
---

## 1. 프로그래밍 패러다임: 절차 지향 vs 객체 지향

### 1-1. 절차 지향 프로그래밍이란?

> **데이터를 처리하는 “순서(절차)”에 초점을 두고 코드를 짜는 방식**

* 프로그램을 “위에서 아래로” 순서대로 읽히는 **명령어들의 나열**로 본다.
* 데이터는 전역 변수나 여러 함수의 인자로 흘러다닌다.
* 초반에 배우는 대부분의 예제가 절차 지향 스타일:

  ```python
  name = "Alice"
  age = 25

  def introduce(name, age):
      print(f"제 이름은 {name}이고, 나이는 {age}입니다.")

  introduce(name, age)
  ```

#### 절차 지향의 특징

* 데이터와 함수가 **따로 떨어져 있다.**

  * 데이터: `name`, `age`
  * 행동: `introduce` 함수
* 프로그램이 커질수록

  * 어떤 함수가 어떤 데이터를 쓰는지,
  * 데이터가 어디서 어떻게 변경되는지
    파악하기 어려워진다.
* 데이터 구조가 바뀌면, 그걸 사용하던 여러 함수를 **전부** 수정해야 할 수도 있다.

---

### 1-2. 객체 지향 프로그래밍이란?

> **데이터와 그 데이터를 다루는 행동을 하나의 덩어리(객체)로 묶어서 생각하는 방식**

* 사람, 계좌, 게시글 같은 **현실 세계의 개념**을 “객체”로 표현한다.
* 객체는

  * **속성(attribute)** : 데이터(상태)
  * **메서드(method)** : 행동(기능)
    을 함께 가진다.

예를 들어 “사람”을 객체로 표현하면:

```python
class Person:
    def __init__(self, name, age):
        self.name = name   # 속성
        self.age = age

    def introduce(self):   # 메서드
        print(f"제 이름은 {self.name}, 나이는 {self.age}입니다.")

alice = Person("Alice", 25)  # 사람 객체 생성
alice.introduce()            # 객체의 행동 호출
```

여기서 느낌 잡기:

* 사람 한 명의 모든 정보(`name`, `age`)와 그 사람이 할 수 있는 행동(`introduce`)이 **한 덩어리로 묶였다.**
* 데이터가 객체 안에 숨어 있기 때문에,

  * “이 객체가 스스로 자기 데이터를 잘 관리한다”는 느낌으로 설계할 수 있다.

---

### 1-3. 절차 지향 vs 객체 지향 관점 차이

* 절차 지향:

  > “**무엇을 먼저 하고, 그다음에 무엇을 할까?**”
  > 흐름(순서)에 집중

* 객체 지향:

  > “**어떤 객체들이 있고, 각각 무슨 역할을 하며, 서로 어떻게 상호작용할까?**”
  > 등장인물(객체)과 역할에 집중

둘은 “누가 더 우월하다”가 아니라 **생각하는 관점**이 다르다.
간단한 스크립트/작은 프로그램→ 절차 지향도 충분
규모가 커지고, 여러 종류의 데이터와 기능이 복잡하게 얽힘 → 객체 지향이 유리

---

## 2. 객체(Object)와 클래스(Class)

### 2-1. 객체(Object)

> **실제로 존재하는 ‘무언가’를 프로그램 안에 표현한 것**

* 속성과 행동을 함께 가진다.
* 예: 학생 객체

  * 속성: 이름, 학번, 전공, 연락처…
  * 행동: 수강신청하기, 휴학신청하기, 자기소개하기…

자료에서는 “가수” 예시가 나온다.

* 속성: 이름, 나이, 데뷔년도, 소속사…
* 행동: 노래하기, 춤추기, 팬싸인회 하기…

### 2-2. 클래스(Class)

> **객체를 만들기 위한 ‘설계도’**

* “가수라는 직업” = 클래스
* “아이유, BTS 멤버들” = 그 클래스로부터 만들어진 **객체(인스턴스)**

클래스는

* 어떤 속성(데이터)을 가질지,
* 어떤 메서드(행동)를 할 수 있을지

를 **미리 정의한 틀**이고,
실제 메모리에 만들어진 각각의 개체가 **인스턴스(instance)**다.

---

## 3. 클래스 정의와 인스턴스 생성

### 3-1. 클래스 기본 형식

```python
class MyClass:
    pass
```

* `class` 키워드 사용
* 이름은 보통 **파스칼 케이스(PascalCase)**: `Person`, `BankAccount` 등

### 3-2. 속성과 메서드가 있는 클래스 예시

```python
class Person:
    # 생성자 메서드 (뒤에서 자세히)
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 인스턴스 메서드
    def introduce(self):
        print(f"안녕하세요, 저는 {self.name}, {self.age}살입니다.")
```

* `self`는 **“자기 자신(해당 인스턴스)”**를 가리키는 관습적인 이름

  * `alice.introduce()`를 호출하면, 내부에서는 `self`가 `alice`를 가리킴
* `__init__`은 **인스턴스가 만들어질 때 자동으로 호출되는 초기화 메서드**

### 3-3. 인스턴스 생성과 사용

```python
alice = Person("Alice", 25)  # Person 클래스로부터 인스턴스 생성
bob   = Person("Bob", 30)

alice.introduce()  # self → alice
bob.introduce()    # self → bob
```

핵심 포인트:

> **클래스는 설계도, 인스턴스는 실제 물건**

---

## 4. 클래스와 인스턴스의 관계 더 깊게 보기

* “가수”라는 글자 자체는 **클래스**
* “아이유는 가수의 인스턴스다”
  (아이유는 객체이면서, 그 객체는 `Singer`라는 클래스의 인스턴스)

파이썬의 모든 값은 사실 객체고,
각각 어떤 클래스의 인스턴스인지 `type()`으로 확인할 수 있다.

```python
name = "Alice"
print(type(name))   # <class 'str'>
```

* `"Alice"`는 `str` 클래스의 인스턴스
* `[1, 2, 3]`은 `list` 클래스의 인스턴스
* `123`은 `int` 클래스의 인스턴스

→ **“파이썬에서 모든 것은 객체다”** 라는 말이 여기서 나온다.

---

## 5. 클래스 변수 vs 인스턴스 변수

### 5-1. 인스턴스 변수

> **각 인스턴스가 개별적으로 가지고 있는 변수**

* `self.name`, `self.age` 처럼 `self`와 함께 정의한다.
* 인스턴스마다 값이 다를 수 있다.

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius   # 인스턴스 변수
```

* `Circle(1)` 과 `Circle(5)`의 `radius`는 서로 다른 값.

### 5-2. 클래스 변수

> **클래스 자체에 속한 변수 (모든 인스턴스가 공유)**

```python
class Circle:
    pi = 3.14   # 클래스 변수

    def __init__(self, radius):
        self.radius = radius
```

* `Circle.pi`로 접근
* `c1.pi`, `c2.pi`로도 보이지만, 실은 둘 다 **같은 값**을 보고 있다.

사용 패턴:

* **클래스 전체에 공통인 값**을 표현할 때
  (ex. 원주율 `pi`, 은행 계좌의 기본 금리, 전체 인원 수 등)

---

## 6. 메서드의 세 종류

OOP에서 **“누가 이 메서드를 주로 쓰게 될까?”**에 따라 세 종류로 나눈다.

1. **인스턴스 메서드**
2. **클래스 메서드**
3. **스태틱(정적) 메서드**

### 6-1. 인스턴스 메서드 (가장 기본)

> **인스턴스의 상태(속성)를 읽거나 바꾸는 메서드**

* 항상 첫 번째 인자로 `self`를 받는다.
* 인스턴스에 종속적인 동작.

```python
class Counter:
    def __init__(self):
        self.count = 0     # 인스턴스 변수

    def increment(self):   # 인스턴스 메서드
        self.count += 1
```

사용:

```python
c = Counter()
c.increment()
print(c.count)  # 1
```

* `c.increment()`라고 부르면 내부적으로는 `Counter.increment(c)`처럼 호출된다.

---

### 6-2. 생성자 메서드 `__init__`

> **인스턴스가 생성될 때 자동으로 호출되는 메서드**

* 엄밀히 말하면 인스턴스 메서드의 일종
* 주로 인스턴스 변수를 초기화하는 역할

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

* `Person("Alice", 25)`를 호출하면

  1. 빈 Person 객체를 만든 뒤
  2. 자동으로 `__init__(self, "Alice", 25)`가 실행된다.

---

### 6-3. 클래스 메서드

> **클래스 자체를 다루는 메서드**
> (클래스 변수에 접근하거나, 인스턴스를 만드는 보조 생성자 역할 등)

* 첫 번째 인자로 `cls`를 받는다.
* `@classmethod` 데코레이터로 정의한다.

```python
class MyClass:
    count = 0   # 클래스 변수

    @classmethod
    def increment_count(cls):
        cls.count += 1
```

사용:

```python
MyClass.increment_count()
print(MyClass.count)
```

* 인스턴스가 없어도, 클래스 이름으로 호출 가능
* 여러 방식으로 객체를 만들고 싶을 때 흔히 쓰는 패턴:

  ```python
  @classmethod
  def from_string(cls, s):
      # 문자열을 파싱해서 cls(...)로 인스턴스 만들어서 반환
      ...
  ```

---

### 6-4. 스태틱(정적) 메서드

> **클래스/인스턴스와 직접적인 관련이 없는 ‘도우미 함수’를 클래스 안에 넣고 싶을 때**

* `cls`나 `self`를 쓰지 않는다.
* **그냥 일반 함수인데, 논리적으로 이 클래스와 관련이 있어서 안에 넣어 둔 것**이라고 보면 된다.
* `@staticmethod` 데코레이터로 정의.

```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

print(MathUtils.add(3, 5))  # 8
```

* 인스턴스 없이도 호출 가능
* 클래스/인스턴스를 건드리지 않으므로, **상태를 전혀 사용하지 않는 순수 함수**에 적합

---

## 7. 예시: BankAccount 클래스로 메서드들 연결해서 이해하기

“입출금이 가능한 은행 계좌” 예시

### 7-1. 설계 아이디어

* 속성

  * 예금주(`owner`)
  * 잔액(`balance`)
* 공통 정보

  * 은행의 이자율(`interest_rate`) → **클래스 변수**
* 행동

  * 입금(`deposit`)
  * 출금(`withdraw`)
  * 이자 계산(`calculate_interest`)
  * 잔액이 양수인지 확인(`is_positive`) – 단순 검사용 → 스태틱 메서드로

### 7-2. 구현 개념

```python
class BankAccount:
    interest_rate = 0.02   # 클래스 변수 (은행 전체 공통 이자율)

    def __init__(self, owner, balance=0):
        self.owner = owner       # 인스턴스 변수
        self.balance = balance   # 인스턴스 변수

    def deposit(self, amount):   # 인스턴스 메서드
        self.balance += amount

    def withdraw(self, amount):  # 인스턴스 메서드
        if amount <= self.balance:
            self.balance -= amount
        else:
            print("잔액 부족")

    @classmethod
    def set_interest_rate(cls, rate):   # 클래스 메서드
        cls.interest_rate = rate

    @staticmethod
    def is_positive(amount):            # 스태틱 메서드
        return amount > 0
```

사용 흐름:

```python
# 계좌 개설
alice_acc = BankAccount("Alice", 1000)

# 입금 / 출금 → 인스턴스 메서드
alice_acc.deposit(500)
alice_acc.withdraw(200)

# 은행 전체 이자율 변경 → 클래스 메서드
BankAccount.set_interest_rate(0.03)

# 단순 값 검사 → 스태틱 메서드
print(BankAccount.is_positive(alice_acc.balance))
```

여기서 정리:

* **“잔액을 바꿔야 하는 동작”** → 인스턴스 메서드 (해당 계좌의 상태를 변경)
* **“은행 전체 정책(이자율) 변경”** → 클래스 메서드 (클래스 변수 수정)
* **“숫자가 양수인지 체크만 하는 유틸 함수”** → 스태틱 메서드 (상태와 무관)

---

## 8. 어떤 메서드를 쓰는 게 맞는지 결정하는 기준

자료에서도 강조하는 부분: “할 수 있다 != 써도 된다”

파이썬에서는 사실

* 인스턴스로 클래스 메서드를 부를 수도 있고,
* 클래스에서 인스턴스 메서드를 직접 호출하는 꼼수도 가능하다.

하지만 **“OOP 설계 관점에서 뭐가 자연스러운지”**가 훨씬 중요하다.

### 결정 기준 정리

1. **인스턴스 메서드**

   * 이 메서드가 **특정 객체의 상태(self.xxx)를 읽거나 바꾸는가?**
   * → 그렇다면 인스턴스 메서드

2. **클래스 메서드**

   * 이 메서드가 **클래스 전체에 공통인 데이터(cls.xxx)를 다루는가?**
   * 또는 **여러 가지 ‘생성 방식’을 제공하는가?**
   * → 그렇다면 클래스 메서드

3. **스태틱 메서드**

   * 이 메서드가 **self, cls 둘 다 필요 없고**,
     단지 이 클래스와 **논리적으로 관련된 유틸 함수**인가?
   * → 그렇다면 스태틱 메서드

---

## 9. 클래스와 인스턴스의 이름 공간(간단 버전)

“OOP 01” 에서는 이름 공간(namespace)을 간단히 소개한다.

핵심만 잡으면:

* **클래스 이름 공간** : 클래스 변수, 메서드들이 저장되는 공간
* **인스턴스 이름 공간** : 각 인스턴스의 인스턴스 변수들이 저장되는 공간

변수를 찾을 때 파이썬은,

> 먼저 인스턴스 → 없으면 클래스 → (상속이 있으면 상위 클래스…) 순서로 찾는다.

그래서 같은 이름을 인스턴스 변수와 클래스 변수에 동시에 둘 수도 있지만,
헷갈리기 때문에 일반적으로는 **역할을 명확히 나누는 편**이 좋다.

---

## 10. (살짝 언급) 매직 메서드와 데코레이터

OOP 01에서는 제목 정도만 나오고 상세 설명은 다음 강의로 넘어가는 부분

### 10-1. 매직 메서드(magic method)

* 이름이 `__something__` 형태인 특수 메서드들
* 예: `__init__`, `__str__`, `__len__`, `__add__` 등
* 파이썬의 여러 문법 요소(+, len(), print(), == …)를 **객체에게 연결해 주는 훅(hook)** 역할

### 10-2. 데코레이터(decorator)

* `@something` 이런 모양으로 함수/메서드 정의 위에 붙이는 문법
* 함수나 메서드를 **자동으로 감싸서 기능을 추가**하는 도구
* `@classmethod`, `@staticmethod`도 사실 **내장 데코레이터**이다.

---

## 11. 오늘 TIL에 적을 한 줄 요약들

1. **절차 지향**은 “무엇을 어떤 순서로 할까”에 집중하고, 데이터와 함수를 분리해서 생각하는 방식이다.
2. **객체 지향**은 “어떤 객체들이 있고, 각자 무슨 속성과 행동을 가지는가”에 집중하며, 데이터와 기능을 객체 안에 묶는다.
3. **클래스**는 객체를 만들기 위한 설계도이고, **인스턴스**는 그 설계도로부터 실제로 만들어진 개별 객체다.
4. **인스턴스 변수**는 각 객체가 개별적으로 가지는 값이고, **클래스 변수**는 클래스 전체가 공유하는 값이다.
5. **인스턴스 메서드**는 `self`를 통해 인스턴스의 상태를 읽거나 바꾸고, **생성자 `__init__`**은 인스턴스가 만들어질 때 초기 설정을 담당한다.
6. **클래스 메서드**는 `cls`를 통해 클래스 변수를 다루거나 다양한 생성 방법(보조 생성자)을 제공하며, 인스턴스 없이도 호출할 수 있다.
7. **스태틱 메서드**는 `self`, `cls`를 쓰지 않는 순수 유틸 함수로, 클래스/인스턴스와 논리적으로만 연관된 기능을 클래스 안에 정리하고 싶을 때 사용한다.
8. “할 수 있다”와 “써도 된다”는 다르다. 메서드 종류는 **누가 주된 주인공인지(인스턴스 / 클래스 / 아무도 아님)** 기준으로 선택하는 것이 객체 지향적인 코드다.

---

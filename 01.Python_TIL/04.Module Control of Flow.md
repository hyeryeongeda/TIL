
---

# 1. 이 챕터의 그림

1. **모듈 / 패키지 / pip**
   → “코드를 여러 파일과 폴더로 나누고, 가져다 쓰는 법”
2. **제어문(Control of Flow)**
   → “조건에 따라 흐름을 바꾸고, 코드를 반복 실행하는 법”

즉,

* *프로그램을 어떻게 구조화해서 나누고(import)*
* *코드를 어떤 순서와 조건으로 흐르게(if / for / while)*

---

# 2. 모듈(Module)

## 2-1. 모듈이란?

> **모듈 = 파이썬 코드(함수, 변수, 클래스 등)가 들어 있는 `.py` 파일 한 개**

* 예: `math.py`, `my_utils.py` 이런 파일 하나가 곧 모듈
* 다른 파일에서 `import` 해서 재사용할 수 있다.
* 장점

  * 코드를 **기능별로 분리**해서 관리하기 좋다.
  * 자주 쓰는 함수들을 모아두고 프로젝트 곳곳에서 불러 쓸 수 있다.

## 2-2. 기본 import

```python
import math

print(math.pi)
print(math.sqrt(9))
```

* `import 모듈명`
  → **모듈 이름을 네임스페이스로 가져온다.**
* 사용할 때는 항상 `math.sqrt`, `math.pi`처럼
  “모듈이름.속성” 형태로 접근.

## 2-3. `from ~ import ~` 사용

### 1) 특정 함수만 가져오기

```python
from math import pi, sqrt

print(pi)
print(sqrt(9))
```

* `from math import sqrt`
  → `sqrt`만 현재 파일의 이름공간으로 가져옴
* 모듈명 없이 바로 `sqrt(9)`처럼 쓸 수 있다.

### 2) as로 별명 주기

```python
import math as m

print(m.sqrt(16))
```

* 모듈 이름이 길거나, 짧은 관용 표기가 있을 때 사용 (`import numpy as np` 같은 것)

### 3) `from 모듈 import *` (와일드카드)

```python
from math import *
```

* 모듈 안의 **공개된 이름**을 전부 불러옴
* 편해 보이지만,

  * 네임스페이스를 어지럽히고
  * 어떤 이름이 어디서 왔는지 헷갈리게 한다.
* 실무에서는 **거의 안 쓰는 방식**이라고 생각하면 편하다.

---

## 2-4. 사용자 정의 모듈

내가 직접 만든 `.py` 파일도 모듈이다.

예를 들어, 같은 폴더에 `my_math.py`:

```python
# my_math.py
def add(a, b):
    return a + b

def sub(a, b):
    return a - b
```

그리고 다른 파일에서:

```python
# sample.py
import my_math

print(my_math.add(3, 5))
```

또는

```python
from my_math import add

print(add(3, 5))
```

이렇게 **내가 만든 함수들을 모아서 다른 파일에서 재사용**할 수 있다.

---

# 3. 파이썬 표준 라이브러리 & 패키지

## 3-1. 파이썬 표준 라이브러리

> 파이썬이 기본으로 제공하는 모듈/패키지 모음집

* 예: `math`, `random`, `datetime`, `os`, `sys` 등
* 별도 설치 없이 바로 `import` 해서 사용 가능
* 공식 문서 사이트에 각 모듈의 기능들이 정리되어 있다.

실제로 개발할 때는,
“이 기능, 이미 표준 라이브러리에 있는지?”
를 먼저 떠올리고 검색해서 쓰는 습관이 중요하다.

## 3-2. 패키지(Package) 개념

> **패키지 = 모듈(파이썬 파일들)을 폴더 구조로 묶어 놓은 것**

* “폴더 = 패키지”, “폴더 안의 `.py` 파일들 = 그 패키지 안의 모듈”
* 예시 구조:

```text
my_package/
    __init__.py (있을 수도 있고, 없을 수도 있음 – 최근엔 없어도 패키지로 인식)
    math_tools.py
    statistics/
        __init__.py
        tools.py
```

사용 예:

```python
from my_package import math_tools
from my_package.statistics import tools
```

이렇게 하면

* 코드가 **기능별, 주제별 폴더 구조**로 깔끔하게 나뉘고,
* 이름이 겹쳐도 `my_package.math_tools`, `other_package.math_tools`처럼
  **경로로 구분**할 수 있다.

---

# 4. pip와 외부 패키지

## 4-1. pip란?

> **pip = 파이썬 패키지 관리 도구**
> (외부에서 만든 라이브러리를 설치/삭제할 때 사용하는 명령어)

터미널에서:

```bash
pip install SomePackage
pip install SomePackage==1.2.3   # 특정 버전 설치
pip install SomePackage>=1.0     # 최소 버전 지정
```

설치 후에는 그냥 `import` 해서 사용한다.

## 4-2. 예: requests 패키지

```bash
pip install requests
```

사용 예:

```python
import requests

url = 'https://date.nager.at/api/v2/publicholidays/2023/KR'
response = requests.get(url)
print(response.text)
```

* `requests`는 HTTP 요청을 간단하게 보내게 해주는 외부 라이브러리.
* 이런 식으로 **필요한 기능이 있으면 패키지를 찾아서 pip로 설치 → import해서 사용**하는 흐름이다.

---

# 5. 제어문(조건문 + 반복문)

## 5-1. 제어문이란?

> **제어문 = 코드의 실행 흐름을 조건에 따라 제어하는 문법**

* “어떤 조건이면 이 코드 실행, 아니면 저 코드 실행” → **조건문**
* “어떤 코드를 여러 번 반복해서 실행” → **반복문**

파이썬에서 제어문은 **들여쓰기(indent)**를 이용해서 코드 블록을 구분한다.
(중괄호 `{}` 대신 들여쓰기를 쓰는 언어)

---

# 6. 조건문 if / elif / else

## 6-1. 기본 형태

```python
if 조건식:
    # 조건이 참(True)일 때 실행할 코드
elif 다른_조건식:
    # 위 if가 거짓이고, 이 조건이 참일 때 실행
else:
    # 위 모든 조건이 거짓일 때 실행
```

* `elif`는 필요할 만큼 여러 개 쓸 수 있다.
* `else`는 선택 사항 (없어도 됨).

## 6-2. 예시: 점수에 따라 메세지 출력

```python
score = 87

if score >= 90:
    print('A입니다.')
elif score >= 80:
    print('B입니다.')
elif score >= 70:
    print('C입니다.')
else:
    print('D입니다.')
```

* 위에서부터 차례로 조건을 검사하고,
* **처음으로 참이 되는 조건의 블록만 실행**한 뒤 나머지는 건너뛴다.

## 6-3. if 안의 조건식

* 파이썬에서는 숫자, 리스트, 문자열 등도 **참/거짓처럼 평가**된다.

  * 0, 빈 문자열 `''`, 빈 리스트 `[]`, `None` → False
  * 그 외 값들은 대부분 True
* 그래서 아래처럼도 쓸 수 있다:

```python
name = input('이름을 입력하세요: ')

if name:   # 비어 있지 않으면 True
    print(f'{name}님 환영합니다!')
else:
    print('이름을 입력하지 않았습니다.')
```

---

# 7. 반복문 – for / while

## 7-1. 반복문의 개념

> **반복문 = 같은 코드 블록을 여러 번 실행할 때 사용하는 구문**

종류는 크게 두 가지:

1. **for 반복문**:

   * “컬렉션·범위” 같은 **반복 가능한 객체(iterable)**의 각 요소를 꺼내면서 반복
2. **while 반복문**:

   * 주어진 **조건이 참인 동안** 계속 반복

---

## 7-2. for 반복문

### 1) 기본 형태

```python
for 변수 in 반복가능한_객체:
    실행할 코드
```

* `변수`에는 반복할 때마다 **하나씩 꺼낸 요소 값**이 들어간다.

예:

```python
students = ['Alice', 'Bob', 'Charlie']

for student in students:
    print('Hello,', student)
```

### 2) 반복 가능한 객체(iterable)

* 리스트, 튜플, 문자열, range, 딕셔너리, 세트 등
  → **하나씩 꺼낼 수 있는 것들**

#### (1) 문자열 순회

```python
for ch in 'python':
    print(ch)
```

#### (2) range와 함께 사용

```python
for i in range(5):      # 0,1,2,3,4
    print(i)

for i in range(1, 6):   # 1~5
    print(i)
```

#### (3) 인덱스 + 값 동시에 쓰고 싶을 때 – enumerate

```python
students = ['Alice', 'Bob', 'Charlie']

for idx, name in enumerate(students, start=1):
    print(idx, name)
```

* `enumerate(반복가능한객체, start=시작번호)`
  → (인덱스, 값) 튜플을 하나씩 꺼내 준다.

#### (4) 딕셔너리 순회

```python
my_dict = {'a': 1, 'b': 2, 'c': 3}

for key in my_dict:           # 기본은 key만 순회
    print(key, my_dict[key])

for key, value in my_dict.items():  # key, value 같이 순회
    print(key, value)
```

---

## 7-3. while 반복문

### 1) 기본 형태

```python
while 조건식:
    실행할 코드
```

* **조건식이 참인 동안** 계속 반복
* 조건이 언젠가 False가 되게 만들어야 반복이 끝난다.

### 2) 예시: 1부터 3까지 출력

```python
n = 1

while n <= 3:
    print(n)
    n += 1
```

### 3) 사용자 입력을 반복해서 받는 경우

```python
while True:         # 일단 무한 루프
    number = int(input('양수를 입력하세요(0 입력 시 종료): '))
    if number == 0:
        print('종료합니다.')
        break
    elif number > 0:
        print('좋아요,', number)
    else:
        print('양수가 아닙니다.')
```

* 이런 패턴에서 **종료 조건**을 잘 설계하는 게 핵심이다.

---

# 8. 반복 제어: break / continue / pass

## 8-1. break

> **현재 반복문을 “즉시” 종료**

```python
for i in range(10):
    if i == 5:
        break
    print(i)
# 0 1 2 3 4까지만 출력
```

* `for` 안이든 `while` 안이든, break를 만나면 **가장 가까운 반복문 하나를 바로 빠져나온다.**

## 8-2. continue

> **이번 회차만 건너뛰고, 다음 반복으로 넘어감**

```python
for i in range(1, 6):
    if i % 2 == 0:   # 짝수면 건너뛰기
        continue
    print(i)
# 1 3 5만 출력
```

* 반복문은 끝내지 않고 계속 진행하되,
  한 번의 루프 안에서 남은 코드를 스킵하고 싶을 때 사용한다.

## 8-3. pass

> **“아무 것도 하지 않음”을 표현하는 키워드**

* 문법적으로 뭔가가 와야 하는데
  *아직 구현은 안 했을 때* 자리를 채우는 용도

```python
def todo():
    pass    # 나중에 구현 예정

for i in range(10):
    if i < 5:
        pass    # 일단 조건만 잡아놓고, 나중에 코드 채우기
```

---

# 9. for-else 문

파이썬에만 있는 조금 특이한 패턴.

```python
for item in iterable:
    if 조건:
        # 원하는 걸 찾으면
        break
else:
    # break가 한 번도 실행되지 않았을 때만 실행되는 블록
```

* 즉,

  * **반복이 정상적으로 끝났을 때** 실행
  * **break로 중간에 끊기면 실행되지 않음**

예시: 어떤 숫자가 리스트에 있는지 찾기

```python
numbers = [1, 3, 5, 7]

target = 4
for n in numbers:
    if n == target:
        print('찾았다!')
        break
else:
    print('리스트에 없음')
```

---

# 10. 유용한 내장 함수: map / zip / enumerate

## 10-1. map(function, iterable)

> **반복 가능한 객체의 각 요소에 함수를 적용한 결과를 돌려주는 함수**

```python
numbers = [1, 2, 3]
result = map(str, numbers)
print(list(result))    # ['1', '2', '3']
```

* `map` 자체는 “게으른” 객체 → 보통 `list(...)`로 감싸서 한 번에 변환한다.
* 자주 쓰는 패턴: **입력값을 한 번에 int로 바꿀 때**

```python
# '1 2 3' 입력 → [1, 2, 3]으로
numbers = list(map(int, input().split()))
```

## 10-2. zip(*iterables)

> 여러 iterable의 요소들을 **같은 인덱스끼리 묶어서** 튜플로 만들어 준다.

```python
names = ['Amy', 'Jake', 'Rosa']
scores = [90, 85, 95]

students = list(zip(names, scores))
print(students)
# [('Amy', 90), ('Jake', 85), ('Rosa', 95)]
```

* 서로 관련 있는 여러 리스트를 **행 단위로 묶고 싶을 때** 아주 유용하다.
* 튜플을 다시 풀 때는 언패킹을 사용 가능.

```python
for name, score in zip(names, scores):
    print(name, score)
```

---

# 11. 이 챕터 TIL 요약 정리

오늘 내용, TIL에 딱 들어갈 정도로 한 번에 정리하면:

1. **모듈**은 `.py` 파일 하나이고, `import` / `from ~ import ~`으로 다른 파일의 코드를 재사용할 수 있다.
2. **패키지**는 모듈들을 폴더 구조로 묶어 놓은 것이고, 표준 라이브러리와 `pip`로 설치한 외부 패키지를 함께 활용해 개발 생산성을 높인다.
3. **조건문(if / elif / else)**로 상황에 따라 다른 코드를 실행하고, 들여쓰기로 블록을 구분한다.
4. **반복문(for / while)**로 코드를 여러 번 실행하며, `for`는 iterable을 순회하고 `while`은 조건이 참인 동안 반복한다.
5. **break / continue / pass**로 반복 흐름을 세밀하게 제어하고, `for-else`를 이용해 “끝까지 찾지 못했을 때”의 처리도 깔끔하게 할 수 있다.
6. **map / zip / enumerate** 같은 내장 함수는 입력 처리, 데이터 변환, 인덱스와 값 동시 사용에 매우 유용하니, 습관처럼 자주 써보면서 몸에 익히는 게 중요하다.

---

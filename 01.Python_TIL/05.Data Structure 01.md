
---

## 1. 데이터 구조(자료구조) 큰 그림

### 1) 데이터 구조가 왜 필요해?

코드에서 다루는 건 결국 “데이터 덩어리”야.

* 책 목록, 학생 명단, 일정, 점수 리스트, 게시글 모음…
* 이런 걸 잘 관리하려면 “어떤 형태로 담을지”가 중요해.
* 그 “형태”가 바로 **데이터 구조(data structure)**.

예를 들어,

> “읽고 싶은 책 3권을 한 곳에 모아서 관리하고 싶다”

* 그냥 책 제목을 변수 세 개에 넣을 수도 있음
  `book1 = 'Clean Code'`, `book2 = '리팩터링'`, …
* 그런데 개수가 많아지면? → 관리 지옥
* 그래서 **리스트, 딕셔너리, 튜플, 세트** 같은 구조를 사용해서
  **한 덩어리로 묶어 관리**하는 거야.

데이터 구조를 잘 써야:

* 필요한 데이터를 **빨리 찾고**,
* **추가/수정/삭제**가 편하고,
* 코드가 **짧고 읽기 쉬워진다.**

---

## 2. 메서드(method) – “데이터가 들고 있는 함수”

### 1) 메서드란?

> **객체에 속해 있는 함수**

조금 감으로 말하면,

* `str`, `list` 같은 데이터 타입(객체) 옆에 붙어 있는
* “얘를 다루기 위해 준비된 도우미 함수들”

이라고 보면 된다.

```python
'hello'.capitalize()
[1, 2, 3].append(4)
```

* `'hello'`라는 문자열 객체가 `capitalize()`라는 메서드를 가지고 있음
* `[1, 2, 3]` 리스트 객체가 `append()`라는 메서드를 가지고 있음

형태는 항상

> `데이터.메서드(인자들...)`

메서드는 **그 타입을 가장 자연스럽게 다루는 기능들**이 모여 있는 패키지 느낌이야.

---

## 3. 시퀀스 데이터 구조 – 문자열 메서드 정리

문자열도 **시퀀스**이자 **불변(immutable)** 데이터 구조라서,
각종 조회/검사/변환 메서드가 많이 붙어 있다.

### 3-1. 조회/검색 계열

#### (1) `find(x)`

> 문자열에서 `x`가 **처음 등장하는 위치(인덱스)** 반환, 없으면 `-1`

```python
text = 'banana'
text.find('a')   # 1
text.find('x')   # -1
```

* “없을 때 에러 내지 말고 -1 달라”일 때 사용

#### (2) `index(x)`

> 문자열에서 `x`가 **처음 등장하는 인덱스** 반환, 없으면 **에러**

```python
text.index('a')   # 1
text.index('x')   # ValueError 발생
```

* “무조건 있어야 하는 값”을 찾을 때 → 없으면 바로 에러로 알리고 싶을 때

---

### 3-2. 대소문자 관련 검사

#### (1) `isupper()`, `islower()`

> 문자열이 **전부 대문자인지 / 전부 소문자인지** 검사

```python
'HELLO'.isupper()   # True
'Hello'.isupper()   # False
'hello'.islower()   # True
'Hello'.islower()   # False
```

* 공백이나 숫자가 섞여 있으면 상황에 따라 False가 나올 수 있어서
  “문자 종류”까지 포함해서 체크하고 싶으면 다른 메서드와 같이 써야 한다.

#### (2) `isalpha()`

> **알파벳 문자만**으로 이루어져 있는지 확인

```python
'abc'.isalpha()     # True
'abc123'.isalpha()  # False
'123'.isalpha()     # False
```

* 아이디, 이름 등 “영문자만 허용” 규칙 체크할 때 쓰기 좋음.

---

### 3-3. 문자열 변환 메서드

문자열은 **불변**이라,
이 메서드들은 원본을 바꾸지 않고 **새 문자열을 만들어서 돌려준다.**

자주 쓰는 것만 개념 기억해두자.

* `upper()` : 모두 대문자로
* `lower()` : 모두 소문자로
* `capitalize()` : 첫 글자만 대문자
* `title()` : 단어마다 첫 글자 대문자
* `swapcase()` : 대↔소문자 뒤집기
* `strip([chars])` : 양쪽 끝의 공백이나 지정 문자 제거
* `replace(old, new[, count])` : 문자열 일부 교체
* `split(sep=None, maxsplit=-1)` : 구분자로 나눠 **리스트**로
* `'구분자'.join(iterable)` : 리스트 등을 **구분자를 끼워 넣어 문자열로 합치기**

#### (1) `replace(old, new, count=None)`

```python
text = 'hello, world, world'
text.replace('world', 'python')      # 'hello, python, python'
text.replace('world', 'python', 1)   # 'hello, python, world'
```

#### (2) `strip([chars])`

> 양쪽 끝에서부터 **주어진 문자들이 아닌 것이 나올 때까지 제거**

```python
text = '   hello   '
text.strip()        # 'hello'

text = '---hello---'
text.strip('-')     # 'hello'
```

#### (3) `split(sep=None, maxsplit=-1)`

> 구분자를 기준으로 문자열을 쪼개서 리스트로 반환

```python
line = 'a,b,c'
line.split(',')     # ['a', 'b', 'c']

words = 'hello   python  world'
words.split()       # 공백 기준 → ['hello', 'python', 'world']
```

#### (4) `'separator'.join(iterable)`

> 리스트/튜플 같은 반복 가능한 객체를 **중간중간에 구분자를 끼워 넣어 하나의 문자열로 합치기**

```python
names = ['kim', 'lee', 'park']
', '.join(names)    # 'kim, lee, park'
```

입출력/파일 처리할 때 굉장히 많이 쓰는 메서드들이다.

---

## 4. 리스트(list) – 메서드 중심으로 정리

리스트는 **가변(mutable) 시퀀스**.
그래서 요소를 추가/삭제/정렬하는 메서드가 아주 많다.

### 4-1. 요소 추가/삭제 관련

#### (1) `append(x)`

> 리스트 **맨 뒤에** 요소 하나 추가

```python
nums = [1, 2, 3]
nums.append(4)
# [1, 2, 3, 4]
```

#### (2) `extend(iterable)`

> 다른 반복 가능한 객체의 **모든 요소를 뒤에 이어 붙이기**

```python
nums = [1, 2, 3]
nums.extend([4, 5])
# [1, 2, 3, 4, 5]
```

* `append`랑 비교하기!

```python
nums = [1, 2, 3]
nums.append([4, 5])
# [1, 2, 3, [4, 5]]  ← 리스트 하나가 통째로 들어감

nums = [1, 2, 3]
nums.extend([4, 5])
# [1, 2, 3, 4, 5]     ← 요소가 풀려서 들어감
```

#### (3) `insert(i, x)`

> 인덱스 `i` 위치에 `x` 삽입 (뒤 요소들은 한 칸씩 밀림)

```python
nums = [1, 3, 4]
nums.insert(1, 2)
# [1, 2, 3, 4]
```

#### (4) `remove(x)`

> 값이 `x`인 **첫 번째 요소** 삭제

```python
nums = [1, 2, 2, 3]
nums.remove(2)
# [1, 2, 3]   (맨 앞 2만 삭제)
```

* `x`가 없으면 `ValueError`.

#### (5) `pop(i=-1)`

> 인덱스 `i`의 요소를 **삭제하면서 반환**

```python
nums = [1, 2, 3, 4]
last = nums.pop()   # 기본은 맨 뒤
# last = 4, nums = [1, 2, 3]

first = nums.pop(0) # 맨 앞 요소 빼내기
# first = 1, nums = [2, 3]
```

#### (6) `clear()`

> 리스트의 **모든 요소 삭제** (빈 리스트로 만듦)

```python
nums = [1, 2, 3]
nums.clear()
# []
```

---

### 4-2. 검색 / 정렬 / 기타

#### (1) `index(x)`

> 값 `x`가 **처음 등장하는 인덱스** 반환, 없으면 에러

```python
nums = [1, 2, 3]
nums.index(2)   # 1
```

#### (2) `count(x)`

> 값 `x`가 **몇 개 있는지** 개수 반환

```python
nums = [1, 2, 2, 3]
nums.count(2)   # 2
```

#### (3) `reverse()`

> 리스트를 **제자리에서 역순으로 뒤집기**

```python
nums = [1, 2, 3]
nums.reverse()
# [3, 2, 1]
```

#### (4) `sort(*, reverse=False)`

> 원본 리스트를 **제자리에서 정렬**

```python
nums = [3, 1, 2]
nums.sort()
# [1, 2, 3]

nums.sort(reverse=True)
# [3, 2, 1]
```

* 정렬된 **새 리스트가 필요하면** 내장 함수 `sorted()`를 사용
  (원본은 그대로, 새 리스트만 생성)

---

## 5. 객체와 참조, 가변/불변, 복사

여기부터는 “리스트를 제대로 다루려면 반드시 알아야 하는 개념” 구간.

### 5-1. mutable / immutable

* **immutable(불변)** : 한 번 만들어지면 내용이 바뀌지 않는 객체
  → `int`, `float`, `str`, `tuple`, `range` 등
* **mutable(가변)** : 내용이 바뀔 수 있는 객체
  → `list`, `dict`, `set` 등

예시:

```python
# 불변 예시
a = 10
b = a
b = 20
# a는 여전히 10

# 가변 예시
lst1 = [1, 2, 3]
lst2 = lst1
lst2[0] = 100
# lst1도 [100, 2, 3] 으로 바뀜
```

포인트:

> **가변 객체는 “같은 걸 가리키고 있으면” 한쪽을 고쳤을 때 다른 쪽도 바뀐다.**

### 5-2. 파이썬에서의 “참조”

* 변수에는 실제 값이 아니라 **객체가 있는 메모리 주소(참조)**가 저장된다.
* `lst2 = lst1`이라고 하면,
  **둘 다 같은 리스트 객체를 가리키는 것**.

`id()`로 “참조가 같은지” 확인 가능:

```python
lst1 = [1, 2, 3]
lst2 = lst1

id(lst1) == id(lst2)  # True
```

---

## 6. 얕은 복사(Shallow Copy)

> **겉 껍데기만 새로 만들고, 안에 들어 있는 요소들은 같은 객체를 가리키는 복사**

### 6-1. 만드는 방법

* 슬라이싱: `new_list = old_list[:]`
* 생성자: `new_list = list(old_list)`
* `copy` 모듈의 `copy.copy()` 사용

```python
import copy

old = [1, 2, 3]
shallow = copy.copy(old)
```

### 6-2. 단일 리스트에서의 얕은 복사

```python
a = [1, 2, 3]
b = a[:]        # 얕은 복사

b[0] = 100
print(a)        # [1, 2, 3]  (안 바뀜)
print(b)        # [100, 2, 3]
```

* 이 경우엔 각 요소가 전부 `int`(불변)라서
  “같은 숫자 객체를 가리키든 말든” 상관이 없음.

### 6-3. 중첩 리스트에서의 문제점

> 리스트 안에 **리스트가 또 들어 있을 때** 얕은 복사의 한계가 드러난다.

```python
a = [[1, 2], [3, 4]]
b = a[:]        # 얕은 복사

b[0][0] = 100
print(a)        # [[100, 2], [3, 4]]
print(b)        # [[100, 2], [3, 4]]
```

* 바깥 리스트(`[]`)는 새로 만들어졌지만
  안쪽 리스트 `[1, 2]`, `[3, 4]`는 **같은 객체**를 공유하고 있기 때문.

즉,

> **“겉 리스트만 새로, 안쪽 요소(객체)들은 그대로 공유” → 얕은 복사**

이게 문제라서 **깊은 복사**가 필요해진다.

---

## 7. 깊은 복사(Deep Copy)

> **겉 리스트뿐 아니라, 그 안에 들어 있는 리스트/객체들까지 전부 새로 복사하는 것**

### 7-1. 만드는 방법

`copy` 모듈의 `deepcopy` 사용:

```python
import copy

a = [[1, 2], [3, 4]]
b = copy.deepcopy(a)

b[0][0] = 100
print(a)  # [[1, 2], [3, 4]]
print(b)  # [[100, 2], [3, 4]]
```

* 이제 완전히 독립된 구조라, 한쪽을 수정해도 다른 쪽은 그대로.

### 7-2. 언제 깊은 복사가 필요할까?

* 리스트 안에 리스트, 딕셔너리, 세트 등
  **가변 객체가 중첩**돼 있을 때
* “원본이랑 완전히 독립적인 복사본”이 꼭 필요할 때

---

## 8. List Comprehension – 리스트 한 줄 생성법

> **“for 반복문 + 조건 + append” 패턴을 한 줄로 줄인 문법**

### 8-1. 기본 형태

```python
[표현식 for 변수 in iterable]
[표현식 for 변수 in iterable if 조건식]
```

예:

```python
# 0~9까지 제곱 리스트
squares = [x**2 for x in range(10)]
# 짝수만 제곱
even_squares = [x**2 for x in range(10) if x % 2 == 0]
```

### 8-2. 기존 for문과 비교

일반적으로라면:

```python
result = []
for x in range(10):
    if x % 2 == 0:
        result.append(x**2)
```

comprehension으로:

```python
result = [x**2 for x in range(10) if x % 2 == 0]
```

* **짧고 간결하게** 쓸 수 있다는 게 장점.
* 다만, 너무 복잡하게 쓰면 **읽기 어려운 한 줄 짜 괴물 코드**가 될 수 있음.

그래서 기억해두기:

> “짧고 명확할 때만 사용하고,
> 복잡해지면 그냥 for문으로 풀어 쓰자.”

---

## 9. 메서드 체이닝(Method Chaining)

> **객체.메서드().메서드().메서드()… 처럼 메서드를 줄줄이 이어서 호출하는 방식**

예:

```python
text = '   hello, world   '
result = text.strip().replace('hello', 'hi').upper()
# 1. strip() → 'hello, world'
# 2. replace(...) → 'hi, world'
# 3. upper() → 'HI, WORLD'
```

조건:

* 각 메서드가 **자기 자신과 같은 타입의 객체를 반환**해야 함
  (그래야 다시 그 위에 메서드를 이어서 호출할 수 있음)

장점:

* 중간 변수를 여러 개 만들지 않고,
  “데이터가 변형되어 가는 흐름”을 한눈에 볼 수 있다.

단점:

* 너무 길어지면 디버깅과 가독성이 떨어질 수 있음 → 적당히 끊어서 쓰기.

---

## 10. 마지막으로, 오늘 TIL에 적을 핵심 문장 정리

1. **데이터 구조**는 데이터를 효율적으로 저장·검색·수정하기 위한 “형태”이고, 리스트·문자열·딕셔너리 같은 타입이 이에 해당한다.
2. **메서드**는 특정 데이터 타입이 들고 있는 함수로, `데이터.메서드()` 형태로 호출하며, 문자열·리스트 각각의 전용 메서드를 잘 활용하면 코드가 훨씬 간결해진다.
3. 문자열 메서드는 주로 **검색(find/index)**, **검사(isupper/islower/isalpha)**, **변환(replace/strip/split/join)** 역할을 한다.
4. 리스트 메서드는 **추가/삭제(append, extend, insert, remove, pop, clear)**와 **검색/정렬(index, count, reverse, sort)** 위주로 정리해두면 된다.
5. 파이썬에서 변수는 **객체를 가리키는 참조**를 저장하고, 가변/불변 타입 차이 때문에 복사 방식(얕은 복사 vs 깊은 복사)에 따라 원본이 함께 바뀔 수 있다.
6. **얕은 복사**는 겉 껍데기만 새로 만들고 안쪽 가변 객체는 공유하고, **깊은 복사**는 내부 객체까지 전부 새로 만들어 완전히 독립된 복사본을 만든다.
7. **List Comprehension**은 간단한 리스트 생성에만 사용하고, 복잡해지면 평범한 for문이 오히려 더 읽기 쉽다.
8. **메서드 체이닝**은 “데이터 변환 흐름”을 한 줄로 깔끔하게 표현하지만, 너무 길어지면 가독성이 떨어지므로 적당히 끊어 쓰는 감각이 필요하다.

---

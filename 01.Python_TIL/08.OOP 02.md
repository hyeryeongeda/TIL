
---

# 1. 상속(Inheritance) – 이미 있는 클래스를 물려받아 확장하기

## 1-1. 상속의 한 줄 정의

> **상속 = 한 클래스(부모/상위 클래스)의 속성과 메서드를 다른 클래스(자식/하위 클래스)가 물려받는 것**

* 부모 클래스: 공통적인 속성과 기능을 정의
* 자식 클래스: 부모 것을 **그대로 사용 + 필요하면 수정/추가**

예를 들어,

* 부모: `Animal`

  * 공통 속성: 이름
  * 공통 메서드: `eat()`
* 자식: `Dog`, `Cat`

  * Dog만의 메서드: `bark()`
  * Cat만의 메서드: `meow()`

이런 구조를 상속으로 표현하는 것.

---

## 1-2. 상속이 왜 필요한가?

자료에서 정리한 상속의 목적을 내 말로 풀면:

1. **코드 재사용성**

   * 공통 부분을 부모 클래스에 한 번만 정의해두고
     자식 클래스들이 물려받아서 사용 → 중복 코드 감소

2. **계층 구조 설계**

   * “사람 → 학생, 직원”,
     “동물 → 포유류 → 강아지/고양이”처럼
     현실 세계의 구조를 그대로 코드에 반영할 수 있음

3. **유지보수, 확장성**

   * 공통 로직을 부모 클래스에서 고치면
     자식 클래스들이 자동으로 영향을 받음
   * 새로운 유형이 생겨도 기존 부모를 상속받아서 조금만 수정/추가하면 됨

---

## 1-3. 상속 기본 문법

```python
class Parent:
    def __init__(self, name):
        self.name = name

    def introduce(self):
        print(f'안녕, 나는 {self.name}야')

class Child(Parent):  # 괄호 안에 상속받을 부모 클래스 이름
    pass

c = Child('혜령')
c.introduce()  # 부모의 메서드를 그대로 사용
```

* `class Child(Parent):`
  → Child는 Parent를 상속받는다.

자식 클래스는

* 부모의 속성과 메서드를 **그대로 쓸 수 있고**
* 원하면 일부만 **재정의(오버라이딩)** 할 수도 있고
* 자기만의 **새 속성/메서드**를 추가할 수도 있다.

---

# 2. 메서드 오버라이딩(Method Overriding)

## 2-1. 개념

> **부모 클래스에 있는 메서드를, 자식 클래스에서 “같은 이름으로 다시 정의하는 것”**

목적:

* 기본 동작은 좋지만, 자식 입장에서 **조금 다르게 행동**시키고 싶을 때

```python
class Animal:
    def sound(self):
        print('동물이 소리를 낸다')

class Dog(Animal):
    def sound(self):                # 메서드 오버라이딩
        print('멍멍!')

dog = Dog()
dog.sound()   # '멍멍!'
```

* `Dog`가 `Animal`의 `sound()`를 덮어쓴 상황.

## 2-2. 오버라이딩 시 주의

* **이름과 매개변수 시그니처를 맞춰야 한다.**
  (부모가 `sound(self)`인데 자식이 `sound(self, x)` 이렇게 바꿔버리면
  호출하는 쪽에서 에러 날 수 있음)
* 보통은 부모 메서드의 기능을 **확장**하고 싶을 때가 많아서
  `super()`로 부모 메서드를 먼저 호출한 뒤, 추가 작업을 한다.

```python
class Person:
    def talk(self):
        print('사람이 말합니다.')

class Student(Person):
    def talk(self):
        super().talk()  # 부모 동작 먼저
        print('학생입니다. 전공은 파이썬!')
```

---

## 2-3. 오버로딩(Overloading)과의 차이

자료에 **오버로딩** 단어도 잠깐 나오는데, 파이썬에서는 C++/Java처럼 “이름은 같고 매개변수 개수만 다른 여러 메서드”를 진짜로 지원하지는 않는다.

* 대신 **기본값 인자, *args, **kwargs**로 “비슷한 효과”를 만든다.

```python
class Greeter:
    def hello(self, name=None):
        if name is None:
            print('안녕!')
        else:
            print(f'{name}님, 안녕!')
```

* 이런 식으로 “인자 개수/타입에 따라 내부에서 분기”하는 게 파이썬식 오버로딩 패턴.

---

# 3. 다중 상속(Multiple Inheritance)

## 3-1. 개념

> **하나의 자식 클래스가 여러 부모 클래스를 동시에 상속받는 것**

```python
class ParentA:
    def method_a(self):
        print('A')

class ParentB:
    def method_b(self):
        print('B')

class Child(ParentA, ParentB):  # 다중 상속
    pass

c = Child()
c.method_a()  # ParentA로부터
c.method_b()  # ParentB로부터
```

장점:

* 서로 다른 역할을 하는 여러 클래스를 조합해서
  “믹스인(mixin)” 느낌으로 기능을 합칠 수 있다.

단점/주의:

* 메서드 이름이 겹칠 때 “어느 부모의 메서드를 쓸지”가 복잡해진다.
  → **다이아몬드 문제(diamond problem)**
* 이때 파이썬은 **MRO(Method Resolution Order)** 라는 규칙으로
  메서드를 찾는 순서를 정한다.

---

## 3-2. 다이아몬드 문제 & MRO

자료의 그림을 말로 표현하면:

* A가 최상위 부모이고
* B, C가 각각 A를 상속받고
* D가 다시 B와 C를 동시에 상속받는 구조

여기서 D에서 어떤 메서드 `m()`을 호출하면:

* A, B, C 중 누구의 `m()`을 먼저 쓸까?
* 중복 호출은 어떻게 피할까?

이걸 해결하기 위해 파이썬은 **MRO**를 쓴다.

> **MRO = 메서드를 탐색하는 순서**

클래스마다 `__mro__` 또는 `mro()` 메서드로 순서를 확인할 수 있다.

```python
print(Child.__mro__)
# (<class '__main__.Child'>, <class '__main__.ParentA'>,
#  <class '__main__.ParentB'>, <class 'object'>)
```

MRO 덕분에:

* 다중 상속에서도 **일관된 순서**로 메서드를 찾고,
* `super()`가 어떤 부모를 호출해야 할지 알게 된다.

---

# 4. super() – 부모 메서드를 우아하게 호출하기

## 4-1. super()의 역할

> **현재 클래스의 MRO를 기준으로, “다음 클래스”의 메서드를 호출할 수 있게 해주는 도우미**

단일 상속에서도 쓰이지만,
특히 **다중 상속에서 강력**해진다.

```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name)   # Parent.__init__(self, name) 대신
        self.age = age
```

장점:

1. **부모 클래스 이름을 하드코딩하지 않아도 된다.**

   * 나중에 상속 구조를 바꿔도 `super()` 기반이면 코드 수정이 훨씬 적다.
2. **MRO를 자동으로 따라간다.**

   * 다중 상속 구조에서 각 부모의 `__init__`이 **한 번씩만** 호출되도록 설계 가능.

---

## 4-2. 단일 상속에서 super()

단일 상속에서는 대체로:

* 자식 `__init__`에서 부모 `__init__` 호출할 때,
* 또는 자식 메서드에서 부모 메서드 내용도 함께 실행하고 싶을 때 사용.

```python
class Student(Person):
    def __init__(self, name, age, student_id):
        super().__init__(name, age)   # Person 초기화
        self.student_id = student_id
```

---

## 4-3. 다중 상속에서 super()

자료의 예시는 “ParentA, ParentB, Child” 구조에서 `super()`가 어떻게 돌아가는지 보여준다.

핵심 요약:

1. `super()`는 “부모 하나”가 아니라 MRO 상의 **다음 클래스**를 호출한다.
2. 각 클래스에서 `super()`를 올바르게 호출하면,

   * 다중 상속 구조에서도 각 부모의 메서드가 **중복 없이, 순서대로** 실행된다.

즉, 다중 상속을 쓸 거라면:

* 각 클래스의 `__init__`에서 `super().__init__()`을 부르는 **협력적인 초기화 패턴**이 중요하다.
* 임의로 `ParentA.__init__(self)`를 직접 부르는 방식은 다이아몬드 구조에서 충돌/중복 호출 위험이 있다.

---

# 5. 에러와 예외, 디버깅

## 5-1. 버그와 디버깅

* **버그(bug)** : 프로그램이 의도와 다르게 동작하게 만드는 오류
* **디버깅(debugging)** : 버그를 찾고 수정하는 과정

자료에서 소개한 디버깅 방법들:

1. **print로 값 찍어보기**
2. IDE/에디터의 **디버거** 기능 사용 (브레이크 포인트, 변수 검사 등)
3. **Python Tutor** 같은 시각화 도구로 코드 흐름 살펴보기
4. 에러 메시지를 **천천히 끝까지 읽기** (정말 중요)

---

## 5-2. 에러와 예외

> **에러(Error)** = 프로그램 실행 중 문제가 발생한 상황 전체
> **예외(Exception)** = 에러 중에서 **잡아서 처리할 수 있는 것**

파이썬에서 에러는 크게 두 부류로 나눈다. 

1. **문법 에러(SyntaxError)**

   * 코드 자체가 파이썬 문법에 맞지 않을 때
   * 예: 괄호 빠짐, `if` 뒤에 `:` 누락, 잘못된 들여쓰기 등
   * 이건 **실행 전에**(파싱 단계에서) 잡힌다.
2. **예외(Exception)**

   * 문법은 맞지만 **실행 중에** 발생하는 오류
   * 예: 0으로 나누기, 존재하지 않는 변수 참조, 리스트 인덱스 범위 초과 등

문법 에러는 *프로그램이 아예 실행되지 않음*
예외는 *실행 도중에 터지며, try/except로 잡아서 처리할 수 있음*

---

## 5-3. 대표적인 내장 예외들

자료에 여러 예시가 표로 정리되어 있다. 주요 것만 정리하자면:

* **ZeroDivisionError** : 0으로 나눌 때
* **NameError** : 정의되지 않은 변수/이름을 사용
* **TypeError** : 타입이 맞지 않을 때

  * 예: 문자열 + 숫자를 더하려고 할 때
* **ValueError** : 타입은 맞는데, 값이 잘못된 경우

  * 예: `"abc"`를 `int()`로 변환
* **IndexError** : 리스트/튜플 인덱스가 범위를 벗어나는 경우
* **KeyError** : 딕셔너리에 없는 키를 조회
* **ModuleNotFoundError / ImportError** : 없는 모듈을 import 하려 할 때
* **IndentationError** : 들여쓰기 에러
* **KeyboardInterrupt** : 사용자가 Ctrl + C로 강제 종료했을 때

이름만 봐도 대충 느낌이 올 정도로 “직관적인 이름”이라,
에러 메시지를 제대로 읽기만 해도 **문제 원인 70%는 해결**된다고 생각하면 된다.

---

# 6. 예외 처리(Exception Handling)

## 6-1. 왜 예외 처리가 필요한가?

* 예외가 발생할 수 있는 코드를 **그냥 두면** 프로그램 전체가 바로 종료된다.
* `try/except`로 감싸서

  * 문제를 **알맞게 처리**하거나
  * 사용자에게 **친절한 메시지**를 보여주고
  * 필요하다면 **프로그램을 계속 진행**시킬 수 있다.

---

## 6-2. try / except 기본 구조

```python
try:
    # 예외가 발생할 수 있는 코드
except 예외타입:
    # 예외가 발생했을 때 실행할 코드
```

예:

```python
try:
    num = int(input('숫자를 입력하세요: '))
    result = 10 / num
    print(result)
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다!')
except ValueError:
    print('정수를 입력해야 합니다!')
```

포인트:

* `try` 블록 안에서 예외가 발생 → 곧장 해당 `except`로 점프
* 예외가 발생하지 않으면 `except`는 실행되지 않음

---

## 6-3. 여러 예외 처리하기

### 방법 1) except 여러 개 나열

```python
try:
    ...
except ZeroDivisionError:
    ...
except ValueError:
    ...
```

### 방법 2) 튜플로 묶어서 한 번에 처리

```python
try:
    ...
except (ZeroDivisionError, ValueError):
    print('계산 오류 발생')
```

---

## 6-4. else / finally

확장 구조:

```python
try:
    # 예외가 발생할 수 있는 코드
except 예외타입:
    # 예외가 발생했을 때
else:
    # 예외가 전혀 발생하지 않았을 때만 실행
finally:
    # 예외 발생 여부와 상관없이 항상 실행 (정리 작업)
```

예:

```python
try:
    num = int(input('숫자를 입력하세요: '))
    result = 10 / num
except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
except ValueError:
    print('정수를 입력해야 합니다.')
else:
    print('결과는', result, '입니다.')
finally:
    print('프로그램을 종료합니다.')
```

* `else` : “문제 없이 잘 끝났을 때만” 수행해야 하는 로직

  * 예: 정상 결과 출력, DB commit 등
* `finally` : 파일 닫기, DB 연결 종료 같은 **정리 작업**에 사용

  * 예외가 있든 없든 호출되므로 안전하다.

---

## 6-5. 예외 객체 다루기

예외를 잡을 때 **객체로 받아서 메시지 확인**도 가능하다.

```python
try:
    ...
except ZeroDivisionError as e:
    print('에러 메시지:', e)
```

* `e` 안에는 에러 관련 정보(메시지 등)가 들어 있다.

또한 예외도 **클래스 상속 구조**를 가진다:

* `Exception`이 대부분 예외들의 부모 클래스
* `ZeroDivisionError`, `ValueError`, `TypeError` … 가 그 아래에 있다.

그래서,

```python
except Exception:
    ...
```

으로 잡으면 **대부분의 예외를 한 번에** 잡을 수 있지만,

* 너무 넓게 잡으면 **문제 원인을 숨겨버릴 수 있어서**
  – 자료에서도 “주의하라”는 취지로 언급한다.

실무에서는:

* 가장 구체적인 예외부터 위쪽에 쓰고
* 맨 마지막에 `except Exception:`을 두는 식으로 점진적으로 넓게 잡는 패턴이 많다.

---

# 7. EAFP vs LBYL – 파이썬다운 예외 처리 스타일

## 7-1. 두 스타일의 의미

* **EAFP**

  * “Easier to Ask Forgiveness than Permission”
  * “허락을 미리 구하기보다, 나중에 용서를 구하는 게 더 쉽다”
  * → **일단 시도하고, 안 되면 예외를 잡아서 처리**

* **LBYL**

  * “Look Before You Leap”
  * “뛰기 전에 먼저 살펴라”
  * → **하기 전에 조건을 다 체크하고, 안전할 때만 실행**

## 7-2. 예시: 딕셔너리에서 키 꺼내기

### EAFP 스타일 (try / except)

```python
try:
    value = my_dict['key']
except KeyError:
    print('키가 없습니다.')
```

### LBYL 스타일 (if 검사)

```python
if 'key' in my_dict:
    value = my_dict['key']
else:
    print('키가 없습니다.')
```

어떤 게 더 “파이써닉”하냐?

* 파이썬 커뮤니티에서는 **EAFP를 더 선호**하는 편이다.

  * 이유:

    * 동시성/멀티스레드 환경에서는,
      “검사하는 순간과 실제 수행하는 순간 사이에 상황이 바뀌는 문제”가 있기 때문.
    * 그리고 `try/except` 덕분에 코드가 간결해지는 경우가 많다.

물론 상황에 따라 LBYL이 더 읽기 좋을 때도 있으니,
두 스타일을 이해하고 **의도적으로 선택**하는 게 중요하다.

---

# 8. 한 줄 요약들

1. **상속**은 공통 기능을 부모 클래스에 모으고, 자식 클래스가 이를 물려받아 재사용·확장하는 기법이다.
2. **메서드 오버라이딩**은 부모의 메서드를 자식에서 같은 이름으로 다시 정의해서, 자식에게 맞는 동작으로 바꾸는 것이다.
3. **다중 상속**에서는 한 클래스가 여러 부모를 상속받을 수 있고, 파이썬은 **MRO** 규칙을 통해 어떤 순서로 메서드를 탐색할지 결정한다.
4. **super()**는 MRO 순서를 따라 “다음 클래스”의 메서드를 호출하는 도우미로, 단일 상속보다 다중 상속에서 진가를 발휘하며, 부모 클래스 이름을 하드코딩하지 않아도 되게 해 준다.
5. **문법 에러(SyntaxError)**는 코드 자체가 잘못된 경우이고, **예외(Exception)**는 실행 중에 발생하며 `try/except`로 처리할 수 있다.
6. `ZeroDivisionError`, `NameError`, `TypeError`, `ValueError`, `IndexError`, `KeyError` 등 내장 예외의 의미를 알고 있으면, 에러 메시지만 읽어도 원인 파악이 훨씬 빨라진다.
7. `try/except/else/finally` 구조를 사용하면, 예외가 발생했을 때 우아하게 처리하고, 정상 동작과 마무리 작업(자원 해제)을 명확히 분리할 수 있다.
8. 예외는 클래스 계층을 가지며, `except Exception as e:` 로 대부분의 예외를 잡을 수 있지만, 너무 넓게 잡으면 버그를 숨길 수 있으므로 주의해야 한다.
9. 파이썬다운 스타일은 **EAFP**(일단 실행해 보고, 예외가 나면 처리) 쪽에 더 가깝고, 상황에 따라 LBYL(if 검사)와 적절히 섞어 쓰면 좋다.

---

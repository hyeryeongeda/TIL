
---

## 1. 이번 파트의 큰 그림

이번 내용은 한마디로 **“비시퀀스 자료구조 + 그 밑바탕인 해시(hash) 개념 + 문법을 정의하는 BNF/EBNF”** 다루는 챕터다.

* **딕셔너리(dict)** : `키 -> 값` 구조로 저장하는 자료구조
* **세트(set)** : “중복 없는 집합” 자료구조
* **해시 테이블 / 해시 함수 / hashable** : dict, set 이 왜 빠른지, 어떤 값만 키/원소로 쓸 수 있는지
* **BNF / EBNF** : 파이썬 같은 언어의 “문법 규칙”을 수식처럼 표현하는 방식

이걸 한 번에 엮어서 이해하면,

> “dict / set이 왜 이런 제약이 있고, 왜 이렇게 빠른지, 그리고 파이썬 문법은 어떻게 정의되는지”

까지 그림이 잡힌다.

---

## 2. 딕셔너리(Dictionary) – 키로 찾는 데이터 구조

### 2-1. 딕셔너리 기본 개념

> **딕셔너리 = `키(key)`와 `값(value)`를 짝지어서 저장하는 자료구조**

* 형태: `{'name': 'Alice', 'age': 25}`
* 각 **키는 유일(unique)** 해야 하고,
* **키는 반드시 hashable(해시 가능)** 한 타입이어야 함

  * 대표적으로: `int`, `float`, `str`, `tuple(안에 것도 hashable이면)`
  * 안 되는 것: `list`, `dict`, `set` (가변이라 hash 불가)

데이터를 찾을 때:

* 리스트: “3번째 요소”처럼 **인덱스 번호**로 찾음
* 딕셔너리: “`'age'`라는 키에 해당하는 값”처럼 **키로 직접 찾음**

그래서 딕셔너리는 “전화번호부” 느낌이야.

* “김혜령” → 010-xxxx-xxxx
* “id 3번 유저” → 해당 유저 정보

### 2-2. 딕셔너리의 특징 요약

* **순서** : 파이썬 3.7+에서는 **삽입 순서를 기억**하지만, 핵심은 “순서가 아니라 키 기반 검색”
* **시간복잡도** : 평균적으로 **키 조회/삽입/삭제가 O(1)** (해시 테이블 덕분)
* **키 제약** : hashable + 유일해야 함
* **값** : 어떤 타입이든 상관없음 (다른 dict, list, 함수, 객체 전부 OK)

---

## 3. 딕셔너리 기본 조작

```python
person = {
    'name': 'Alice',
    'age': 25,
}
```

### 3-1. 조회

```python
person['name']     # 'Alice'
```

* 존재하지 않는 키를 `[]`로 접근하면 **KeyError**가 난다.

그래서 안전하게 조회할 때는 `get()`을 많이 사용한다 (아래에서 자세히).

### 3-2. 추가 & 수정

```python
person['city'] = 'Seoul'   # 없던 키면 추가
person['age'] = 26         # 있던 키면 값 수정
```

### 3-3. in 연산자

```python
'name' in person      # True (키 기준)
'Alice' in person     # False (값은 검사 안 함)
```

* `in`은 항상 **키 기준**으로 동작하는 것 기억하기.

---

## 4. 딕셔너리 메서드 정리

### 4-1. `.get(key[, default])` – 안전한 조회

> 키가 있으면 값, 없으면 `default`(기본은 `None`)를 반환

```python
person = {'name': 'Alice', 'age': 25}

person.get('name')         # 'Alice'
person.get('country')      # None
person.get('country', 'KOREA')  # 'KOREA'
```

* `[]`로 접근하면 없는 키에서 에러,
* `get()`은 없는 키면 에러 대신 지정한 기본값을 돌려줌.

→ 실무 코드에서 **매우 자주 쓰이는 패턴**.

---

### 4-2. `.keys()`, `.values()`, `.items()`

이 세 개는 dict를 반복할 때 거의 기본 세트.

#### (1) `.keys()` – 키 목록 뷰

```python
person = {'name': 'Alice', 'age': 25}

for k in person.keys():
    print(k)
# name
# age
```

* “키들만 모아서 보여주는 뷰 객체”를 반환
* `list(person.keys())` 하면 리스트로도 볼 수 있음.

#### (2) `.values()` – 값 목록 뷰

```python
for v in person.values():
    print(v)
# Alice
# 25
```

#### (3) `.items()` – (키, 값) 쌍 뷰

```python
for key, value in person.items():
    print(key, value)

# name Alice
# age 25
```

* 딕셔너리를 순회할 때 가장 많이 쓰는 패턴:
  `for key, value in dict.items(): ...`

---

### 4-3. `.pop(key[, default])` – 꺼내면서 삭제

> 키에 해당하는 값을 **반환하고, 그 키를 딕셔너리에서 제거**

```python
person = {'name': 'Alice', 'age': 25}

age = person.pop('age')      # age = 25, 딕셔너리에서는 제거
print(person)                # {'name': 'Alice'}
```

* 없는 키를 `pop`할 때 `default`를 주면 에러 대신 그 값을 반환:

```python
country = person.pop('country', 'KOREA')  # 'KOREA'
```

---

### 4-4. `.clear()` – 전부 비우기

```python
person.clear()
print(person)   # {}
```

---

### 4-5. `.setdefault(key[, default])` – “있으면 그대로, 없으면 추가”

> 키가 있으면 그 **값을 반환**
> 키가 없으면 **`default`를 값으로 추가한 뒤 그 값을 반환**

```python
person = {'name': 'Alice', 'age': 25}

person.setdefault('country', 'KOREA')
print(person)
# {'name': 'Alice', 'age': 25, 'country': 'KOREA'}

person.setdefault('age', 30)
print(person['age'])   # 25 (기존 값 유지)
```

* “키가 없으면 기본 구조를 만들어 두고 그걸 반환” 이런 패턴에 좋다 (예: `dict` 안에 리스트 넣기 등).

---

### 4-6. `.update(other)` – 한 번에 여러 키/값 갱신

> 다른 딕셔너리나 `키=값` 쌍들을 받아 **기존 딕셔너리에 덮어쓰기/추가**

```python
person = {'name': 'Alice', 'age': 25}
other  = {'age': 30, 'country': 'KOREA'}

person.update(other)
print(person)
# {'name': 'Alice', 'age': 30, 'country': 'KOREA'}
```

* 이미 있던 키(`age`)는 값이 바뀌고, 없던 키(`country`)는 새로 추가된다.
* 함수 인자 스타일도 가능:

```python
person.update(city='Seoul', job='Dev')
```

---

## 5. 세트(Set) – “중복 없는 집합”

### 5-1. 세트 기본 개념

> **세트 = 순서가 없고, 중복을 허용하지 않는 가변 컬렉션**

* 형태: `{1, 2, 3}`
* **중복 자동 제거**: `{1, 2, 2, 3}` → `{1, 2, 3}`
* **순서가 없다**: 인덱스로 접근 불가 (`my_set[0]` ❌)
* 요소는 역시 **hashable 타입**만 가능 (dict 키와 동일 규칙)

빈 세트 만들 때:

```python
empty = set()   # ✅
empty2 = {}     # ❌ 이건 빈 dict
```

### 5-2. 세트 기본 메서드

#### (1) `.add(x)` – 요소 하나 추가

```python
my_set = {1, 2, 3}
my_set.add(4)
# {1, 2, 3, 4}
my_set.add(2)
# 여전히 {1, 2, 3, 4} (중복 추가 안 됨)
```

#### (2) `.update(iterable)` – 여러 요소 한 번에 추가

```python
my_set = {1, 2, 3}
my_set.update([3, 4, 5])
# {1, 2, 3, 4, 5}
```

#### (3) `.clear()` – 모두 제거

```python
my_set.clear()
# set()
```

#### (4) `.remove(x)` – 요소 삭제 (없으면 에러)

```python
my_set = {1, 2, 3}
my_set.remove(2)
# {1, 3}
my_set.remove(5)  # KeyError
```

#### (5) `.discard(x)` – 요소 삭제 (없어도 조용히 통과)

```python
my_set = {1, 2, 3}
my_set.discard(2)
my_set.discard(5)    # 에러 없음
```

#### (6) `.pop()` – 아무 요소 하나 꺼내고 제거

```python
my_set = {1, 2, 3}
elem = my_set.pop()
# 순서가 없으므로 어떤 값이 나올지 보장 X
```

---

### 5-3. 세트의 집합 연산 메서드

* `set1.difference(set2)` / `set1 - set2`
  → `set1`에는 있지만 `set2`에는 없는 원소들
* `set1.intersection(set2)` / `set1 & set2`
  → 교집합
* `set1.union(set2)` / `set1 | set2`
  → 합집합
* `set1.symmetric_difference(set2)` / `set1 ^ set2`
  → “둘 중 한쪽에만 있는” 원소들
* `set1.issubset(set2)` / `set1 <= set2`
  → `set1`이 `set2`의 부분집합인지 여부
* `set1.issuperset(set2)` / `set1 >= set2`
  → `set1`이 `set2`를 포함하는 상위 집합인지 여부

이 덕분에 **리스트 중복 제거, 교집합/차집합 계산, 태그/권한 처리** 같은 작업을 아주 간단히 할 수 있다.

---

## 6. 해시 테이블 / 해시 / 해시 함수

이제 “왜 dict랑 set은 hashable만 허용하고 이렇게 빠른가?”에 대한 밑바탕 개념.

### 6-1. 해시 테이블(hash table) 개념

해시 테이블은 간단히 말해서

> **키를 어떤 숫자 인덱스로 바꿔 주는 함수(해시 함수)를 이용해서,
> 바로 배열 위치를 찾아가는 구조**

흐름을 말로 써보면:

1. 키(예: `'Alice'`)를 해시 함수에 넣음 → 큰 정수 하나가 나온다.
2. 이 정수를 **배열의 인덱스 범위로 나누기**(보통 나머지 연산) 해서 위치를 얻는다.
3. 그 인덱스 칸(bucket)에 값(value)을 저장.

검색할 때도 똑같이:

1. 찾고 싶은 키를 해시 함수에 넣고
2. 같은 방식으로 인덱스를 계산해
3. 그 칸에 가서 값만 꺼내면 끝.

그래서 평균적으로 **O(1)** 시간에 접근 가능.

---

### 6-2. 해시(Hash)와 해시 함수

> **해시 함수(hash function)** = 입력(키)을 고정 길이 정수로 바꿔주는 함수
> **해시 값(hash)** = 그 결과 정수

요구되는 성질:

* 같은 입력이면 언제나 같은 해시 값
* 서로 다른 입력이면 가급적 다른 해시 값 (충돌 줄이기)
* 계산이 빠를 것

파이썬에서는 내장 함수 `hash()`로 해시 값을 볼 수 있다.

```python
hash(1)          # 정수
hash('hello')    # 정수
hash((1, 2, 3))  # 정수
# hash([1, 2, 3])  # TypeError (리스트는 hash 불가)
```

### 6-3. 해시 충돌

서로 다른 키인데도 해시 값이 우연히 같아지는 걸 **충돌(collision)**이라고 한다.

* 현실적으로 “무한한 키 공간 → 유한한 정수 공간”이니까 충돌은 언젠가 일어날 수밖에 없다.
* 실제 구현에서는 **같은 버킷에 연결 리스트/트리로 여러 원소를 넣는 방식** 등으로 처리.

중요한 건:

> 충돌이 조금 나더라도, 전체적으로 평균 조회/삽입이 여전히 O(1)에 가깝게 유지되도록 해시 함수를 잘 설계하는 게 핵심.

---

## 7. hashable vs unhashable – 어떤 값이 dict 키/세트 원소가 될 수 있나

### 7-1. hashable이란?

파이썬에서 **hashable**의 의미는:

1. `__hash__()` 메서드가 있어서 `hash(x)`가 잘 동작하고,
2. `__eq__()`로 비교했을 때 같다고 판단되는 동안 **해시 값이 변하지 않는 것**

즉, **“수명 동안 변치 않는 정체성을 가진 값”**이라고 생각하면 된다.

대표적인 hashable 타입:

* `int`, `float`, `str`, `bool`
* `tuple` (단, 안에 들어 있는 요소들도 전부 hashable이면)

unhashable 타입(해시 불가):

* `list`, `dict`, `set` 등 **가변 객체**

```python
hash(1)          # OK
hash('abc')      # OK
hash((1, 2))     # OK
hash([1, 2])     # TypeError
hash({'a': 1})   # TypeError
```

그래서

* **딕셔너리의 키**와
* **세트의 원소**는

반드시 hashable 타입이어야 한다.

### 7-2. 왜 가변 객체는 안 되는가?

가장 큰 이유는:

> **해시 테이블은 “키의 해시 값”을 기준으로 위치를 정해놓고 쓰는데,
> 키 값이 바뀌면 해시 값도 바뀌어 버리기 때문.**

예를 들어, 리스트가 키가 될 수 있다고 상상해보면:

1. `[1, 2]`를 키로 넣어서 어떤 버킷에 저장
2. 나중에 리스트를 `[9, 9]`로 수정
3. 이제 이 리스트의 해시 값은 완전히 달라져야 하는데,
   해시 테이블은 이 키를 여전히 “옛날 자리”에 두고 있음
4. 그 결과, 찾으려고 해도 못 찾고, 구조가 망가짐

그래서 파이썬은 **애초에 가변 객체는 hashable로 만들지 않고**,
오직 불변 객체만 hashable로 허용해서 이런 문제를 막는다.

---

## 8. 파이썬에서의 해시 난수화와 pop 동작

자료에는 “set의 `pop()`을 여러 번 해보면 순서가 이상하게 보이고, 파이썬을 다시 실행할 때마다 또 순서가 달라질 수 있다”는 예시가 나온다.

이건 크게 두 가지 이유가 있다.

1. **세트 자체가 ‘순서 없는 컬렉션’**이라

   * 내부 구현에 따라 어떤 요소가 먼저 나올지 정의되어 있지 않음
2. **파이썬이 안전을 위해 해시 값을 프로세스마다 랜덤하게 섞는 기능**(hash randomization)을 쓰기 때문에

   * 실행할 때마다 set/dict 내부 배치가 달라질 수 있음

정리하면:

> 세트나 딕셔너리는 “순서 보장 자료구조”가 아니고,
> 특히 세트는 **pop 결과나 순회 순서를 믿고 의존하면 안 된다**는 것.

(딕셔너리는 삽입 순서를 기억하지만, 그건 “보너스 성질”이라고 생각해두기.)

---

## 9. 파이썬 문법 규격 – BNF / EBNF

마지막 부분은 파이썬 언어 자체의 **문법을 수학처럼 표현하는 공식 표기법**에 대한 내용이야.

### 9-1. BNF (Backus-Naur Form)

> 프로그래밍 언어의 문법을 정의할 때 사용하는 “형식 문법” 표기법

* 어떤 문장이 어떤 기호들의 조합으로 이뤄지는지 규칙으로 적는다.

예시 느낌:

```text
digit   ::= "0" | "1" | ... | "9"
integer ::= digit {digit}
```

이런 식으로 “이건 이렇게 생겼어”를 명확하게 정의.

### 9-2. EBNF (Extended BNF)

> BNF를 더 쓰기 쉽도록 확장한 표기법

* 반복, 선택, 옵션 등을 **메타 기호**로 표현

메타 기호 예시:

| 기호   | 의미       |         |
| ---- | -------- | ------- |
| `[]` | 선택적 요소   |         |
| `{}` | 0번 이상 반복 |         |
| `()` | 그룹화      |         |
| `    | `        | 선택 (OR) |

예를 들어, 딕셔너리 `pop`의 문법을 EBNF 스타일로 표현하면 대략:

```text
dict.pop(key [, default])
```

* `[,]` 부분이 “옵션”이라는 뜻 → `key`만 줄 수도 있고 `key, default`를 줄 수도 있다는 의미.

이런 표기법은

* 언어 설계자, 인터프리터/컴파일러 개발자, 문서 작성자들이
* “문법을 사람과 기계가 모두 이해할 수 있는 형태로” 표현하는 데 쓰인다.

우리는 “아, 파이썬 공식 문서에서 이런 괄호/대괄호가 문법을 표현하는 방식이구나” 정도만 이해해두면 충분해.

---

## 10. 오늘 TIL에 적을 핵심 문장 정리

1. **딕셔너리**는 `키 -> 값` 구조로 데이터를 저장하며, 키는 hashable이고 유일해야 하고, 평균적으로 O(1)에 가까운 속도로 조회/삽입/삭제할 수 있다.
2. 딕셔너리 메서드 중 자주 쓰는 건 `get`(안전 조회), `keys`/`values`/`items`(반복용), `pop`(꺼내고 삭제), `clear`, `setdefault`, `update` 이며, 각각의 동작과 에러 발생 여부를 구분해서 기억해야 한다.
3. **세트(set)**는 순서가 없고 중복을 허용하지 않는 집합 자료구조로, `add`, `update`, `remove`, `discard`, `pop`, `clear`와 함께 합집합/교집합/차집합/대칭차집합/부분집합 검사를 빠르게 할 수 있다.
4. **dict와 set은 해시 테이블 위에서 동작**하며, 키(또는 원소)를 해시 함수로 정수 인덱스로 바꿔서 평균 O(1) 시간에 데이터에 접근한다.
5. **hashable**한 값만 dict의 키와 set의 원소로 쓸 수 있는데, 이는 해시 값이 변하지 않아야 해시 테이블 구조가 깨지지 않기 때문이며, 따라서 불변 타입(int, str, tuple 등)만 허용되고 list, dict, set은 허용되지 않는다.
6. 세트와 딕셔너리는 내부적으로 해시 난수화가 적용되기 때문에, 특히 세트에서는 `pop()`이나 순회 순서가 실행할 때마다 달라질 수 있고, 순서를 믿고 로직을 짜면 안 된다.
7. 파이썬 공식 문법은 BNF/EBNF 같은 형식 문법으로 표현되며, EBNF의 `[]`, `{}`, `()` 같은 기호는 각각 옵션, 반복, 그룹을 의미한다. 이걸 알고 보면 문서에 나오는 함수 표기나 문법 설명이 훨씬 읽기 쉬워진다.

---

# CSS Layout TIL

## 0) 레이아웃이란 무엇인가

CSS Layout은 “각 요소의 위치와 크기를 조정해서 웹 페이지의 디자인(뼈대)을 결정하는 것”이다. 결국 화면은 수많은 박스들이 모여서 만들어지고, 레이아웃은 그 박스들을 **어떻게 줄 세우고(흐름), 어디에 고정하고(위치), 어떤 규칙으로 배치할지(정렬)**를 정하는 작업이다. 

레이아웃의 핵심 도구는 크게 두 축으로 나뉜다.

* **Layout(배치 방식)**: `display` (block/inline/flex/grid …)로 “박스들이 기본적으로 어떻게 놓이는지” 결정한다. 
* **Position(위치 지정)**: `position` (static/relative/absolute/fixed/sticky …)로 “기본 흐름에서 벗어나서 어디에 둘지” 결정한다. 

---

# 1) display와 박스 타입: “이 요소는 한 줄을 먹나, 글자처럼 흐르나?”

## 1-1) 박스 타입이 중요한 이유

박스 타입이 달라지면 다음이 통째로 달라진다.

* 줄바꿈이 생기는가?
* 너비/높이를 줄 수 있는가?
* margin/padding/border가 주변 요소를 밀어내는가?
* 기본 배치 흐름(normal flow)에서 어떻게 정렬되는가?

자료는 가장 기본을 **Block 타입 vs Inline 타입**으로 정리한다. 

---

## 1-2) Block 타입: “독립된 덩어리, 무조건 줄바꿈”

Block 요소는 말 그대로 **한 덩어리 박스**처럼 동작한다. 

특징을 감각적으로 정리하면:

* 항상 **새로운 줄에서 시작**한다(줄바꿈 발생) 
* 기본적으로 **가로 너비를 한 줄 전체(100%)**처럼 차지한다

  * `width`를 지정하지 않으면 “사용 가능한 공간을 전부” 먹는다(부모 컨테이너 너비를 채움) 
* `width`, `height`, `margin`, `padding`을 모두 사용할 수 있다 
* margin/padding/border 때문에 다른 요소를 “밀어내는” 레이아웃 영향이 확실히 생긴다 

대표 태그 예시: `h1~h6`, `p`, `div`, `ul`, `li` 
특히 **div**는 “다른 요소를 그룹화해서 레이아웃을 만들 때 가장 많이 쓰는 대표 block”으로 설명한다. 

---

## 1-3) Inline 타입: “문장 속 단어처럼 흐름에 섞인다”

Inline 요소는 **텍스트 흐름 안에서 단어처럼 배치**되는 요소다. 

핵심 특징:

* 줄바꿈이 자동으로 생기지 않는다(한 줄 안에서 옆으로 붙는다) 
* 너비/높이를 직접 지정할 수 없다(`width`, `height` 적용 불가) 
* padding/margin/border는 적용되지만,

  * **수직 방향(위아래)**은 다른 요소를 밀어내지 못한다(라인 흐름을 크게 못 바꿈) 
  * **수평 방향(좌우)**은 적용되며 옆 요소와 간격을 만들 수 있다 

대표 태그 예시: `a`, `img`, `span`, `strong` 
**span**은 자체 시각 변화가 거의 없고 “문장 일부만 스타일링하고 싶을 때” 쓰는 대표 inline이라고 정리한다. 

---

## 1-4) inline-block: “줄바꿈 없이, 크기 지정은 하고 싶을 때”

자료에서 “inline과 block의 특징을 모두 가진 특별한 display 값”으로 `inline-block`을 소개한다. 

* 줄바꿈 없이 inline처럼 옆으로 나열되지만
* block처럼 `width`, `height` 지정이 가능하고
* padding/margin/border로 인해 주변 요소를 밀어낼 수도 있다 

즉, “버튼/뱃지/카드 조각” 같은 걸 한 줄에 여러 개 나열하면서도 크기 조절을 하고 싶으면 `inline-block`이 직관적인 선택이 된다.

---

## 1-5) display: none

`display: none`은 요소를 화면에 표시하지 않을 뿐 아니라 **공간 자체도 차지하지 않게** 만든다. 
즉, “숨김 처리”를 했는데 레이아웃 빈 공간이 남으면 `visibility` 계열이 아닌지 점검하고, “공간까지 없애려면 display:none”이라고 기억하면 된다.

---

# 2) Normal Flow: “아무것도 안 했을 때의 기본 배치 규칙”

자료에서 Normal Flow를 “레이아웃을 변경하지 않은 경우 웹 페이지 요소가 배치되는 방식”이라고 정의한다. 

이게 왜 중요하냐면, 레이아웃 문제는 대부분:

* “나는 normal flow대로 두고 싶다” vs
* “normal flow에서 빼서 따로 배치하고 싶다”

이 두 갈래에서 출발하기 때문이다.

---

# 3) Position: normal flow에서 빼서 ‘원하는 위치’로 옮기는 법

Position의 핵심은 이 문장으로 끝난다.

> `position`은 요소를 Normal Flow에서 제거(또는 유지)하면서
> 원하는 위치로 배치해 “겹치기/고정/특정 위치 배치” 등을 가능하게 만든다. 

그리고 position은 항상 top/right/bottom/left와 세트로 같이 이해해야 한다. 

---

## 3-1) position: static (기본값)

* normal flow 그대로 배치된다 
* `top/right/bottom/left`가 적용되지 않는다 

즉, “특별히 위치를 조정하지 않으면” 모든 요소는 static이다.

---

## 3-2) position: relative (내 원래 자리 기준으로 ‘살짝 이동’)

자료의 포인트는 3개다. 

* normal flow에 따라 배치된다(기본 자리는 유지)
* **자기 원래 위치를 기준으로** top/right/bottom/left로 이동한다
* 중요한 핵심: **다른 요소 레이아웃에 영향을 주지 않는다**

  * 즉, 화면에서 요소가 이동해 보이더라도
    그 요소가 “원래 차지하던 공간”은 그대로 남아 있다(자리 비움 X) 

실무 감각으로 말하면:
`relative`는 “자기 위치를 미세 조정”하거나 “absolute의 기준점(부모) 만들기”로 정말 많이 쓴다.

---

## 3-3) position: absolute (기준점을 잡고 ‘완전 분리’해서 배치)

자료가 말하는 absolute의 핵심: 

* 요소를 normal flow에서 제거한다 → 문서에서 차지하던 공간이 사라진다
* **가장 가까운 relative 부모 요소**를 기준으로 이동한다
* 그런 부모가 없으면 body를 기준으로 한다
* top/right/bottom/left로 위치를 조정한다

여기서 가장 중요한 실전 규칙:

> absolute를 쓰면, 보통 “부모에게 relative를 주고, 자식에게 absolute를 준다”.

왜냐하면 relative 부모를 기준으로 잡아야 “카드 안 뱃지”, “이미지 위 아이콘”, “섹션 내부 고정 요소” 같은 배치가 안정적으로 된다.

---

## 3-4) position: fixed (스크롤해도 화면에 붙어있기)

자료의 정의 그대로가 핵심이다. 

* normal flow에서 제거된다(공간 차지 X)
* 기준은 부모가 아니라 **viewport(현재 화면)** 이다
* 스크롤해도 항상 같은 위치에 유지된다
* top/right/bottom/left로 조정한다

예: “우측 하단 챗봇 버튼”, “상단 고정 네비게이션” 같은 것.

---

## 3-5) position: sticky (relative + fixed 하이브리드)

sticky는 감각을 먼저 잡으면 이해가 쉽다. 자료는 이렇게 설명한다. 

* 임계점 전까지는 relative처럼 동작한다(흐름 안에 있다)
* 임계점에 도달하면 fixed처럼 화면에 고정된다
* 다음 sticky 요소가 나오면 이전 sticky가 밀려나며 자리가 대체된다(겹치기 때문에) 

즉, “스크롤하다가 특정 위치에서 딱 달라붙는 헤더/카테고리 바”가 sticky다.

---

# 4) z-index: “겹칠 때 누가 위로 올라오나”

z-index는 단순히 “숫자가 크면 위”라고만 외우면 실전에서 계속 헷갈린다. 자료의 규칙을 정확히 정리하면: 

* 요소의 **쌓임 순서**(Z축)를 정하는 속성
* 정수 값을 쓰며 **값이 클수록 위에 쌓인다**
* **static이 아닌 요소에만 적용된다** (position이 있어야 의미가 생김) 
* 기본값은 auto이고, 부모의 z-index 영향을 받는다
* **같은 부모 안에서만 비교**하며,

  * z-index가 같으면 **HTML 문서 순서대로** 쌓인다(나중에 나온 게 위) 
* 가장 중요한 추가 규칙:

  * **부모의 z-index가 낮으면 자식이 아무리 높아도 부모보다 위로 못 올라간다** 

실무에서 “자식에 z-index 9999 줬는데 왜 안 올라와?”의 대부분 원인은
부모가 낮은 stacking context에 묶여 있기 때문이다.
이 규칙 하나만 기억해도 디버깅 시간이 확 줄어든다.

---

# 5) Flexbox: 1차원(행/열) 정렬의 표준 도구

자료는 Flexbox를 “요소를 행과 열 형태로 배치하는 1차원 레이아웃 방식”이라고 정의한다. 

### 5-1) Outer display vs Inner display

자료에 “박스 표시 타입”이 2개로 나뉜다고 나온다. 

* **Outer display**: block / inline → “박스가 바깥에서 어떻게 놓일지”
* **Inner display**: flex 등 → “박스 내부의 자식들이 어떻게 배치될지”

즉, `display: flex`는 “이 요소가 flex container가 되면서, 내부 아이템 배치 규칙을 flex로 하겠다”는 선언이다.

---

## 5-2) Flexbox 구성 요소: container와 item, 그리고 축 개념

Flexbox를 이해하는 핵심은 “축”이다. 자료 그림은 다음 요소들을 설명한다. 

* **Flex Container**: `display: flex`가 적용된 부모
* **Flex Item**: 컨테이너의 직계 자식들
* **Main axis(주축)**: 아이템이 나열되는 방향
* **Cross axis(교차축)**: 주축과 수직 방향

기본값에서:

* flex item은 기본적으로 **행(row)** 방향(가로)으로 나열된다 
* 아이템은 주축 시작선에서 출발한다 
* 아이템은 교차축 방향으로 “늘어나서” 컨테이너 높이를 채우는 성질이 있다(기본 stretch 감각) 

---

## 5-3) Flex Container 핵심 속성 4개

### (1) display: flex

```css
.container { display: flex; }
```

이 한 줄로 컨테이너/아이템 관계가 생긴다. 

---

### (2) flex-direction: 주축 방향 바꾸기

* `row`(기본): 왼→오 가로 배치 
* `column`: 위→아래 세로 배치 
* `row-reverse`, `column-reverse`: 시작선/끝선이 뒤집힘 

“justify-content가 왜 갑자기 세로로 먹지?” 같은 혼란은 보통
`flex-direction: column`에서 주축이 세로로 바뀌어서 생긴다.
즉, 방향을 바꾸면 **주축/교차축이 같이 바뀐다**고 생각해야 한다.

---

### (3) flex-wrap: 한 줄에 다 못 들어가면 줄바꿈 할까?

* `nowrap`(기본): 줄바꿈 안 함, 한 줄에 억지로 넣으려 함 
* `wrap`: 여러 줄로 내려가게 허용 

카드 리스트(예: 상품 카드, 영화 카드)를 “반응형으로 여러 줄로” 만들려면 `wrap`이 거의 필수다.

---

### (4) justify-content / align-items / align-content: 정렬 3형제

자료는 정렬을 “주축 vs 교차축”, “한 줄 vs 여러 줄”로 구분해 설명한다. 

#### ① justify-content (주축 정렬)

주축에서 아이템들을 어떻게 배치할지 결정한다. (자료에 예시 다수) 

* `flex-start` / `flex-end`
* `center`
* `space-between` / `space-around` / `space-evenly` 

#### ② align-items (교차축 정렬, “한 줄 기준”)

교차축에서 **각 아이템**을 어떻게 정렬할지 결정한다. 

* `stretch`(기본 감각)
* `flex-start`, `flex-end`, `center`, `baseline` 등

#### ③ align-content (교차축 정렬, “여러 줄 기준”)

`wrap`으로 줄이 여러 개가 되었을 때, 그 “줄 묶음 전체”를 교차축에서 어떻게 배치할지 결정한다. 

헷갈림 방지 공식:

* **align-items**: 아이템 하나하나(한 줄에서도 의미 있음)
* **align-content**: 줄(line) 전체(여러 줄이어야 의미 큼)

---

## 5-4) align-self: 특정 아이템만 예외로 정렬

자료는 `align-self`를 “해당 아이템 하나만 교차축 정렬을 개별 지정”으로 소개한다. 

즉, 컨테이너에서 `align-items: center` 했는데
“이 아이템 하나만 위에 붙여라” 같은 예외 상황을 만들 때 사용한다.

---

## 5-5) flex-grow / flex-basis: 남는 공간을 어떻게 나눌까?

자료는 특히 **flex-grow(비율로 공간 나눔)**과 **flex-basis(기준 크기)**를 예시로 설명한다. 

* `flex-basis`: “이 아이템은 기본적으로 이 정도 크기에서 시작”
* `flex-grow`: “남는 공간이 있으면 이 비율만큼 더 커져라”

실전 감각:

* 카드 3개를 한 줄에 두고 “남는 공간을 똑같이” 나누고 싶다 → `flex: 1` 감각(아래 shorthand 참고)
* 어떤 카드 하나만 더 넓게 하고 싶다 → 그 카드에 `flex-grow`를 더 크게

---

## 5-6) Flexbox Shorthand (축약형)

자료에서 shorthand로 `flex-flow`, `flex`가 정리돼 있다. 

* `flex-flow`: `flex-direction` + `flex-wrap`을 한 번에
* `flex`: `flex-grow`, `flex-shrink`, `flex-basis`를 한 번에

실무에서는 `flex: 1`, `flex: 0 0 auto` 같은 패턴이 자주 등장하는데,
핵심은 “flex는 아이템의 크기와 공간 분배 전략을 한 줄로 정한다” 정도로 이해하면 된다.

---

# 6) 마진 상쇄(Margin collapsing): “왜 마진이 더해지지 않고 합쳐지지?”

자료에 참고로 **마진 상쇄**가 나온다. 

> 두 block 요소의 `margin-top`과 `margin-bottom`이 만나면
> 더 큰 margin 하나로 결합되는 현상

즉, 위 요소의 margin-bottom 20px + 아래 요소의 margin-top 30px이 있으면
50px이 아니라 **30px(더 큰 값)**처럼 보일 수 있다.

이 현상은 “왜 간격이 예상과 다르지?”의 대표 원인이라
블록 요소가 위아래로 쌓이는 레이아웃에서 특히 조심해야 한다.

---

# 7) 박스 타입별 수평 정렬 감각

자료에 “박스 타입 별 수평 정렬” 팁이 정리돼 있다. 

* **block 요소 자체를 가운데**

  * 보통 `width`를 줘서 박스 폭을 줄인 뒤 `margin: 0 auto`로 중앙 정렬
* **inline 요소(텍스트, span 등)를 가운데**

  * 부모에 `text-align: center`를 주는 방식이 기본
* **inline-block도**

  * 줄 안에 놓이므로 부모의 `text-align` 영향을 받는다

이 차이를 모르면 “왜 margin:auto가 안 먹지?” 같은 혼란이 생기는데,
대부분 “나는 inline을 가운데 두려고 margin:auto를 쓴다” 같은 케이스에서 터진다.

---

# 8) Position 활용 예시 감각 (absolute / fixed / sticky)

자료는 실제 화면 예시로 position 활용을 보여준다. 

실무에서 자주 나오는 패턴을 정리하면:

* `absolute`: 카드 내부 뱃지(NEW), 이미지 위 아이콘, 입력창 안 돋보기 아이콘처럼
  “부모 박스 안에서 정확히 고정 위치”가 필요할 때
* `fixed`: 스크롤해도 항상 보이는 버튼(상단 이동, 채팅), 고정 헤더
* `sticky`: 섹션 제목/필터 바가 스크롤 중 특정 구간에서만 고정되는 UI

---

# 9) 오늘 내용 한 장 요약

* **display**는 “박스가 기본적으로 어떻게 배치되는지”를 결정한다. 

  * block: 줄바꿈 O, 크기 지정 O, 주변 요소를 밀어냄
  * inline: 줄바꿈 X, 크기 지정 X(대부분), 수직 방향 밀어냄 제한
  * inline-block: 줄바꿈 X + 크기 지정 O
  * none: 표시 X + 공간도 X
* **normal flow**는 아무 것도 안 했을 때의 기본 배치 규칙이다. 
* **position**은 normal flow에서 빼거나 유지하면서 위치를 조정한다. 

  * static: 기본값
  * relative: 원래 자리 기준 이동(공간 유지)
  * absolute: flow 제거 + relative 부모 기준(공간 제거)
  * fixed: flow 제거 + viewport 기준(스크롤에도 고정)
  * sticky: 임계점 전 relative, 이후 fixed처럼 고정
* **z-index**는 겹침 순서이며, static이 아닌 요소에서만 의미가 크고 “부모 stacking 영향”을 강하게 받는다. 
* **flexbox**는 1차원 레이아웃 도구이며, container에서 방향/줄바꿈/정렬을 잡고 item에서 grow/basis로 크기 분배를 조절한다. 
* **마진 상쇄**는 block 요소 상하 마진이 합쳐지는 현상이라 간격이 예상과 달라질 수 있다. 

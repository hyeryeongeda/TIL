# Git 핵심 개념 및 활용 가이드

## 1. Git & GitHub 이해

*   **Git**: **분산 버전 관리 시스템 (DVCS)**입니다. 중앙 서버 없이 각 개발자가 프로젝트의 전체 이력을 로컬에 저장하고 관리할 수 있어, 네트워크 연결 없이도 작업이 가능하며 장애 내구성이 뛰어납니다. Git은 파일 변경 이력을 정교하게 추적하고 관리하여 프로젝트의 시간별 스냅샷을 기록하며, 여러 개발자 간의 효율적인 협업을 위한 기반을 제공합니다. 주로 **로컬 저장소 (Local Repository)**의 버전을 관리하는 데 사용됩니다.

*   **GitHub**: Git 저장소를 호스팅하는 **클라우드 기반의 원격 저장소 서비스**입니다. Git으로 관리되는 로컬 프로젝트를 인터넷을 통해 공유하고 협업할 수 있도록 지원합니다. GitHub는 코드 공유, 협업 워크플로우(예: Pull Request를 통한 코드 리뷰), 이슈 트래킹, 프로젝트 관리 등 다양한 부가 기능을 제공하여 팀 개발을 용이하게 합니다. 이 외에도 GitLab, Bitbucket, Azure DevOps 등 다양한 Git 호스팅 서비스가 존재합니다.

## 2. Git 기본 작업 흐름

Git 프로젝트의 전형적인 작업 흐름은 '초기화 -> 변경 사항 추적 -> 스테이징 -> 커밋'의 반복으로 이루어집니다.

### 2.1. Git 프로젝트 초기화 및 준비

*   **`git init`**
    *   **설명**: 현재 디렉토리를 **새로운 Git 저장소**로 초기화합니다. 이 명령을 실행하면 현재 디렉토리 내에 Git의 모든 버전 관리 정보를 담는 `.git`이라는 숨겨진 디렉토리가 생성됩니다. Git은 이 `.git` 디렉토리를 통해 프로젝트 파일의 변경 사항을 추적하고 관리하게 됩니다.
    *   **사용 시점**: 새로운 프로젝트에서 Git을 사용하여 버전 관리를 시작할 때, 해당 프로젝트 디렉토리 안에서 **단 한 번만** 실행합니다. 이미 Git 저장소인 곳에서는 다시 실행할 필요가 없습니다.

### 2.2. 변경 사항 추적 및 Staging

*   **`git add .`**
    *   **설명**: 현재 디렉토리의 **모든 변경된 파일 (새로 생성된 파일, 수정된 파일, 삭제된 파일)**을 **스테이징 영역 (Staging Area / Index)**에 추가합니다. 스테이징 영역은 다음 커밋에 포함될 변경 사항들을 미리 준비하는 임시 공간으로, 커밋할 변경 사항의 "스냅샷"을 만드는 단계입니다.
    *   **대안**:
        *   특정 파일만 추가하려면 `git add <파일경로>`를 사용합니다. 예: `git add index.html`.
        *   모든 변경된 파일(새로운 파일, 수정/삭제된 파일)을 추가하려면 `git add -A` 또는 `git add --all`을 사용합니다.
        *   이미 Git이 추적하는 파일 중 수정/삭제된 파일만 추가하려면 `git add -u` 또는 `git add --update`를 사용합니다.

*   **`git status`**
    *   **설명**: 현재 Git 저장소의 **상태를 자세히 확인**합니다. 이 명령은 스테이징 영역에 올라간 파일(Changes to be committed), 아직 스테이징되지 않은 변경 사항(Changes not staged for commit), Git이 추적하지 않는 파일(Untracked files) 등을 명확하게 보여줍니다.
    *   **사용 팁**: 커밋하기 전에 항상 `git status`를 사용하여 어떤 변경 사항이 커밋될지 확인하는 습관을 들이는 것이 좋습니다. 이는 불필요하거나 의도하지 않은 파일이 커밋되는 것을 방지합니다.

### 2.3. Git 사용자 정보 설정 (최초 1회 필수)

모든 Git 커밋은 누가 해당 변경 사항을 기록했는지 식별하기 위한 작성자 정보를 포함합니다. 이 사용자 정보는 Git을 사용하는 환경(로컬 PC)에 최초 1회만 전역적으로 설정해두면 됩니다.

*   **`git config --global user.name "사용자 이름"`**
    *   **설명**: Git 커밋에 기록될 사용자 이름을 설정합니다. 이 이름은 Git 호스팅 서비스(예: GitHub)에 표시되며, 커밋 이력을 통해 누가 어떤 변경을 했는지 쉽게 알 수 있도록 돕습니다.
    *   **예시**: `git config --global user.name "John Doe"`

*   **`git config --global user.email "이메일 주소"`**
    *   **설명**: Git 커밋에 기록될 사용자 이메일 주소를 설정합니다. 이 이메일 주소는 GitHub 계정과 연동되어 커밋이 사용자 프로필에 올바르게 귀속되도록 합니다.
    *   **예시**: `git config --global user.email "john.doe@example.com"`

*   **`git config --global --list`** (또는 `-l`)
    *   **설명**: 전역으로 설정된 모든 Git 구성 정보를 확인합니다. `user.name`과 `user.email`이 올바르게 설정되었는지 검증할 때 유용합니다. `global` 설정은 해당 사용자 계정의 모든 Git 저장소에 적용됩니다.
    *   **특정 값 확인**: `git config user.name` 또는 `git config user.email`로 특정 값만 확인할 수도 있습니다.
    *   **참고**: 특정 프로젝트에만 적용되는 사용자 정보를 설정하려면 `git config user.name "프로젝트 이름"`과 같이 `--global` 옵션 없이 명령어를 실행하면 됩니다. 이 경우 `.git/config` 파일에 정보가 저장됩니다.

### 2.4. 변경 사항 커밋 (Commit)

*   **`git commit -m "커밋 메시지"`**
    *   **설명**: 스테이징 영역에 있는 모든 변경 사항을 **로컬 저장소의 영구적인 기록 (커밋)**으로 저장합니다. 각 커밋은 프로젝트의 특정 시점의 완벽한 스냅샷을 나타내며, 고유한 해시(ID)를 가집니다. `--message` 또는 `-m` 옵션 뒤에는 이 커밋이 어떤 변경 사항을 포함하는지 설명하는 **간결하고 명확한 메시지**를 작성해야 합니다.
    *   **예시**: `git commit -m "feat: 사용자 로그인 기능 구현"`
    *   **모범 사례**:
        *   **간결한 제목**: 첫 줄은 50자 이내로 변경 사항을 요약합니다. `타입: 제목` (예: `feat:`, `fix:`, `docs:`, `refactor:`) 형태를 권장합니다.
        *   **자세한 설명 (선택 사항)**: 한 줄 띄운 뒤, 변경의 이유, 문제 해결 방식, 영향 등을 자세히 서술할 수 있습니다.
        *   **단위 작업**: 하나의 커밋은 하나의 논리적인 변경 단위만 포함하도록 합니다.

*   **`git log`**
    *   **설명**: 현재 저장소의 **커밋 이력**을 최신순으로 확인합니다. 각 커밋의 고유 ID (해시), 작성자, 날짜, 커밋 메시지 등을 자세히 보여줍니다. 커밋 이력을 통해 프로젝트의 변경 과정을 추적하고 특정 시점으로 돌아갈 수 있습니다.
    *   **유용한 옵션**:
        *   `git log --oneline`: 각 커밋을 한 줄로 요약하여 보여주므로, 전체 이력을 빠르게 파악할 때 유용합니다.
        *   `git log --graph --oneline --decorate`: 브랜치 및 병합 이력을 아스키 그래프로 시각화하여 보여주므로, 복잡한 브랜치 구조를 이해하는 데 도움이 됩니다.
        *   `git log --stat`: 각 커밋에서 어떤 파일이 변경되었고, 몇 줄이 추가/삭제되었는지 요약하여 보여줍니다.
        *   `git log -p`: 각 커밋의 실제 변경 내용(diff)을 보여줍니다.
        *   `git log --author="이름"`: 특정 작성자의 커밋만 필터링합니다.

## 3. 원격 저장소 연동 및 관리

로컬에서 작업한 내용을 팀원들과 공유하거나 다른 환경에서 접근하기 위해서는 원격 저장소와의 연동이 필수적입니다.

### 3.1. 원격 저장소 연결

*   **`git remote add <별칭> <원격 저장소 URL>`**
    *   **설명**: 로컬 Git 저장소를 **새로운 원격 저장소와 연결**합니다. `<별칭>`은 이 원격 저장소를 가리키는 짧은 이름으로, 관례적으로 `origin`을 사용하여 주 원격 저장소를 지정합니다. `<원격 저장소 URL>`은 GitHub 등에서 제공하는 저장소 주소(HTTPS 또는 SSH)입니다.
    *   **예시**: `git remote add origin https://github.com/사용자명/레포지토리명.git`
    *   **참고**: `git clone` 명령으로 저장소를 처음 복제하는 경우, `origin`이라는 별칭으로 원격 저장소가 자동으로 설정되므로 이 명령을 수동으로 실행할 필요가 없습니다.

*   **`git remote -v`**
    *   **설명**: 현재 로컬 저장소에 설정된 **원격 저장소 목록**과 해당 URL (fetch/push)을 확인합니다. 이를 통해 올바른 원격 저장소에 연결되어 있는지 확인할 수 있습니다.

### 3.2. 원격 저장소 연결 해제

*   **`git remote rm <별칭>`**
    *   **설명**: 지정된 `<별칭>`에 해당하는 **원격 저장소 연결을 제거**합니다. 예를 들어 `git remote rm origin`은 `origin` 원격 저장소와의 연결을 끊습니다.

### 3.3. 로컬 변경 사항 원격으로 전송 (Push)

*   **`git push <원격 별칭> <브랜치명>`**
    *   **설명**: 로컬 저장소의 커밋된 변경 사항들을 지정된 `<원격 별칭>`의 `<브랜치명>`으로 **업로드**합니다. 이는 로컬에서 작업한 내용을 원격 저장소에 반영하여 다른 팀원들이 접근할 수 있도록 하는 가장 일반적인 방법입니다.
    *   **예시**: `git push origin master` (또는 `main`)
    *   **최초 Push 시 (업스트림 설정)**: `git push -u origin master` 또는 `git push --set-upstream origin master` 명령어를 사용하면, 현재 로컬 브랜치가 `origin` 원격 저장소의 `master` 브랜치에 연결되어 이후 `git push` (별칭 및 브랜치명 없이)만으로도 해당 원격 브랜치로 푸시할 수 있도록 업스트림(upstream) 설정을 해줍니다. 이 설정은 한 번만 해주면 됩니다.

*   **`git push <원격 별칭> +<브랜치명>` (강제 Push)**
    *   **경고**: 이 명령은 **매우 위험하며 극도로 신중하게 사용**해야 합니다. 로컬 브랜치의 이력을 원격 브랜치에 **강제로 덮어씌웁니다.** 이는 원격 저장소의 다른 사람들의 작업 이력을 삭제하거나 꼬이게 할 수 있어 팀 작업 환경에서는 치명적인 문제를 야기할 수 있습니다.
    *   **사용 시점**: Git 이력을 재작성한 (예: `git rebase` 또는 `git commit --amend` 후) 경우, 그리고 해당 브랜치가 본인만 사용하는 개인 브랜치이거나, 팀원들과의 충분한 조율과 동의를 거쳐 변경 사항을 강제로 적용해야 할 때만 사용합니다. 일반적인 상황에서는 절대 사용하지 마십시오.

## 4. Git Clone vs. Pull: 차이점 이해

Git 저장소를 가져오거나 업데이트하는 두 가지 주요 방법이지만, 그 목적과 작동 방식은 명확히 다릅니다.

### 4.1. `git clone`

*   **정의**: **새로운 환경에서 원격 저장소의 전체 사본을 처음으로 다운로드**할 때 사용합니다.
*   **특징**:
    *   원격 저장소의 **모든 커밋 이력, 브랜치, 파일**을 로컬로 복사하여 완벽한 로컬 저장소를 생성합니다.
    *   자동으로 다운로드된 저장소의 원격 별칭 (`origin`)을 설정하고, 로컬 저장소와 원격 저장소 간의 연결을 구축합니다. `git remote add origin ...` 명령을 별도로 실행할 필요가 없습니다.
    *   새로운 프로젝트를 시작하거나, 기존 프로젝트에 처음으로 참여하여 전체 코드를 가져와야 할 때 사용합니다.
*   **명령어**: `git clone <원격 저장소 URL>`
    *   **예시**: `git clone https://github.com/사용자명/레포지토리명.git`
    *   특정 디렉토리로 클론하려면: `git clone <원격 저장소 URL> <대상 디렉토리명>`

### 4.2. `git pull`

*   **정의**: **이미 로컬에 존재하는 Git 저장소를 원격 저장소의 최신 변경 사항으로 업데이트**할 때 사용합니다.
*   **특징**:
    *   원격 저장소에서 변경 사항을 가져와(`git fetch` 명령의 역할) 로컬 브랜치에 자동으로 병합(`git merge` 명령의 역할)하는 **두 단계 작업**을 수행합니다.
    *   동일한 프로젝트에서 다른 팀원이 변경 사항을 푸시했거나, 여러 기기에서 작업할 때 로컬 환경을 최신 상태로 유지하는 데 필수적입니다.
    *   `git pull`을 실행하기 전에 로컬에 커밋되지 않은 변경 사항이 있다면 충돌이 발생할 수 있으므로, 미리 커밋하거나 임시 저장(stash)하는 것이 좋습니다.
*   **명령어**: `git pull <원격 별칭> <브랜치명>`
    *   **예시**: `git pull origin master` (또는 `main`)
    *   **`git pull`과 `git fetch`의 차이**: `git fetch`는 원격 저장소의 최신 변경 사항을 가져오기만 하고 로컬 워킹 디렉토리나 브랜치를 업데이트하지 않습니다. `git pull`은 `git fetch` 후 `git merge`까지 자동으로 수행합니다.

*   **강제 Pull (`git pull origin +<브랜치명>`)**: `git push`의 강제 푸시와 유사하게, `git pull`에 `+` 옵션을 사용하는 것은 로컬 브랜치를 원격 브랜치로 **강제로 덮어씌워 업데이트**할 때 사용될 수 있습니다. 이는 로컬 변경 사항을 강제로 버리고 원격 상태와 완전히 동일하게 만들 때 사용되는데, 로컬 이력을 잃을 수 있는 위험이 있어 **매우 드물게, 그리고 특별한 상황에서만 사용**됩니다. 일반적인 상황에서는 절대 사용하지 마십시오.

### 4.3. 요약: `clone` vs. `pull`

| 기능          | `git clone`                               | `git pull`                                          |
| :------------ | :---------------------------------------- | :-------------------------------------------------- |
| **목적**      | 원격 저장소를 **최초로 로컬에 복제**      | 기존 로컬 저장소를 **원격의 최신 상태로 동기화**    |
| **수행 작업** | 전체 저장소 복사본 생성, `.git` 초기화, 원격 연결 설정 | `git fetch` (원격 변경 가져오기) + `git merge` (로컬 브랜치에 병합) |
| **사용 시점** | 프로젝트를 처음 시작하거나 참여할 때, 새로운 개발 환경 설정 시 | 이미 `clone`한 프로젝트의 내용을 동기화하여 최신 상태를 유지할 때 |

## 5. 작업 환경 변경 후 설정 및 문제 해결 팁

개발 환경 (예: 새로운 PC, 자리 이동)을 변경한 후 Git 작업 시 발생할 수 있는 일반적인 문제와 그 해결 방법입니다.

1.  **Git 사용자 정보 확인**:
    *   **명령어**: `git config --global --list`
    *   **목적**: 새로운 환경에서 `user.name`과 `user.email`이 올바르게 설정되어 있는지 확인하는 것이 중요합니다. 잘못된 정보로 커밋되거나, GitHub/GitLab 등에서 커밋이 본인 계정에 올바르게 귀속되지 않는 것을 방지합니다.

2.  **Windows 자격 증명 관리자 초기화 (인증 오류 해결)**:
    *   **경로**: `제어판` → `사용자 계정` → `자격 증명 관리자` → `Windows 자격 증명`
    *   **조치**: `git:https://github.com` (또는 `gitlab.com`, `bitbucket.org` 등)과 관련된 모든 항목을 찾아 삭제합니다.
    *   **목적**: 이전에 저장된 GitHub/GitLab 로그인 정보(토큰 또는 비밀번호)가 만료되거나 변경되어 `git push` 또는 `git pull` 시 인증 실패 (`Authentication failed`, `remote: Repository not found`, `fatal: Authentication failed for ...`) 문제가 발생하는 경우, 이 정보를 삭제하여 Git이 다시 로그인 프롬프트를 표시하게 합니다. macOS나 Linux에서는 키체인(Keychain) 또는 자격 증명 헬퍼(credential helper)를 확인하고 관련 정보를 삭제할 수 있습니다.

## 6. `.gitignore` 파일 활용

### 6.1. `.gitignore` 파일 생성 목적

Git은 기본적으로 프로젝트 디렉토리 내의 모든 파일을 추적할 수 있지만, 특정 파일이나 폴더는 버전 관리에서 제외하고 싶을 때가 많습니다. `.gitignore` 파일은 이러한 **의도적으로 Git 추적에서 제외할 파일 및 디렉토리를 지정**하는 데 사용됩니다.

*   **편의성 및 효율성**: 불필요하거나 임시적인 파일들이 `git add .` 명령으로 실수로 스테이징 영역에 추가되거나 커밋되는 것을 방지합니다. 이는 `.git` 저장소의 불필요한 크기 증가를 막고, `git status` 출력을 깔끔하게 유지합니다.
*   **용량 최적화**: 바이너리 파일(예: `.jar`, `.class`, `.exe`), 빌드 결과물(예: `dist/`, `build/`), 의존성 모듈 폴더(예: `node_modules/`, `vendor/`) 등 용량이 매우 크고 재빌드 가능한 파일들을 저장소에 포함시키지 않아 저장소의 크기를 관리하고 클론/푸시/풀 속도를 최적화합니다.
*   **보안 및 개인 정보 보호**: API 키, 비밀번호, 민감한 환경 변수 (`.env` 파일), 개인 설정 파일 등 보안상 외부에 공개되어서는 안 되는 파일들을 Git 저장소에서 제외합니다. 이러한 파일들은 `.gitignore`에 추가하여 실수로 원격 저장소에 푸시되는 것을 방지해야 합니다.
*   **불필요한 변경 기록 방지**: IDE 설정 파일(예: `.idea/`, `.vscode/`), 운영체제에서 생성되는 임시 파일(예: `.DS_Store` on macOS, `Thumbs.db` on Windows), 로그 파일(`*.log`) 등 협업에 불필요하거나 개인의 작업 환경에만 해당하는 파일들의 변경 기록이 커밋 이력에 남는 것을 방지하여 이력을 깔끔하게 유지하고, 불필요한 충돌 발생 가능성을 줄입니다.

### 6.2. `.gitignore` 파일 작성 방법

1.  **파일 생성**: 프로젝트의 **최상위 디렉토리**에 `.gitignore`라는 이름의 파일을 생성합니다. (`.git` 디렉토리와 같은 레벨에 있어야 합니다.)
2.  **규칙 작성**: `.gitignore` 파일 내부에 무시할 파일 또는 폴더의 이름을 한 줄에 하나씩 작성합니다.

    *   **주요 패턴 규칙**:
        *   `파일명.확장자`: 특정 파일만 무시 (예: `my_secret_key.pem`)
        *   `*.확장자`: 특정 확장자를 가진 모든 파일 무시 (예: `*.log`, `*.tmp`)
        *   `폴더명/`: 특정 폴더 및 그 안의 모든 파일 무시 (예: `temp/`, `node_modules/`)
        *   `/폴더명`: 프로젝트 루트에 있는 특정 폴더만 무시. 다른 서브디렉토리의 동일 이름 폴더는 무시하지 않음 (예: `/build`)
        *   `!파일명`: 무시 규칙에 포함된 파일이라도 예외적으로 추적 (예: `!src/main.js` - `src/` 폴더 전체를 무시하지만 `main.js`는 추적)
        *   `#`: 주석 처리 (해당 줄은 Git에 의해 무시되지 않음)

    *   **자주 무시하는 파일 유형 예시**:
        ```gitignore
        # 빌드 결과물 및 컴파일된 파일
        *.log        # 모든 로그 파일
        *.tmp        # 모든 임시 파일
        *.bak        # 백업 파일
        *.class      # Java 컴파일 결과
        *.jar        # Java 실행 파일
        *.pyc        # Python 컴파일된 바이트코드
        build/       # 빌드 결과물 디렉토리 (프로젝트 루트)
        dist/        # 배포용 빌드 디렉토리

        # 패키지 관리자 관련
        node_modules/ # Node.js 의존성 모듈
        vendor/       # PHP Composer 의존성 모듈
        .bundle/      # Ruby Bundler 의존성
        venv/         # Python 가상 환경

        # 환경 설정 및 비밀 정보
        .env         # 환경 변수 파일
        config.ini   # 설정 파일 (민감 정보 포함 가능성)
        secrets.json # 비밀 정보 파일

        # IDE 및 운영체제 생성 파일
        .idea/       # IntelliJ IDEA 설정 디렉토리
        .vscode/     # VS Code 설정 디렉토리
        .DS_Store    # macOS 시스템 파일
        Thumbs.db    # Windows 썸네일 캐시
        *.iml        # IntelliJ IDEA 모듈 파일

        # 테스트 및 캐시
        /coverage    # 코드 커버리지 결과
        .nyc_output/ # NYC (Istanbul) 코드 커버리지

        # 특정 파일 예외 처리
        !src/important.js # src/ 폴더가 무시되더라도 important.js는 추적
        ```

3.  **저장**: `.gitignore` 파일을 저장하면 Git이 다음 `git status` 명령부터 해당 규칙에 따라 파일을 무시합니다.

**주의**: `.gitignore` 파일에 추가하기 *전에* 이미 Git에 의해 추적되고 있는 파일은 `.gitignore`에 추가하더라도 무시되지 않습니다. 이 경우, 해당 파일을 Git 추적에서 먼저 제외해야 합니다 (`git rm --cached <파일경로>`).

## 7. Git 이력 및 변경 사항 관리

Git은 강력한 이력 관리 기능을 제공하며, 이를 통해 과거로 돌아가거나, 특정 변경 사항을 취소하거나, 커밋 이력을 수정할 수 있습니다.

### 7.1. 마지막 커밋 수정하기 (`git commit --amend`)

*   **명령어**: `git commit --amend`
*   **설명**: 가장 최근에 생성한 커밋(HEAD)을 수정할 때 사용합니다. 이 명령은 현재 스테이징 영역에 있는 변경 사항을 마지막 커밋에 추가하거나, 마지막 커밋의 메시지를 수정할 수 있게 해줍니다. `amend`는 새로운 커밋을 생성하여 이전 커밋을 대체하므로, **커밋 해시(ID)가 변경**됩니다.
*   **사용 시점**:
    *   방금 커밋했는데 커밋 메시지에 오타가 있거나, 메시지를 더 명확하게 쓰고 싶을 때.
    *   커밋할 파일을 빠뜨렸거나, 불필요한 파일을 실수로 커밋에 포함했을 때. (`git add` 후 `git commit --amend` 또는 `git reset HEAD~1` 후 `git add` 및 `git commit`)
*   **주의 사항**: 이미 원격 저장소에 푸시한 커밋에 대해 `amend`를 사용하는 것은 **매우 위험**합니다. 커밋 해시가 변경되므로, 이후 `git push` 시 충돌이 발생하거나 `git push --force` (강제 푸시)를 사용해야 할 수 있으며, 이는 다른 팀원의 이력과 불일치를 야기할 수 있습니다. 로컬에서만 존재하는 커밋에 대해서만 사용하는 것이 안전합니다.
*   **Vim 에디터에서 메시지 수정**: 명령어를 실행하면 기본 텍스트 에디터(대부분 Vim)가 열립니다.
    *   `i` 키를 눌러 `INSERT` 모드로 진입합니다.
    *   메시지를 수정합니다.
    *   `Esc` 키를 눌러 `NORMAL` 모드로 돌아갑니다.
    *   `:wq`를 입력하고 `Enter` 키를 눌러 저장 후 종료합니다. (`:q!`는 저장하지 않고 강제 종료)

### 7.2. 특정 커밋 되돌리기 (Revert)

*   **명령어**: `git revert <커밋_해시>`
*   **설명**: 특정 과거 커밋에서 발생한 변경 사항을 **취소하는 새로운 커밋을 생성**합니다. 예를 들어, 커밋 `X`가 추가한 내용을 `git revert X`는 제거하고, 커밋 `X`가 제거한 내용을 `git revert X`는 다시 추가하는 식으로 작동합니다. 이 방법은 기존의 커밋 이력을 보존하면서 특정 변경 사항만 되돌리고 싶을 때 사용됩니다.
*   **사용 시점**: 이미 원격 저장소에 푸시된 커밋의 내용을 되돌리고 싶을 때 가장 안전한 방법입니다. 기존 이력을 건드리지 않으므로 팀 협업에 영향을 주지 않습니다.
*   **예시**:
    1.  `a.txt` 생성 및 커밋 (`A`)
    2.  `b.txt` 생성 및 커밋 (`B`)
    3.  `c.txt` 생성 및 커밋 (`C`)
    4.  만약 커밋 `B`의 내용을 되돌리고 싶다면: `git revert <B_커밋_해시>`
    5.  Git은 `B`의 변경 사항을 되돌리는 새로운 커밋 `D`를 생성합니다. `A`, `B`, `C`, `D` 모든 커밋이 이력에 남아 있습니다.
*   **Vim 에디터에서 메시지 확인/수정**: 명령어를 실행하면 `Revert "..."` 메시지가 미리 작성된 Vim 에디터가 열립니다. 확인 후 `:wq`로 저장하고 종료합니다.

### 7.3. 특정 상태로 저장소 초기화 (Reset)

*   **명령어**: `git reset <모드> <대상_커밋>`
*   **설명**: `HEAD` (현재 작업 중인 브랜치의 최신 커밋을 가리키는 포인터)를 지정된 `<대상_커밋>`으로 이동시킵니다. 이 명령은 로컬 저장소의 이력을 **실제로 변경**하며, 지정된 모드에 따라 스테이징 영역과 워킹 디렉토리의 상태에도 영향을 미칩니다. `reset`은 주로 로컬에서 작업 중인 이력을 정리하거나, 커밋을 취소할 때 사용됩니다.
*   **주의 사항**: 이미 원격 저장소에 푸시된 커밋에 대해 `git reset --hard`를 사용하는 것은 **절대 피해야 합니다.** 이력 손실 및 팀원 간의 작업 불일치를 초래할 수 있습니다.
*   **`git reset`의 주요 모드**:
    *   **`git reset --soft <대상_커밋>`**: `HEAD`만 `<대상_커밋>`으로 이동시킵니다. 워킹 디렉토리와 스테이징 영역의 파일은 그대로 유지됩니다. 이전 커밋과의 차이점이 스테이징 영역에 남아있어 새로운 커밋으로 다시 만들 수 있습니다.
    *   **`git reset --mixed <대상_커밋>` (기본값)**: `HEAD`를 이동시키고, 스테이징 영역도 `<대상_커밋>` 상태로 되돌립니다. 워킹 디렉토리의 파일은 그대로 유지됩니다. 이전 커밋과의 차이점이 워킹 디렉토리에 'Unstaged' 상태로 남아있어 다시 `git add`로 스테이징할 수 있습니다.
    *   **`git reset --hard <대상_커밋>`**: `HEAD`, 스테이징 영역, 워킹 디렉토리 **모두** `<대상_커밋>` 상태로 완전히 되돌립니다. `<대상_커밋>` 이후의 모든 변경 사항은 **영구적으로 삭제**되므로 **가장 위험한 모드**입니다. 매우 신중하게 사용해야 합니다.
*   **`git reflog` 활용**: `git reset --hard` 등으로 작업 이력을 잃어버렸을 때, `git reflog`는 Git 저장소의 **모든 HEAD의 이동 기록**을 보여줍니다. 이를 통해 과거의 어떤 상태로든 되돌아갈 수 있는 커밋 해시(또는 `HEAD@{번호}`)를 찾을 수 있습니다.
    *   **예시**: `git reset --hard HEAD@{2}` (reflog에서 2번째 이전 상태로 되돌림)

### 7.4. Staging Area 변경 사항 취소하기 (`git restore`, `git rm --cached`)

이미 `git add`로 스테이징 영역에 올린 파일을 워킹 디렉토리 상태로 되돌리거나, 아예 Git 추적에서 제외할 때 사용합니다.

*   **`git restore --staged <파일경로>` (Git 2.23 버전 이상 권장)**
    *   **설명**: 스테이징 영역에 있는 특정 파일의 변경 사항을 취소하고, 해당 파일을 워킹 디렉토리의 'Unstaged' 상태로 되돌립니다. 파일의 내용은 그대로 유지됩니다.
    *   **예시**: `git restore --staged index.html`
    *   **참고**: Git 2.23 버전부터 `git restore` 명령이 도입되어 `git reset`과 `git checkout`의 일부 기능을 대체하며, 워킹 디렉토리와 스테이징 영역 간의 상태 관리를 더 명확하게 해줍니다.

*   **`git reset HEAD <파일경로>` (Git 2.23 버전 이전)**
    *   **설명**: 위 `git restore --staged`와 동일한 기능을 수행합니다. `HEAD`는 현재 커밋을 가리키며, 특정 파일을 `HEAD` 상태로 'unstaged' 시키는 명령입니다.

*   **`git rm --cached <파일경로>`**
    *   **설명**: 특정 파일을 **Git의 추적 대상에서 제외**합니다. 파일 자체는 워킹 디렉토리에 남아 있지만, Git은 더 이상 이 파일의 변경 사항을 추적하지 않습니다. 이 파일은 이후 `git status`에서 'Untracked file'로 표시되며, 필요하다면 `.gitignore`에 추가하여 영구적으로 무시할 수 있습니다.
    *   **사용 시점**: 이미 커밋되어 Git이 추적하고 있는 파일을 더 이상 버전 관리할 필요가 없을 때 (예: 실수로 커밋한 민감한 정보 파일).
    *   **주의**: `git rm <파일경로>` ( `--cached` 옵션 없이)를 사용하면 Git 추적에서 제외될 뿐만 아니라 **워킹 디렉토리에서도 파일이 삭제**되므로 주의해야 합니다.


## 1) SQL 문장은 “목적”으로 나뉜다

실무/과제에서는 SQL을 다음 2축으로 쓰게 된다.

* **DDL(Data Definition Language)**: 테이블(구조)을 만든다/바꾼다/없앤다

  * `CREATE`, `ALTER`, `DROP`
* **DML(Data Manipulation Language)**: 테이블 안의 데이터(행)를 넣고/수정/삭제한다

  * `INSERT`, `UPDATE`, `DELETE`

즉, **DDL은 “스키마(설계)”를 만지고, DML은 “레코드(내용)”를 만진다**고 구분하면 된다.

---

## 2) CREATE TABLE: 테이블은 “열 정의 + 제약조건”으로 만들어진다

테이블을 만든다는 것은 결국 아래 두 가지를 정하는 것이다.

1. **컬럼(필드)**: 어떤 값들을 저장할지
2. **제약조건(Constraints)**: 어떤 규칙으로 저장할지(데이터 품질 보장)

### 2-1) 기본 문법 감각

```sql
CREATE TABLE table_name (
  column1 datatype constraints,
  column2 datatype constraints,
  ...
);
```

이 형태 자체가 핵심이다.

### 2-2) 예시로 “설계 감각” 잡기

문서의 예시는 다음 느낌이다. `ExamId`를 자동 증가하는 기본키로 두고, 이름 컬럼들은 NULL을 허용하지 않게 만든다.

```sql
CREATE TABLE examples (
  ExamId INTEGER PRIMARY KEY AUTOINCREMENT,
  LastName VARCHAR(50) NOT NULL,
  FirstName VARCHAR(50) NOT NULL
);
```

여기서 중요한 포인트는 이거다.

* `PRIMARY KEY`는 “행을 유일하게 식별하는 대표값”이다
* `AUTOINCREMENT`는 “새 행이 들어올 때마다 자동으로 숫자를 올려서 넣는 방식”이다
* `NOT NULL`은 “무조건 값이 있어야 저장 가능”이라는 규칙이다

### 2-3) Constraints(제약조건)는 “DB가 데이터 품질을 강제로 지키게 하는 장치”다

제약조건은 “개발자가 실수해도 DB가 막아주는 안전장치”라고 이해하면 된다. 대표적으로 다음이 등장한다. 

* **PRIMARY KEY**: 중복/NULL 불가 + 유일 식별
* **NOT NULL**: 빈 값 저장 금지
* **FOREIGN KEY**: 다른 테이블의 기본키를 참조해서 관계를 만든다(조인 기반)

---

## 3) PRAGMA table_info: “내가 만든 테이블 구조를 확인”하는 습관이 중요하다

SQL을 작성할 때 제일 흔한 실수가 “내가 생각한 컬럼명/타입/제약이 실제 테이블과 다름”이다.
그래서 테이블 만들고/수정한 뒤에는 **스키마를 확인하는 루틴**을 들이는 게 좋다. 문서에서도 `PRAGMA table_info(...)`로 구조 확인을 시킨다.

---

## 4) ALTER TABLE: “이미 운영 중인 테이블”을 바꾸는 기술이다

운영하다 보면 요구사항이 바뀌어서 컬럼을 추가하거나 이름을 바꾸거나 삭제해야 한다. 이때 쓰는 게 `ALTER TABLE`이다.

문서에서 다루는 변경 유형은 다음과 같다.

* `ADD COLUMN` 컬럼 추가
* `RENAME COLUMN` 컬럼 이름 변경
* `DROP COLUMN` 컬럼 삭제
* `RENAME TO` 테이블 이름 변경

### 4-1) ADD COLUMN: 컬럼을 추가할 때 “기존 데이터”를 반드시 생각해야 한다

```sql
ALTER TABLE examples
ADD COLUMN Country VARCHAR(100) NOT NULL DEFAULT 'default value';
```

이 예시가 중요한 이유는 이거다.

* 테이블에 이미 행이 존재하면, 새 컬럼은 기존 행에도 생긴다
* 그런데 `NOT NULL`이면 기존 행에도 값이 있어야 한다
* 그래서 **DEFAULT를 같이 주는 흐름**이 자연스럽다

즉, **“운영 테이블에 NOT NULL 컬럼을 추가할 거면 DEFAULT(또는 nullable) 전략이 필요하다”**가 핵심 감각이다.

추가로, Age / Address 같은 컬럼을 연달아 추가하는 예시도 나온다.

### 4-2) RENAME COLUMN: 컬럼명 변경은 “의미를 명확히 할 때” 자주 쓴다

```sql
ALTER TABLE examples
RENAME COLUMN Address TO PostCode;
```

이런 형태로 컬럼명을 바꾼다.

### 4-3) DROP COLUMN: 삭제는 신중해야 한다

컬럼 삭제는 복구가 어렵다. “나중에 필요할지도”라는 생각이 들면 보통은 바로 DROP하지 않고, 먼저 사용처를 제거하고 데이터 백업/마이그레이션 계획을 세운 뒤 진행한다. 문서에서는 `DROP COLUMN PostCode` 형태를 보여준다.

### 4-4) RENAME TO: 테이블 이름 변경

```sql
ALTER TABLE examples
RENAME TO new_examples;
```

테이블 이름을 바꿀 때 쓴다.

---

## 5) DROP TABLE: 테이블 자체를 삭제한다

`DROP TABLE table_name;` 형태로 테이블을 통째로 삭제한다.
이건 “구조도, 데이터도” 같이 날아가므로 테스트 환경에서 자주 쓰고, 운영에서는 매우 신중해야 한다.

---

## 6) INSERT / UPDATE / DELETE: 데이터(행)를 조작하는 3종 세트다

### 6-1) INSERT: 새 행을 추가한다

문서 흐름은 “기존 테이블 확인 → 필요하면 DROP → PRAGMA로 구조 확인 → CREATE → INSERT”로 실습 루틴을 잡아준다.

기본 문법은 다음 두 가지 형태를 기억하면 된다.

1. 특정 컬럼만 지정해서 넣기(실무에서 가장 흔함)

```sql
INSERT INTO articles (title, content, createdAt)
VALUES ('hello', 'world', '2000-01-01');
```

2. 여러 행을 한 번에 넣기(배치)

```sql
INSERT INTO articles (title, content, createdAt)
VALUES
  ('title1', 'content1', '1900-01-01'),
  ('title2', 'content2', '1800-01-01'),
  ('title3', 'content3', '1700-01-01');
```

실습 화면에서도 여러 행이 추가되는 형태가 나온다.

### 6-2) UPDATE: 기존 행을 수정한다

UPDATE에서 제일 중요한 경고는 이거다.

* `WHERE`가 없으면 **전체 행이 수정될 수 있다**
* 그래서 UPDATE는 “수정 대상이 정확한가”를 먼저 확인하는 습관이 필요하다

기본 형태는 다음과 같다.

```sql
UPDATE table_name
SET column_name = expression,
    column2 = expression
WHERE condition;
```

문서 예시는 id=2인 글의 title/content를 바꾸는 식이다.

### 6-3) DELETE: 행을 삭제한다

DELETE도 UPDATE와 똑같이 “WHERE 유무”가 생명이다.

```sql
DELETE FROM articles
WHERE id = 1;
```

또한 문서에는 **최근 2개만 남기고 나머지를 지우는 형태**처럼, 서브쿼리/정렬/limit을 섞어서 삭제하는 예시 흐름이 나온다. 이런 건 “지우기 전에 먼저 SELECT로 대상이 맞는지 확인”하는 습관이 반드시 필요하다.

---

## 7) JOIN: 여러 테이블을 “관계로 이어 붙여서” 한 번에 조회하는 기술이다

JOIN은 관계형 DB의 핵심이다. 테이블을 나눠서(정규화) 중복을 줄인 대신, 조회할 때는 다시 합쳐서 의미 있는 결과를 만든다.

문서에서는 게시글을 예로 들어, 처음엔 한 테이블에 writer/role까지 다 넣어두면 중복이 커진다는 점을 보여주고, 이를 `articles`, `users`, `roles`로 나눠 관리하는 흐름을 보여준다.

그리고 `articles.userId -> users.id`, `users.roleId -> roles.id`처럼 **FK 관계**를 통해 JOIN이 가능해진다는 그림을 준다.

---

## 8) INNER JOIN vs LEFT JOIN: “결과에 누가 남는가”만 보면 된다

### 8-1) INNER JOIN: 양쪽에 모두 존재하는 것만 남긴다

문서의 문법 틀은 다음과 같다.

```sql
SELECT select_list
FROM table_a
INNER JOIN table_b
ON table_a.fk = table_b.pk;
```

감각적으로는 “교집합”이다.

* 게시글(articles)과 유저(users)를 조인하면
* `articles.userId`가 실제로 존재하는 유저에 매칭되는 행만 결과에 남는다

예시로는 이런 형태가 나온다.

```sql
SELECT *
FROM articles
INNER JOIN users
ON users.id = articles.userId;
```

그리고 “특정 유저(id=1)가 작성한 글만”처럼 WHERE까지 결합하는 흐름도 나온다.

---

### 8-2) LEFT JOIN: 왼쪽 테이블은 무조건 남기고, 오른쪽이 없으면 NULL로 채운다

LEFT JOIN은 “왼쪽 기준으로 전부 보여주되, 매칭이 없으면 오른쪽 컬럼이 NULL”이 된다.

문서의 문법 틀은 다음이다.

```sql
SELECT select_list
FROM table_a
LEFT JOIN table_b
ON table_a.fk = table_b.pk;
```

이걸 어디에 쓰느냐가 핵심이다.

* “**글을 안 쓴 유저**도 포함해서 유저 목록을 보고 싶다” 같은 상황에서 LEFT JOIN이 필요하다
* 그리고 매칭이 안 된 쪽은 NULL이 되니까, 그걸 `WHERE ... IS NULL`로 잡아내면 된다

문서에도 “작성한 글이 없는 회원 정보 조회”처럼 `articles.userId IS NULL` 조건을 이용하는 예시가 나온다.

---

## 9) 오늘  요약

* **CREATE/ALTER/DROP**으로 테이블 구조를 설계하고 바꾼다.
* **INSERT/UPDATE/DELETE**로 데이터를 운영한다. 단, UPDATE/DELETE는 WHERE가 없으면 사고가 난다.
* 테이블을 나눠 관리하는 순간, 의미 있는 조회는 **JOIN**이 만든다.

  * INNER JOIN은 “둘 다 있어야 남는다”
  * LEFT JOIN은 “왼쪽은 무조건 남고, 오른쪽이 없으면 NULL이다”

---

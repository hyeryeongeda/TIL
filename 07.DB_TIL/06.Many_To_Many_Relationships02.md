# Django 다대다(Many-to-Many) 02 개념서 · TIL

(팔로우 기능 + 프로필 페이지 + Fixtures + 쿼리 최적화: N+1/annotate/select_related/prefetch_related)

“다대다 관계를 **좋아요**가 아니라 **팔로우(유저-유저 자기참조)**에 적용하고, 그 과정에서 개발할 때 반드시 같이 쓰게 되는 **Fixtures**와 **쿼리 최적화**까지 한 번에 묶어서 정리 

---

## 1) 팔로우는 왜 Many-to-Many인가

팔로우는 방향이 있는 관계다.
A가 B를 팔로우할 수 있고, B가 A를 팔로우할 수도 있다. 둘 다 “여러 명”을 대상으로 관계를 맺는다.

* 한 명의 유저는 여러 명을 팔로우할 수 있다.
* 한 명의 유저는 여러 명에게 팔로우받을 수 있다.

즉 **User ↔ User**가 **M:N(다대다)** 구조가 된다. (자기 자신을 참조하는 self M2M) 

---

## 2) 프로필 페이지 구현 흐름

팔로우는 “상대 유저의 프로필 화면에서 버튼을 눌러 관계를 만든다”가 자연스럽다. 그래서 먼저 프로필 페이지 라우팅부터 만든다. (프로필 URL, view, template 연결 흐름이 이어진다.) 

### 2-1) URL이 username을 받는 이유

프로필은 보통 pk보다 username이 더 자연스럽다.
그래서 `/accounts/profile/<username>/` 같은 형태로 들어가서 그 username에 해당하는 유저를 찾아 화면을 렌더링한다. 

### 2-2) 프로필 화면에서 보여줄 것들

프로필 페이지는 “그 사람”에 대한 요약 정보가 핵심이다.

* 프로필 주인(해당 유저) 정보
* 그 유저가 작성한 글 목록(있다면)
* 팔로워 수 / 팔로잉 수
* 로그인 유저가 그 사람을 팔로우 중인지 여부
* (본인이 아닐 때만) 팔로우/언팔로우 버튼 

---

## 3) 모델 관계 설정: User(M) - User(N) 자기참조 M2M

팔로우의 본체는 모델에 한 줄 추가하는 것이다. 핵심 옵션은 3개다.

### 3-1) ManyToManyField의 “self” 의미

유저가 유저를 팔로우하니까, ManyToManyField가 “다른 모델”이 아니라 “자기 자신”을 가리킨다.
이때 `ManyToManyField('self', ...)` 형태가 된다. 

### 3-2) symmetrical=False가 왜 필요하나

팔로우는 친구 관계가 아니다.
친구는 “내가 너를 친구 추가하면 너도 나를 친구로 가진다” 같은 대칭 관계가 자연스럽지만, 팔로우는 **방향이 있다**.

* A가 B를 팔로우해도
* B가 A를 자동으로 팔로우한 것이 아니다

그래서 `symmetrical=False`가 들어간다. 이 옵션이 없으면 자기참조 M2M에서 “대칭 관계처럼 취급되는 혼란”이 생길 수 있다. 

### 3-3) related_name이 왜 중요한가

자기참조 M2M은 “같은 테이블을 두 역할로” 쓰는 구조라서, 역참조 이름이 안 잡히면 코드가 읽기 지옥이 된다.
그래서 보통 다음처럼 이름을 분리해 둔다.

* followings: 내가 팔로우하는 사람들
* followers: 나를 팔로우하는 사람들 

정리하면 “필드명과 related_name이 각각 다른 방향을 의미하도록” 설계하는 것이 핵심이다.

---

## 4) 팔로우 토글 로직 구현

팔로우 버튼은 거의 항상 토글이다.

* 이미 팔로우 중이면 → 언팔로우(remove)
* 팔로우 중이 아니면 → 팔로우(add) 

여기서 제일 중요한 예외 처리가 있다.

### 4-1) 자기 자신은 팔로우하면 안 된다

프로필 주인(person)이 로그인 유저(request.user)와 같으면 팔로우 버튼 자체를 숨기고, 서버 로직에서도 막아야 한다.
템플릿에서 “본인이면 버튼 미표시”, 뷰에서 “본인이면 처리 안 함” 둘 다 해두는 게 안전하다. 

### 4-2) follow 요청은 POST로만 받는 게 맞다

팔로우는 DB 상태를 바꾸는 동작이다. 즉 “조회(GET)”가 아니라 “변경(POST)”에 해당한다.
그래서 follow 뷰는 POST만 허용하는 방식이 자연스럽다. 

---

## 5) Fixtures: 테스트/실습용 데이터를 빠르게 주입하는 장치

팔로우 기능은 “유저가 여러 명 있어야” 확인이 된다.
그래서 fixtures로 유저/글/댓글 데이터를 한 번에 넣는 흐름이 이어진다. 

### 5-1) dumpdata가 하는 일

현재 DB에 들어있는 데이터를 **JSON 같은 파일로 뽑아내는 것**이다.
즉 “지금 상태를 그대로 저장해두는 스냅샷” 개념이다. 

### 5-2) loaddata가 하는 일

dumpdata로 뽑아낸 파일을 다시 DB에 **그대로 주입**하는 것이다.
즉 “스냅샷을 복원”하는 개념이다. 

### 5-3) fixtures 파일 위치가 중요한 이유

Django는 기본적으로 `app_name/fixtures/` 경로를 기준으로 fixtures를 찾는 흐름이 나온다.
경로가 틀리면 “fixture 못 찾음” 에러가 나기 쉽다. 

### 5-4) loaddata 순서가 중요한 이유

관계가 있는 테이블을 로드할 때는 **외래키 참조 순서**를 지켜야 한다.
예를 들어 댓글이 유저/게시글을 참조한다면, 유저/게시글이 먼저 로드되어 있어야 댓글이 들어갈 수 있다.
순서가 꼬이면 “FK 제약조건 위반” 에러가 나는 흐름이 자료에 나온다. 

---

## 6) Improve query: N+1 문제는 “관계 조회”에서 거의 무조건 만난다

프로필/게시글 목록 페이지 같은 곳에서 다음을 동시에 보여주려 하면 문제가 터진다.

* 게시글 N개를 가져옴
* 각 게시글마다 작성자(user)도 출력함
* 각 게시글마다 댓글 개수도 출력함
* 각 게시글마다 댓글 목록도 출력함

이때 “한 번에 끝날 것 같은 화면”이 실제로는 DB에 엄청 많은 쿼리를 날릴 수 있다. 이게 N+1 문제다. 

---

## 7) annotate: “댓글 개수” 같은 집계를 한 방에 붙이는 기술

게시글 목록에서 “댓글 수”를 표시하려면, 가장 단순한 구현은 템플릿에서 `article.comment_set.all()`을 돌면서 세는 방식이다.
그런데 이 방식은 게시글마다 댓글을 따로 조회하게 되어 N+1이 된다.

이때 `annotate()`를 쓰면, **DB가 집계를 해서 결과에 컬럼처럼 붙여준다.**
즉 “게시글 목록 + 댓글 수”를 한 번의 흐름으로 가져오게 된다. 

핵심 감각은 이렇다.

* annotate는 결과 행에 “추가 필드”를 붙인다
* Count/Sum/Avg 같은 집계 결과를 `comment_count` 같은 이름으로 붙인다
* 템플릿에서는 `article.comment_count`처럼 일반 필드처럼 사용한다 

---

## 8) select_related: ForeignKey/OneToOne에 최적이다

게시글 목록에서 `article.user.username`을 출력할 때, 게시글마다 유저를 따로 가져오면 N+1이 된다.
이때 `select_related('user')`를 쓰면 **JOIN으로 한 번에** 가져온다.

* 대상: ForeignKey, OneToOne
* 방식: DB JOIN 기반으로 한 번에 가져옴 

정리하면 “작성자 같이 FK로 딸려오는 데이터는 select_related가 정답”이다.

---

## 9) prefetch_related: ManyToMany/역참조에 최적이다

댓글 목록처럼 `article.comment_set.all()`은 “역참조(Reverse FK)”다.
이건 select_related로는 해결이 안 되고, `prefetch_related('comment_set')`처럼 **미리 한 번 더 쿼리로 당겨서 파이썬에서 매칭**하는 방식이 필요하다.

* 대상: ManyToMany, 역참조(Reverse FK)
* 방식: (1) 본 테이블 조회 (2) 관련 테이블을 한 번 더 조회 (3) 파이썬에서 관계를 연결 

정리하면 “댓글/좋아요/팔로우처럼 여러 개가 붙는 관계는 prefetch_related가 정답”이다.

---

## 10) select_related + prefetch_related는 같이 쓴다

실전 페이지는 대개 “FK도 쓰고, 역참조도 쓰는” 복합 구조다.

* 게시글 N개
* 각 게시글의 작성자(FK)
* 각 게시글의 댓글 목록(역참조)

이런 화면은 다음 조합이 자연스럽다.

* `select_related('user')`로 작성자 JOIN
* `prefetch_related('comment_set')`로 댓글을 미리 가져오기 

---

## 11) 오늘 정리

팔로우는 “유저-유저 자기참조 M2M”이며 `symmetrical=False`로 방향성을 만들고, 팔로우/언팔로우는 add/remove 토글로 처리한다. fixtures로 테스트 데이터를 안정적으로 주입하고, 화면에서 관계 데이터를 많이 보여줄수록 N+1이 터지므로 annotate로 집계를 붙이고, FK는 select_related, 역참조/M2M은 prefetch_related로 최적화해야 한다. 


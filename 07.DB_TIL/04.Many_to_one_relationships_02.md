# Django 모델 관계 개념서 · TIL: Many-to-One 02 (Article/User, Comment/User, 권한, Decorator, ERD)

“다대일 관계를 실제 게시판 기능에 붙일 때” 겪는 흐름
**(1) Article–User 연결**, **(2) Comment–User 연결**, **(3) 작성자만 수정/삭제 가능하게 권한 처리**, **(4) 요청 메서드 제한 데코레이터**, **(5) ERD로 구조 이해**다.

---

## 1) Article–User 다대일 관계: “게시글은 작성자 1명, 사용자는 글 여러 개”

게시글과 유저의 관계는 **Article(N) : User(1)** 이다. 즉 한 명의 유저는 글을 여러 개 쓸 수 있고, 글 하나는 작성자 한 명을 가진다. 그래서 **Article 모델에 ForeignKey(User)가 들어간다**.

자료는 다음 형태로 관계를 설정한다.

```py
# articles/models.py
from django.conf import settings

class Article(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(...)
    content = models.TextField(...)
```

### 1-1) User 모델 참조 2가지: settings.AUTH_USER_MODEL vs get_user_model()

자료는 “유저 모델을 참조하는 방법이 2개”라는 점을 분명히 잡아준다.

* **settings.AUTH_USER_MODEL**

  * 모델 필드(특히 ForeignKey)처럼 “모델 정의 시점”에 자주 쓴다.
* **get_user_model()**

  * 코드 실행 시점(뷰/폼 등)에서 실제 User 클래스를 가져올 때 자주 쓴다.

이걸 한 줄로 정리하면 **“모델 필드는 AUTH_USER_MODEL, 런타임에서 클래스는 get_user_model”** 이다.

---

## 2) 마이그레이션에서 자주 터지는 에러: “기존 데이터가 있는데 NOT NULL FK를 추가함”

자료 2p가 아주 현실적인 상황을 보여준다. 이미 Article 테이블에 데이터가 있는 상태에서 `user` 필드를 **NOT NULL**로 추가하면, 기존 행들의 user 값을 채울 수 없어서 Django가 “기본값을 지정하라”는 선택지를 띄운다.

여기서 감각은 이거다.

* 기존 데이터가 존재함
* 새로운 FK 필드는 NOT NULL
* 그래서 DB는 “기존 레코드의 user를 뭐로 채우지?”를 결정해야 함
* Django가 1회성 default를 넣거나, 모델에서 default/null 정책을 잡으라고 요구함

즉, “운영 중(데이터 있음) 테이블에 NOT NULL FK 추가”는 항상 마이그레이션 전략이 필요하다.

---

## 3) 게시글 CREATE: 폼에서 user를 받지 말고 서버에서 채운다

자료의 흐름은 “ArticleForm에서는 user 필드를 제외하고, 저장 직전에 request.user로 채운다”는 방식이다. (3p~4p)

### 3-1) 왜 폼에서 user를 빼야 하나

user를 폼에 포함하면 사용자가 조작해서 “남의 이름으로 글 쓰기”가 가능해진다. 그래서 **작성자는 항상 로그인한 사용자(request.user)로 서버가 고정**해야 한다.

### 3-2) IntegrityError의 정체

`NOT NULL constraint failed: articles_article.user_id` 같은 에러
이 에러는 의미가 딱 하나다.

* “Article 레코드를 저장하려는데 user_id가 비어있다”
* 즉, **article.user를 채우지 않고 save()를 호출했다**는 뜻이다.

### 3-3) 해결 패턴: save(commit=False) → user 채우기 → save()

표준 패턴이다.

```py
form = ArticleForm(request.POST)
if form.is_valid():
    article = form.save(commit=False)   # 아직 DB 저장 X
    article.user = request.user         # 작성자 주입
    article.save()                      # 이제 저장
```

여기서 `commit=False`는 “DB 저장을 잠깐 멈추고 객체만 만들어라”는 뜻이고, 그 사이에 FK 같은 **폼에 없는 필수 값**을 채우는 용도로 쓴다.

---

## 4) 게시글 READ: 템플릿에서 작성자를 보여주는 방법

READ 파트에서는 게시글 상세에서 작성자 출력이 등장한다. 템플릿에서 `article.user`를 출력하는 식으로 작성자에 접근한다. (4p~5p)

핵심은 **ForeignKey가 연결되면 article.user로 바로 User 객체에 접근**된다는 점이다.

---

## 5) 게시글 UPDATE/DELETE 권한: “작성자만 가능”

자료의 핵심 실전 포인트 중 하나다. 수정/삭제는 “로그인 여부”만으로 끝나면 안 되고, **작성자인지 확인**해야 한다. 그래서 뷰에서 `request.user == article.user` 비교로 권한을 제한한다. 

* UPDATE에서는 “작성자 아니면 수정 폼/요청을 막는다” 흐름이 나온다.
* DELETE도 똑같이 “작성자일 때만 delete 실행”으로 구현한다.

이 비교 한 줄이 실무에서 권한의 1차 방어선이다.

---

## 6) Comment–User 다대일 관계: “댓글도 작성자 1명”

이제 댓글에도 똑같이 작성자(유저)를 붙인다. 
 Comment 모델에 `user = ForeignKey(User)`를 추가하는 걸 보여준다.

즉 댓글은 두 개의 FK를 가진 구조가 된다.

* `comment.article` : 어떤 글에 달린 댓글인가
* `comment.user` : 누가 쓴 댓글인가

---

## 7) 댓글 CREATE: article + user를 둘 다 서버에서 채워야 한다

댓글 생성에서도 똑같이 `NOT NULL constraint failed: articles_comment.user_id` 같은 에러가 나는 장면을 보여준다.

이것도 원리는 동일하다.

* 댓글 저장하려는데 user_id가 비어 있음
* 즉 **comment.user를 채우지 않고 save()를 했다**는 뜻이다

해결은 항상 같은 패턴이다.

```py
comment = form.save(commit=False)
comment.article = article
comment.user = request.user
comment.save()
```

---

## 8) 댓글 READ/DELETE: 템플릿에서 “댓글 작성자 표시 + 작성자만 삭제 버튼”

댓글 목록을 보여줄 때 `comment.user`를 같이 출력하고, 삭제 버튼은 조건부로 노출하는 형태를 보여준다.

그리고 DELETE 뷰에서도 똑같이 작성자 비교를 한다. (9p에도 이어짐)

즉 “UI에서 버튼 숨기기”는 편의고, **실제 보안은 뷰에서 작성자 확인으로 막는 것**이 핵심이다.

---

## 9) View decorator: 요청을 ‘검문’하는 코드 재사용 장치

view decorator를 “특정 조건을 만족해야만 view를 실행하게 만드는 장치”로 설명한다. 로그인_required처럼 반복되는 검사를 함수 바깥에서 공통 처리할 수 있다.

---

## 10) Allowed HTTP methods: GET/POST를 강제로 제한하는 이유

“허용된 HTTP method만 받도록 제한하는 데코레이터”를 다룬다.

핵심 이유는 다음이다.

* 어떤 URL은 조회만 허용해야 한다(GET)
* 어떤 URL은 생성/삭제 같은 변경만 허용해야 한다(POST)
* 제한을 안 하면 잘못된 요청이 들어와도 view가 돌아가서 로직이 꼬이거나 보안적으로 위험해질 수 있다

자료에 등장하는 대표 데코레이터는 다음이다.

* `@require_http_methods(['GET', 'POST'])`
* `@require_safe()` (GET/HEAD만)
* `@require_POST()` (POST만)

그리고 허용되지 않은 method면 **405 Method Not Allowed**로 막는다.

---

## 11) ERD: 코드로 만든 관계를 “그림으로 검증”하는 습관

ERD를 “DB 구조를 시각화한 설계도”로 설명한다.

### 11-1) ERD 구성요소 3개

* **Entity**: 테이블(예: User, Article, Comment)
* **Attribute**: 컬럼(필드)
* **Relationship**: 관계선(1:N 등)

### 11-2) Cardinality(카디널리티): “하나인가, 여러 개인가”를 표기하는 규칙

1:1, 1:N, M:N 같은 관계 표기를 정리하고, 까마귀발(Crow’s foot)로 “많음”을 표현하는 방식도 보여준다.

이걸 Django 코드에 대응시키면,

* `ForeignKey`가 있으면 거의 항상 **1:N**이 만들어진다.
* FK가 있는 쪽이 N, 참조 당하는 쪽이 1이다.

---

## 12) 시험/과제에서 바로 써먹는 “실수 방지 체크리스트”

자료 전체를 관통하는 사고 포인트를 실전 체크리스트로 정리하면 이렇다.

1. **모델에 FK 추가하면 마이그레이션에서 기존 데이터 처리 문제가 생길 수 있다**
2. CREATE에서 `IntegrityError: ... user_id`가 뜨면 “user를 안 넣었다”로 바로 해석한다
3. user 필드는 폼에서 받지 않고 **request.user로 서버에서 주입**한다
4. 저장 패턴은 `save(commit=False)` → FK 채우기 → `save()`다
5. UPDATE/DELETE는 로그인만으로 끝내지 말고 **작성자 비교(request.user == article.user / comment.user)** 로 막는다
6. DELETE/CREATE 같은 변경 작업은 `@require_POST()`로 막아두는 게 안전하다

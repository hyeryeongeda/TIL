# Django Many-to-Many(다대다) 관계 개념서 · TIL (Many_To_Many_Relationships01)

**“N:1로는 표현이 막히는 관계”를 M:N으로 풀어내는 과정**을 이해하는 데 목적이 있다. 다대다의 핵심은 **중개 테이블(중개 모델)** 이며, Django에서는 이를 직접 만들 수도 있고 `ManyToManyField`로 자동 생성시킬 수도 있다. 

---

## 1) 다대다(M:N) 관계가 필요한 순간을 먼저 이해해야 한다

다대다 관계는 **A 여러 개가 B 여러 개와 연결될 수 있는 구조**다. 한쪽이 “여러 개”이고 다른 쪽도 “여러 개”라서 N:1(다대일)만으로는 깔끔하게 표현이 안 된다.

### 1-1) N:1의 한계가 생기는 대표 상황이다

예를 들어 “의사–환자” 관계를 생각하면 다음이 자연스럽다.

* 의사 1명은 환자 여러 명을 진료할 수 있다(의사 → 환자: 1:N 같아 보인다)
* 동시에 환자 1명도 의사 여러 명에게 진료받을 수 있다(환자 → 의사: 1:N 같아 보인다)

즉 양쪽 방향이 모두 “여러 개”가 된다. 이런 구조는 **결국 M:N** 이다. 

---

## 2) 다대다의 진짜 정답은 “중개 테이블”이다

다대다는 DB에서 **중개 테이블(association table)** 로 구현한다.
의사 테이블과 환자 테이블 사이에 “예약/진료/관계”를 저장하는 테이블을 하나 더 두는 방식이다. 

### 2-1) 왜 중개 테이블이 필요한가

N:1 방식으로 억지로 만들면 보통 이런 문제가 생긴다.

* 환자 테이블에 `doctor_id`를 두면 “환자 1명당 의사 1명만” 저장 가능해진다
* 의사 여러 명을 저장하려면 `doctor_id1, doctor_id2...` 같은 이상한 컬럼을 늘려야 한다
* 또는 문자열로 “1,2,3” 같은 식으로 저장하는 순간 관계형 DB의 장점이 무너진다

그래서 **“의사–환자 연결 자체를 행(row)으로 저장”** 해야 한다.
이 역할이 중개 테이블이다. 

---

## 3) 방법 1: 중개 모델을 직접 만드는 방식이다

Django에서 중개 모델을 직접 만들면 구조가 명확해진다.

* Doctor
* Patient
* Reservation(또는 Appointment): doctor FK + patient FK

이렇게 만들면 “누가 누구와 연결되었는지”가 Reservation 테이블의 한 행으로 표현된다. 

### 3-1) 중개 모델의 강력한 장점이다

중개 모델을 직접 만들면 연결 정보에 **추가 데이터**를 붙일 수 있다.

* 예약 시간
* 증상(symptom)
* 진료 상태
* 메모

즉 “의사와 환자가 연결되었다”라는 사실뿐 아니라, **그 연결의 맥락**을 저장할 수 있다. 

---

## 4) 방법 2: ManyToManyField로 “중개 테이블을 자동 생성”시키는 방식이다

Django의 `ManyToManyField`는 M:N 관계를 선언하면 **Django가 자동으로 중개 테이블을 만들어주는 기능**이다. 

### 4-1) ManyToManyField를 쓰면 어떤 일이 생기나

예를 들어 `Patient.doctors = models.ManyToManyField(Doctor)` 같은 식으로 선언하면,

* Patient와 Doctor 사이에
* 자동으로 “patient_doctor” 같은 중개 테이블이 만들어진다
* 개발자는 연결/해제를 API로 다룰 수 있게 된다 

### 4-2) 연결/해제는 add/remove로 다룬다

ManyToManyField에는 대표적으로 아래 조작이 등장한다.

* `add()` : 관계(연결) 추가
* `remove()` : 관계(연결) 제거 

즉, “중개 테이블에 행을 추가/삭제”하는 작업을 Django가 감싸서 제공한다고 이해하면 된다.

---

## 5) 그런데 “추가 데이터”가 필요하면 어떻게 하나

ManyToManyField를 자동 생성으로만 쓰면, 중개 테이블은 “연결 정보”만 저장한다.
하지만 예약 시간, 증상 같은 추가 컬럼이 필요해질 수 있다.

이럴 때 쓰는 것이 **through 속성**이다. 

### 5-1) through의 의미다

* “M:N 관계는 ManyToManyField로 선언하되”
* “중개 테이블은 자동 생성 말고 내가 만든 중개 모델(Reservation)을 써라”
  라는 뜻이다. 

즉,

* 중개 모델을 직접 만들고(Reservation)
* `ManyToManyField(..., through='Reservation')`로 연결하면
* M:N 조작은 편하게 하면서도(관계 API)
* 중개 테이블에 추가 데이터도 저장 가능해진다 

---

## 6) related_name은 “역참조 이름을 사람이 읽기 좋게 바꾸는 장치”다

ManyToMany도 역참조 매니저가 생긴다.
기본 이름이 마음에 안 들면 `related_name`으로 바꾼다. 

예를 들어 “의사가 가진 환자 목록”을 `doctor.patient_set` 같은 기본 이름 대신 `doctor.patients`처럼 읽기 좋게 만들 수 있다.
실제로 좋아요 기능(Article ↔ User)에서 역참조 이름을 명확하게 만드는 흐름이 나온다. 

---

## 7) symmetrical은 “자기 자신과의 M:N”에서 중요해진다

친구 관계처럼 **User ↔ User**(자기참조 M:N)에서는 “A가 B의 친구면 B도 A의 친구인가”가 애매해진다.
이때 `symmetrical=True/False`로 관계의 대칭 여부를 조절한다. 

* 대칭이면: 한쪽에서 추가하면 반대쪽도 자동으로 연결된 것처럼 동작한다
* 비대칭이면: 팔로우처럼 “내가 너를 팔로우해도 너는 나를 팔로우한 게 아니다” 같은 모델링이 가능해진다 

---

## 8) 실전 예시: “좋아요(Like)” 기능은 다대다의 정석이다

좋아요는 대표적인 M:N이다.

* 유저는 게시글을 여러 개 좋아요할 수 있다
* 게시글은 유저 여러 명에게 좋아요를 받을 수 있다

그래서 **Article(M) : User(N)** 관계로 ManyToMany를 건다. 

### 8-1) 구현 감각이다

* Article 모델에 `like_users = models.ManyToManyField(User, related_name='like_articles')` 같은 형태로 둔다
* 그러면

  * `article.like_users.all()` : 이 글을 좋아요한 유저들
  * `user.like_articles.all()` : 이 유저가 좋아요한 글들
    같은 조회가 가능해진다 

### 8-2) 토글(toggle) 로직이 자주 나온다

좋아요 버튼은 보통 “이미 눌렀으면 취소, 안 눌렀으면 추가”다.

* 이미 좋아요한 상태면 `remove(request.user)`
* 아니면 `add(request.user)`

이 패턴이 좋아요 기능 구현 파트에서 그대로 등장한다.

---

## 9) 오늘 내용에서 실수 방지 포인트만 뽑아 정리한다

1. M:N은 결국 **중개 테이블이 본체**다.
2. `ManyToManyField`는 **중개 테이블을 자동 생성**해준다. 
3. 관계 추가/해제는 DB 관점에서 “중개 테이블의 행 추가/삭제”이며, Django에서는 `add/remove`로 한다. 
4. 연결에 “추가 정보(예약시간/증상)”가 필요하면 `through`로 **직접 만든 중개 모델**을 써야 한다.
5. 역참조 이름이 헷갈리면 `related_name`으로 바꿔서 읽기 좋게 만든다.

---

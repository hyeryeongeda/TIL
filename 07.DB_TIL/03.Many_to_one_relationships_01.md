# Django 모델 관계 개념서 · TIL: Many-to-One(다대일) 관계 완전 정복

## 1) “관계”를 왜 쓰는지부터 잡아야 한다

관계형 데이터베이스에서 **관계(relationship)** 는 “데이터끼리 의미 있게 연결하는 규칙”이다. 한 테이블에 모든 정보를 때려 넣으면 중복이 폭발하고, 수정할 때도 여기저기 다 바꿔야 해서 관리가 망가진다. 그래서 데이터를 여러 테이블로 나누고, **키로 연결**해서 쓰는 방식이 기본이 된다.

---

## 2) Many-to-One(다대일)은 어떤 상황인가

다대일은 말 그대로 **여러 개(N)가 하나(1)에 속하는 구조**다.
대표 예시로 “댓글 여러 개가 게시글 하나에 달린다” 같은 구조가 있다. 문서도 이 예시를 중심으로 설명한다.

* Comment(N) : Article(1) 구조다. 즉 댓글은 여러 개가 존재할 수 있지만, 댓글 하나는 특정 게시글 하나에만 속한다는 의미다.

이 관계가 성립하려면 DB에서 **외래키(Foreign Key)** 가 필요하다. 외래키는 “N쪽(댓글)이 1쪽(게시글)을 가리키는 열”이라고 이해하면 된다.

---

## 3) Django에서 다대일은 ForeignKey로 만든다

Django 모델에서 다대일 관계는 `ForeignKey(to, on_delete)`로 만든다. 문서도 댓글 모델을 정의하면서 이 문법을 핵심으로 잡는다.

### 3-1) 왜 댓글(Comment) 모델에 ForeignKey가 들어가나

다대일에서 **N 쪽이 FK를 가진다**는 규칙이 있다.
댓글이 여러 개고 게시글이 하나이므로, 댓글 테이블이 “내가 어느 게시글 소속인지”를 들고 있어야 한다. 그래서 댓글 모델에 `article = models.ForeignKey(Article, ...)`가 들어간다.

---

## 4) ForeignKey의 `on_delete`는 “부모가 삭제될 때 자식이 어떻게 되나”를 정하는 옵션이다

`on_delete`는 굉장히 중요하다. **게시글(1)이 삭제되면 댓글(N)은 어떻게 할 것인가**를 정책으로 정하는 부분이기 때문이다. 문서에서는 `CASCADE`, `PROTECT`, `SET_NULL`, `SET_DEFAULT` 같은 옵션을 정리한다.

* **CASCADE**: 부모(게시글)가 삭제되면 자식(댓글)도 같이 삭제된다. 실습에서 가장 흔하게 쓰는 방식이다.
* **PROTECT**: 자식이 남아 있으면 부모 삭제를 막는다. “댓글이 달린 글은 삭제 못 하게” 같은 정책에서 쓴다.
* **SET_NULL**: 부모가 삭제되면 자식의 FK를 NULL로 바꾼다. 단, FK 필드가 `null=True`여야 한다.
* **SET_DEFAULT**: 부모가 삭제되면 지정된 기본값으로 바꾼다.

실습/과제에서 “게시글 삭제하면 댓글도 같이 삭제”가 자연스러우면 `CASCADE`를 쓴다고 이해하면 된다.

---

## 5) 댓글 생성이 왜 자꾸 실패하는지(핵심 원인)

다대일 댓글 생성에서 가장 많이 터지는 에러는 **FK를 안 넣어서** 생긴다.
댓글은 반드시 어떤 게시글에 속해야 하므로, 댓글을 만들 때 `article` 정보를 같이 줘야 한다. 문서도 댓글 생성 연습에서 이 흐름을 단계별로 보여준다.

### 5-1) Django shell에서 “먼저 게시글을 가져온 뒤” 댓글을 만든다

문서 흐름은 다음과 같은 감각이다.

1. 게시글 한 개를 먼저 조회한다
2. 그 게시글을 FK로 넣어서 댓글을 생성한다

이 순서를 머릿속에 고정하면 된다. “댓글은 단독으로 떠다니는 데이터가 아니라 게시글 소속 데이터”이기 때문이다.

---

## 6) 참조와 역참조가 Many-to-One의 실전 포인트다

다대일에서는 데이터 접근이 두 방향으로 가능하다.

* **참조(Forward Reference)**: 댓글에서 게시글로 간다. (댓글 → 게시글)
* **역참조(Reverse Reference)**: 게시글에서 댓글 목록으로 간다. (게시글 → 댓글들)

문서도 “관계모델 참조 / 역참조”를 따로 구분해서 설명한다. 

### 6-1) 참조는 “FK 필드명으로 접근”한다

댓글 객체가 있으면 `comment.article`처럼 접근해서 “이 댓글이 속한 게시글”을 꺼내는 방식이 참조다. (문서가 말하는 QuerySet API 기반 흐름이 이 방향이다.) 

### 6-2) 역참조는 “related manager”가 핵심이다

게시글 객체가 있으면 그 게시글에 달린 댓글들을 **한 번에** 가져오고 싶다. 이때 Django는 자동으로 역참조 매니저를 만들어 준다. 문서에서는 기본 형태를 `article.comment_set.all()`로 강조한다. 

즉, 이 한 줄을 이렇게 이해하면 된다.

* `article`은 게시글 1개다
* `comment_set`은 “이 게시글을 FK로 참조하는 댓글들의 묶음(매니저)”이다
* `all()`은 그 묶음을 실제 QuerySet으로 꺼내는 동작이다 

---

## 7) related_name을 설정하면 역참조 이름을 내 스타일로 바꿀 수 있다

기본 역참조는 `comment_set`인데, 이 이름이 직관적이지 않다고 느낄 수 있다. 그래서 `ForeignKey`에 `related_name`을 주면 역참조 이름이 바뀐다. 문서 문제에서도 related_name 관련 문항이 등장한다. 

예를 들어 `related_name='comments'`로 설정하면,

* 기본: `article.comment_set.all()`
* 변경: `article.comments.all()`

처럼 더 읽기 쉬운 코드가 된다.

---

## 8) 댓글 기능 구현 흐름은 “Form + View + URL + Template”로 묶어서 이해해야 한다

문서 후반은 댓글 CRUD 중에서도 **CREATE / READ / DELETE** 흐름을 실제 Django 코드 조각으로 보여준다. 

### 8-1) CREATE의 핵심은 save(commit=False)다

댓글은 사용자 입력으로 `content`만 받는 경우가 많다. 하지만 FK인 `article`은 폼 입력으로 받지 않고, URL로 들어온 `article_pk`로 서버에서 세팅하는 게 일반적이다.

그래서 다음 흐름이 나온다.

1. `form.save(commit=False)`로 **아직 DB에 저장하지 않은 댓글 객체**를 만든다
2. `comment.article = article`로 FK를 채운다
3. `comment.save()`로 최종 저장한다 

문서에 `save(commit=False)`를 별도 강조하는 이유가 바로 “FK를 서버에서 채우기 위해서”다. 

### 8-2) READ는 “게시글 상세 페이지에서 댓글 목록을 같이 내려주는 방식”이다

상세 페이지에서 게시글 정보와 함께 `article.comment_set.all()`(또는 related_name을 썼다면 `article.comments.all()`)로 댓글 목록을 내려서 템플릿에서 렌더링하는 방식이 나온다. 

### 8-3) DELETE는 “댓글 pk를 받아서 지운 뒤 다시 상세로 리다이렉트”다

삭제는 보통 `comment_pk`를 URL로 받고, 댓글을 찾아 지운 뒤, 다시 원래 게시글 상세로 돌아가게 만든다. 문서도 댓글 DELETE 구현을 이 구조로 제시한다. 

---

## 9) 오늘 내용에서 제일 중요한 실수 방지 포인트 5개다

1. 다대일에서는 **N쪽 모델(댓글)에 ForeignKey가 들어간다**는 규칙을 고정해야 한다.
2. 댓글 생성이 실패하면 대부분 **FK(article)를 안 채운 것**부터 의심해야 한다.
3. `on_delete`는 “부모 삭제 시 자식 처리 정책”이라서 의미를 이해하고 선택해야 한다.
4. 역참조는 기본이 `comment_set`이고, `related_name`으로 더 읽기 좋게 바꿀 수 있다.
5. 폼에 없는 FK를 채우려면 `save(commit=False)` 패턴이 사실상 표준이다.

---

## 10)

Many-to-One은 “댓글 같은 N 데이터가 게시글 같은 1 데이터에 소속되는 구조”이고, Django에서는 **N쪽 모델에 ForeignKey를 두고**, 조회는 **참조(comment.article)** 와 **역참조(article.comment_set.all())** 로 양방향 접근을 한다고 이해하면 된다.

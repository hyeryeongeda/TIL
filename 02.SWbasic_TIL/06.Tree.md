
## 1) 트리(Tree)가 필요한 이유: “계층 구조”를 자연스럽게 표현하려고

트리는 **부모-자식 관계**로 데이터가 연결된 구조다.
리스트/배열이 “일렬(선형)”이라면, 트리는 “가지가 뻗는 구조(비선형)”다. 

현실에서 계층 구조가 필요한 예는 많다.

* 폴더 구조(루트 폴더 아래 하위 폴더/파일)
* 조직도(팀장-팀원)
* 웹 페이지의 HTML DOM(태그가 안에 태그를 포함)
* 게임/AI에서의 의사결정 구조, 추천/분류 모델의 트리 구조

즉 “상위 개념 아래에 하위 개념이 여러 개 달릴 수 있는 구조”를 가장 깔끔하게 표현하는 방법이 트리다.

---

## 2) 트리의 기본 용어: 그림만 보면 알 듯하지만, 문제 풀 때는 정의가 정확해야 한다

트리 문제는 용어를 헷갈리면 바로 꼬인다. 슬라이드가 강조하는 핵심 용어들을 “문제 풀이 기준”으로 정리하면 이렇다. 

### 노드(node)

트리를 구성하는 각 “점”이다. 값(데이터)을 가진다.

### 간선(edge)

노드와 노드를 잇는 “선”이다. 부모-자식 관계를 나타낸다.

### 루트(root)

트리의 최상위 노드. 부모가 없다. (시작점) 

### 부모/자식(parent/child)

연결된 두 노드에서 위가 부모, 아래가 자식이다.

### 형제(sibling)

같은 부모를 가진 자식 노드들.

### 조상/자손(ancestor/descendant)

부모를 타고 위로 올라가며 만나는 노드들 = 조상
아래로 내려가며 만나는 노드들 = 자손

### 서브트리(subtree)

어떤 노드를 루트로 하는 “작은 트리 덩어리”.
트리는 결국 “서브트리들의 재귀적 결합”이라는 관점으로 이해하면 훨씬 강해진다. 

### 레벨(level), 높이(height)

* 레벨: 루트가 0(또는 1)부터 시작해 아래로 갈수록 1씩 증가하는 층
* 높이: 트리의 가장 깊은 레벨(또는 루트~가장 깊은 노드까지의 길이) 

문제에서 “트리의 높이”, “노드의 깊이”, “레벨”이 섞여 나오니, **루트를 기준으로 얼마나 내려갔는지**라는 감각을 잡아두면 된다.

---

## 3) 이진트리(Binary Tree): “자식이 최대 2개”인 트리

이진트리는 각 노드가 가질 수 있는 자식이 **최대 2개**인 트리다(왼쪽/오른쪽). 

여기서 중요한 포인트는 “0개/1개/2개 모두 가능”이라는 것.
즉, 꼭 2개를 다 채울 필요는 없다.

---

## 4) 이진트리의 주요 종류(자주 출제 포인트)

### (1) 포화 이진 트리(Full Binary Tree)

모든 레벨이 꽉 차 있고, 마지막 레벨까지 노드가 가득한 형태다.
이때 노드 수는 레벨에 따라 규칙적으로 증가하며, 트리 성질(최대 노드 수)과 연결된다. 

### (2) 완전 이진 트리(Complete Binary Tree)

마지막 레벨을 제외한 레벨은 다 차 있고,
마지막 레벨은 **왼쪽부터** 순서대로 채워진 형태다. 

완전 이진 트리는 특히 중요한데, 이유는 아래 “배열 표현”이 매우 깔끔해지기 때문이다(힙이 이 구조를 쓴다). 

### (3) 편향 이진 트리(Skewed Binary Tree)

한쪽(왼쪽 또는 오른쪽)으로만 계속 자식이 달리는 형태다.
이 경우 트리는 사실상 “연결 리스트처럼” 길어져서 탐색 효율이 나빠질 수 있다. 

---

## 5) 트리 순회(Traversal): “모든 노드를 어떤 순서로 방문할까?”

순회는 트리의 모든 노드를 한 번씩 방문하는 방법이다.
트리는 선형 구조가 아니라서 “방문 순서”를 규칙으로 정해줘야 한다. 

이진트리의 기본 순회 3종은 항상 아래 3개로 세트처럼 나온다. 슬라이드도 V(방문), L(왼쪽), R(오른쪽)로 정리한다. 

### (1) 전위 순회(preorder): V - L - R

* “현재 노드 먼저 방문하고”
* 왼쪽 서브트리 방문
* 오른쪽 서브트리 방문 

**언제 쓰나?**

* 트리를 “복사”할 때(루트부터 구조를 잡아나감)
* 디렉터리 구조를 출력할 때(부모를 먼저 출력하고 자식 출력)

### (2) 중위 순회(inorder): L - V - R

* 왼쪽 서브트리
* 현재 노드
* 오른쪽 서브트리

**언제 쓰나?**

* 이진탐색트리(BST)에서는 중위 순회 결과가 **오름차순**이 된다(아주 중요)

### (3) 후위 순회(postorder): L - R - V

* 왼쪽 서브트리
* 오른쪽 서브트리
* 현재 노드

**언제 쓰나?**

* “자식 작업을 먼저 끝내고 부모를 처리”해야 할 때
  예: 디렉터리 삭제(하위 파일/폴더부터 지우고 상위 폴더 삭제), 수식 트리 계산(피연산자부터 계산 후 연산자 적용)

---

## 6) 이진트리 표현 방법 1: 배열(인덱스)로 표현하기

슬라이드에는 “완전 이진 트리”에서 특히 배열 표현이 자연스럽다는 내용이 나온다.

### (1) 인덱스 규칙(거의 공식처럼 씀)

보통 루트를 1번 인덱스로 둘 때:

* i번 노드의 왼쪽 자식: `2*i`
* i번 노드의 오른쪽 자식: `2*i + 1`
* i번 노드의 부모: `i//2`

이 규칙이 “완전 이진 트리”에서 특히 깔끔하게 동작한다.

### (2) 배열 표현의 장단점

* 장점:

  * 부모/자식 접근이 O(1)로 매우 쉽다(인덱스 계산)
* 단점:

  * 편향 트리처럼 비어 있는 칸이 많으면 공간 낭비가 커진다

---

## 7) 이진트리 표현 방법 2: 연결(노드 구조체/객체)로 표현하기

연결 표현은 각 노드가 `left`, `right` 포인터(참조)를 들고 있는 방식이다.

* 장점: 트리 모양이 어떻든 공간 낭비가 적고 유연하다.
* 단점: 배열처럼 인덱스 계산으로 바로 접근하는 게 아니라 포인터를 따라가야 한다.

슬라이드의 노드 표현(왼쪽 링크/데이터/오른쪽 링크 구조)은 “트리 노드를 객체로 만든다”는 개념을 시각화한 것이다.

---

## 8) 이진탐색트리(BST): “정렬된 트리”로 탐색을 빠르게

BST는 이진트리에 “정렬 규칙”을 추가한 자료구조다.

### BST 규칙(이거 하나로 끝)

어떤 노드의 값이 `key`라면:

* 왼쪽 서브트리의 모든 값 < key
* 오른쪽 서브트리의 모든 값 > key

그래서 탐색할 때는 매번:

* 찾는 값이 key보다 작으면 왼쪽
* 크면 오른쪽
  이렇게 내려가면 된다.

### 시간 복잡도 감각

BST의 탐색/삽입/삭제는 트리 높이에 비례한다.

* 트리가 균형 잡혀 있으면 높이가 대략 log n → **O(log n)**
* 편향되면 높이가 n → **O(n)** (거의 리스트처럼 됨)

즉 BST는 “균형”이 핵심이고, 균형이 무너지면 성능이 급격히 나빠진다.

### BST 삽입(insertion) 직관

* 루트부터 시작해 비교하며 내려간다.
* 더 내려갈 수 없는(비어있는 자식 자리) 위치에 새 노드를 붙인다.

### BST 삭제(deletion)가 어려운 이유(핵심만)

삭제는 경우가 3개로 갈라진다.

1. 리프 노드 삭제: 그냥 제거
2. 자식 1개인 노드 삭제: 자식을 끌어올려 연결
3. 자식 2개인 노드 삭제:

   * “대체 노드”가 필요하다
   * 보통 오른쪽 서브트리에서 가장 작은 값(중위 후속자) 또는 왼쪽 서브트리에서 가장 큰 값(중위 선행자)을 가져와 교체한다

삭제가 복잡한 이유는 “BST 정렬 규칙을 깨지 않으면서” 노드를 제거해야 하기 때문이다.

---

## 9) 힙(Heap): 우선순위 큐를 위한 “완전 이진 트리 기반” 구조

슬라이드 뒤쪽은 힙을 소개한다. 힙은 **완전 이진 트리 형태를 유지하면서**, “부모가 자식보다 항상 크거나(최대 힙) 항상 작게(최소 힙)” 만드는 구조다.

### 최대 힙(Max Heap)

* 부모 ≥ 자식
* 루트가 전체 최댓값

### 최소 힙(Min Heap)

* 부모 ≤ 자식
* 루트가 전체 최솟값

여기서 매우 중요한 오해 하나를 잡아야 한다.

> 힙은 “정렬된 트리”가 아니다.
> 오직 “부모-자식 사이”에만 크기 규칙이 있을 뿐, 좌/우 서브트리 전체가 BST처럼 정렬되진 않는다.

그래서 힙은 “최댓값/최솟값을 빠르게 꺼내는 용도”에 최적화되어 있다.

---

## 10) 힙의 삽입/삭제가 빠른 이유: 완전 이진 트리 + 스왑(재정렬)

### 삽입(insert)

1. 완전 이진 트리 규칙에 따라 “마지막 위치”에 새 원소를 넣는다.
2. 부모와 비교해서 규칙을 어기면 위로 올리며 swap한다(위로 올라가는 과정).

이 “위로 올리기”를 흔히 sift-up / heapify-up이라고 생각하면 된다.

### 삭제(delete) = 보통 “루트 삭제”

힙에서 삭제는 주로 루트(최대/최소)를 꺼내는 것이다.

1. 루트 값을 꺼낸다.
2. 마지막 노드를 루트로 올린다.
3. 자식과 비교해서 규칙을 어기면 아래로 내리며 swap한다(아래로 내려가는 과정).

이 과정이 sift-down / heapify-down이다.

### 시간 복잡도

완전 이진 트리 높이가 log n이므로,

* 삽입: O(log n)
* 삭제: O(log n)

그래서 “우선순위 큐”를 구현할 때 힙이 표준으로 등장한다.

---

## 11) 트리 문제에서 자주 나오는 연결 포인트 3개

### (1) “순회”는 재귀로 매우 자연스럽다

전위/중위/후위 모두 “현재 노드에서 왼쪽/오른쪽 서브트리를 다시 순회한다” 구조라 재귀로 구현이 깔끔하다.

### (2) BST는 중위 순회가 정렬이다

BST에서 중위 순회를 하면 값이 오름차순이 되는 이유는
왼쪽(<현재) → 현재 → 오른쪽(>현재) 순서가 “정렬 정의”를 그대로 따르기 때문이다.

### (3) 힙은 “최댓값/최솟값 빠르게 꺼내기”에 특화

정렬이 목적이면 BST/정렬 알고리즘이 더 맞고,
“항상 가장 큰/작은 것만 빨리 필요”하면 힙이 맞다.

---

## 마무리

* 트리는 부모-자식 계층 구조를 표현하는 비선형 자료구조다.
* 이진트리는 자식이 최대 2개이며, 포화/완전/편향 형태를 구분할 줄 알아야 한다.
* 순회는 전위(VLR) / 중위(LVR) / 후위(LRV) 3가지가 기본이고, 의미(언제 쓰는지)까지 연결해야 한다.
* 배열 표현은 `left=2i, right=2i+1, parent=i//2`가 핵심이며 완전 이진 트리에서 특히 유리하다.
* BST는 왼<현재<오 규칙으로 탐색이 빠르지만, 편향되면 O(n)으로 무너질 수 있다.
* 힙은 완전 이진 트리를 유지하며 부모-자식 우선순위를 만족시켜 루트에서 최댓값/최솟값을 O(log n)에 다룬다.


## 1) 왜 스택으로 “계산기”를 만들 수 있는가

사칙연산이 섞인 수식은 사람이 읽을 때는 자연스럽지만, 컴퓨터 입장에서는 문제가 하나 있다.

* `6 + 5 * (2 - 8) / 2` 같은 식에서
  **곱셈/나눗셈이 덧셈/뺄셈보다 먼저** 계산되고,
  **괄호 안이 우선** 계산된다는 규칙(연산자 우선순위)이 있다.

즉, 왼쪽에서 오른쪽으로 그냥 읽으면 안 되고, “규칙을 적용하면서” 계산 순서를 정해야 한다.
이때 스택이 필요한 이유는 **“아직 확정하지 못한 연산자들을 잠깐 보관”**해야 하기 때문이다. 

---

## 2) 후위 표기법(Postfix)이 무엇이고 왜 좋은가

### 후위 표기법의 형태

* 중위 표기법(infix): `A + B * C` (연산자가 가운데)
* 후위 표기법(postfix): `A B C * +` (연산자가 뒤에)

후위 표기법의 장점은 딱 하나로 요약된다.

> **우선순위/괄호가 없어도, 왼쪽에서 오른쪽으로 읽으면서 바로 계산할 수 있다.**

즉, 컴퓨터가 좋아하는 “절차가 단순한 형태”로 바꿔주는 것이다. 

---

## 3) 중위 → 후위 변환(스택이 핵심인 이유)

변환 아이디어는 이렇다.

* 숫자(피연산자)는 “일단 출력(후위 결과에 바로 붙임)”
* 연산자는 “지금 출력하면 안 될 수도 있으니 스택에 보관”
* 연산자 스택에서 꺼내는 타이밍은 **우선순위**와 **괄호**가 결정한다 

### 규칙을 사람 말로 정리하면

#### 1) 피연산자(숫자/변수)를 만나면

* 후위 결과(output)에 바로 추가한다.

#### 2) 여는 괄호 `(` 를 만나면

* 무조건 스택에 넣는다.
* 이유: 괄호는 “이 구간이 끝날 때까지 밖으로 내보내면 안 되는 경계선” 역할이다.

#### 3) 닫는 괄호 `)` 를 만나면

* 스택에서 `(` 가 나올 때까지 연산자를 pop해서 output에 붙인다.
* 그리고 `(` 는 버린다(결과에 출력하지 않는다).

#### 4) 연산자 `+ - * /` 를 만나면

* **스택 top에 있는 연산자와 우선순위를 비교**해서,

  * 현재 연산자보다 **우선순위가 높거나 같은** 연산자가 스택 위에 있으면, 그걸 먼저 pop해서 output으로 보낸다.
  * 그 과정을 끝낸 후 현재 연산자를 스택에 push한다.
* 왜 “같은 우선순위도 pop”하나?
  보통 `+,-,*,/`는 **좌결합(왼쪽부터 계산)**이므로, 같은 우선순위라면 먼저 들어온 연산자가 먼저 계산되어야 한다.

#### 5) 입력을 끝까지 다 읽었으면

* 스택에 남은 연산자를 전부 pop해서 output 뒤에 붙인다.

이 규칙들 때문에 “연산자 스택”이 반드시 필요해진다. 

---

## 4) 우선순위 비교에서 자주 등장하는 ICP / ISP 감각

자료 그림에는 연산자 우선순위를 비교할 때 **스택 밖에서 들어오는 우선순위(icp)** 와 **스택 안에 이미 들어있는 우선순위(isp)** 를 따로 두는 방식이 나온다. 

이걸 쓰는 이유는 `(` 때문이다.

* `(` 는 스택에 들어오면 “웬만하면 위에서 pop되지 않게” 만들어야 한다.
* 하지만 `(` 가 들어올 때는 “무조건 push”되어야 한다.

그래서 보통 이런 철학으로 설계한다.

* 스택 **밖에서 들어올 때** `(` 는 우선순위가 매우 높게(그래서 push되게)
* 스택 **안에 있을 때** `(` 는 우선순위가 매우 낮게(그래서 다른 연산자들이 괄호 안에서만 돌다가, `)`에서만 pop되게)

즉, icp/isp는 “괄호를 자연스럽게 처리하기 위한 우선순위 트릭”이라고 이해하면 된다. 

---

## 5) 후위 표기법 계산(평가)은 더 단순하다

후위 표기식을 계산할 때는 연산자 스택이 아니라 **피연산자(값) 스택**을 쓴다. 

### 후위 계산 규칙(아주 중요)

* 토큰을 왼쪽→오른쪽으로 읽는다.
* 숫자를 만나면 스택에 push
* 연산자를 만나면 스택에서 값을 두 개 pop해서 계산한 뒤 결과를 다시 push

여기서 실수 포인트가 하나 있다.

> 연산자는 항상 “두 번째 pop”이 왼쪽 피연산자, “첫 번째 pop”이 오른쪽 피연산자다.

예를 들어 스택에서 `a`를 먼저 pop하고, 그 다음 `b`를 pop했다면
`b - a`, `b / a`처럼 순서를 지켜야 한다. 

---

## 6) 계산기 흐름을 한 번에 정리하면

스택 계산기는 결국 2단계다. 

1. **중위(infix) → 후위(postfix) 변환**: 연산자 스택 사용(우선순위/괄호 처리)
2. **후위(postfix) 평가**: 피연산자 스택 사용(연산자 만나면 2개 pop 후 계산)

이 2단계를 분리하면, “우선순위 처리”와 “계산”을 서로 깔끔하게 나눌 수 있어서 구현이 안정적이 된다.

---

## 7) 스택 응용: Backtracking(백트래킹)의 본질

자료는 스택 응용으로 **Backtracking**을 소개하고, DFS와의 차이를 “가지치기(pruning)”로 강조한다. 

### 백트래킹이란

가능한 선택지를 따라가며 해를 찾되,

* 어떤 선택을 했을 때 **더 이상 답이 될 가능성이 없으면**
* 그 지점에서 더 내려가지 않고
* 즉시 되돌아와(Backtrack) 다른 선택지를 시도하는 방식이다. 

### DFS와 뭐가 다른가

* DFS는 “끝까지 가보고 나중에 돌아오기”라서, 가능성이 없는 경로도 끝까지 가버릴 수 있다.
* 백트래킹은 “가망 없음이 확인되면 즉시 컷”한다.

그래서 같은 문제라도 방문하는 노드 수가 크게 줄 수 있고, 자료의 그림처럼 “순수 DFS는 많이 방문하지만, 백트래킹은 훨씬 적게 방문”하는 비교가 나온다. 

---

## 8) 미로 탐색에서 스택/백트래킹이 왜 자연스러운가

미로를 탐색할 때는 “현재 위치에서 갈 수 있는 방향”을 시도하다가 막히면 돌아와야 한다.

* 이동할 때마다 “내가 어디에서 왔는지”를 기억해야 한다.
* 막히면 “가장 최근의 갈림길”로 돌아가야 한다.

이 구조는 스택(또는 재귀 호출 스택)과 정확히 맞아떨어진다.
자료의 미로 예시는 push/pop으로 경로를 저장하고 되돌리는 과정을 그림으로 보여준다. 

---

## 9) 부분집합(Powerset): 백트래킹의 대표 무대

부분집합은 “원소를 **넣을지/말지**” 두 가지 선택이 원소 개수만큼 반복되는 문제다. 

### 핵심 사고 방식

각 원소마다 선택이 2개이므로 경우의 수는 (2^n)개다.
즉, 원래 완전탐색은 피할 수 없다.

하지만 여기서도 백트래킹이 의미가 있는 이유가 있다.
부분집합을 “그냥 다 출력”하는 게 아니라, 보통 문제는 조건이 붙는다.

예:

* 부분집합의 합이 특정 값이 되는 경우만 찾기
* 부분집합의 합이 제한을 넘으면 더 진행할 필요 없음

이때 **중간 단계에서 이미 조건을 위반하면 더 내려갈 필요가 없기 때문에 pruning**이 강력해진다. 

---

## 10) 순열(Permutation): “사용 여부 체크”가 핵심인 백트래킹

순열은 “서로 다른 n개 중에서 순서 있게 나열”이다.
여기서 중요한 건 “각 단계에서 아직 쓰지 않은 원소만 고르는 것”이다. 

그래서 순열 백트래킹은 보통 이런 구조를 가진다.

* 현재 깊이 k에서 하나를 선택해서 자리(k)에 놓는다.
* 선택할 때는 `used[i]` 같은 배열로 “이미 사용한 숫자인지” 체크한다.
* 사용했다면 후보에서 제외(이 자체가 pruning이다)

이 방식은 N-Queen 같은 문제로도 그대로 이어진다.

---

## 11) 가지치기(Pruning): “아직 완성도 안 됐는데 이미 망했으면 멈추기”

자료 후반에는 가지치기 예시가 나오며, 부분집합의 합 같은 문제에서 “현재까지의 합”으로 컷하는 논리가 등장한다. 

예를 들어 “부분집합의 합이 T를 넘으면 안 된다” 같은 조건이 있을 때,

* 현재까지 합 `S`가 이미 `T`를 넘었다면
* 뒤에 어떤 양수를 더 고르든 합은 더 커지므로
* 더 내려갈 의미가 없다 → 바로 return(가지치기)

이게 백트래킹이 단순 DFS보다 훨씬 빠를 수 있는 핵심 이유다.

---

## 12) 이 자료의 전체 연결 구조

* **연산자 우선순위를 처리하는 데 스택이 필요하고**, 그 결과가 후위 표기법 변환이다.
* 후위 표기법은 **피연산자 스택**으로 매우 단순하게 계산된다.
* “선택을 저장했다가 되돌리는” 문제들(미로, 부분집합, 순열)은 본질적으로 **스택/재귀 스택**을 사용하며,
* DFS에 **pruning(가능성 없는 경로 컷)**을 더하면 백트래킹이 된다. 

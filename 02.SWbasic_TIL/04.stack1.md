## 1) 스택(Stack)은 “마지막에 넣은 게 먼저 나온다”를 보장하는 구조다

스택은 **후입선출(LIFO: Last-In-First-Out)** 자료구조다. 즉, 가장 마지막에 쌓은 데이터가 가장 먼저 빠져나간다. 
현실 비유로는 “접시를 쌓아두는 구조”가 가장 직관적이다. 위에 올린 접시를 먼저 꺼내게 된다.

이 특성 때문에 스택은 “과거로 되돌아가야 하는 상황”에 강하다.

* 방금 한 작업을 취소(undo)할 때
* 탐색하다가 막히면 직전 분기점으로 돌아갈 때
* 괄호처럼 “최근에 열린 것”을 “가장 먼저 닫아야 하는” 규칙을 검사할 때

---

## 2) 스택을 다룰 때 반드시 나오는 기본 연산들

스택의 동작은 아래 연산들로 정리된다. 

* **push(x)**: x를 스택의 맨 위(top)에 넣는다.
* **pop()**: 스택의 맨 위(top) 값을 꺼내서(삭제하면서) 반환한다.
* **isEmpty()**: 비었는지 확인한다.
* **peek()/top()**: 맨 위 값을 “꺼내지 않고” 확인만 한다.

여기서 `peek()`는 실전에서 생각보다 많이 쓰인다.
“지금 상태를 보고 판단은 해야 하지만, 꺼내면 안 되는” 경우가 많기 때문이다(예: 괄호 검사에서 닫는 괄호를 봤을 때 top이 여는 괄호인지 확인). 

---

## 3) 스택의 핵심 포인트: top이 의미하는 것

스택은 “맨 위”가 어디인지 추적해야 한다. 보통 이 역할을 `top`이 한다. 

* `top`을 **마지막으로 저장된 원소의 위치(인덱스)** 로 두면,

  * push는 `top`을 1 증가시키고 그 자리에 저장
  * pop은 그 자리를 꺼낸 뒤 `top`을 1 감소

즉, **push/pop은 결국 top을 움직이는 일**이다.
이 감각이 잡히면 배열 스택이든 연결리스트 스택이든 똑같이 이해된다.

---

## 4) 스택 구현 방법 2가지: 파이썬 리스트 vs 배열(인덱스) 스택

자료에는 “리스트 append/pop” 방식과 “직접 top을 관리하는 방식”이 같이 나온다. 

### (1) 파이썬 리스트로 구현(가장 실전적)

* `append(x)`가 push
* `pop()`이 pop (맨 뒤 pop은 평균적으로 빠르게 동작)

```py
stack = []
stack.append(x)   # push
v = stack.pop()   # pop
```

파이썬 코테에서는 이 방식이 가장 흔하다.

### (2) 배열 + top 인덱스로 구현(원리 이해용/언어 공통)

고정 크기 배열을 만들고 `top`으로 상태를 관리한다. 

* **Overflow**: 꽉 찼는데 push하려는 경우
* **Underflow**: 비었는데 pop하려는 경우

이 두 에러 조건을 직접 처리해야 한다는 점이 핵심이다. 

---

## 5) 스택의 대표 응용: 괄호 검사(“가장 최근에 열린 괄호가 먼저 닫혀야 한다”)

괄호 검사는 스택이 왜 필요한지 가장 명확하게 보여주는 예시다. 

### 규칙을 말로 풀면

* 여는 괄호가 나오면 “나중에 닫아야 할 예약”이 하나 생긴다 → 스택에 저장한다.
* 닫는 괄호가 나오면 “가장 최근에 예약된 여는 괄호”와 짝이 맞아야 한다 → 스택 top과 비교한다.
* 끝까지 검사했는데 스택이 남아 있으면 “예약만 해놓고 안 닫은 괄호”가 있는 것 → 실패다.

### 알고리즘 흐름(실수 포인트 포함)

1. 문자열을 왼쪽부터 읽는다.
2. 여는 괄호면 push
3. 닫는 괄호면:

   * 스택이 비었으면 바로 실패(닫을 게 없음)
   * top이 짝이 맞는 여는 괄호인지 확인
   * 맞으면 pop, 아니면 실패
4. 문자열을 다 봤는데 스택이 비어 있으면 성공, 남아 있으면 실패 

이 문제에서 스택을 쓰는 이유는 “닫는 괄호는 항상 **가장 최근에 열린 괄호**를 닫아야 한다”는 규칙 때문이다. 이 규칙이 바로 LIFO다.

---

## 6) “함수 호출(Function Call)”도 사실 스택으로 관리된다

자료에는 함수가 호출될 때마다 **스택 프레임(stack frame)** 이 쌓이고, 함수가 끝나면 마지막 호출부터 되돌아오는 흐름이 그림으로 나온다. 

### 스택 프레임에 들어가는 것(핵심만)

함수가 호출되면 다음 정보가 “호출 기록”으로 저장된다.

* 어디서 호출했는지(복귀 주소)
* 지역 변수
* 매개변수
* (언어/환경에 따라) 임시 값 등

그래서 함수가 중첩 호출될수록 스택에 프레임이 계속 쌓이고, **가장 마지막에 호출된 함수가 먼저 끝나면서** 스택에서 빠진다. 

이게 바로 “재귀가 스택을 쓴다”는 말의 정확한 의미다.

---

## 7) 재귀(Recursion): “함수가 자기 자신을 다시 호출하는 구조”가 왜 스택과 연결되는가

재귀는 같은 작업을 더 작은 문제로 쪼개서 풀 때 강력하다. 자료에서도 재귀를 “자기 자신을 다시 호출하는 구조”로 설명한다. 

### 재귀에서 절대 빠지면 안 되는 2요소

1. **종료 조건(Base case)**
   이게 없으면 무한 호출 → 스택이 계속 쌓이다가 터진다.
2. **문제를 줄이는 규칙(Recursive step)**
   호출할 때마다 문제 크기가 줄어야 종료 조건에 도달한다.

---

## 8) 팩토리얼로 재귀 흐름을 “스택처럼” 이해하기

팩토리얼 (n!)은 (n \times (n-1)!) 로 정의된다.
재귀로 구현하면 호출이 아래로 내려가며 쌓이고, return은 위로 올라오며 계산이 완성된다. 자료 그림도 이 “내려가기 → 올라오기”를 단계적으로 보여준다. 

핵심 감각:

* 호출 단계: `fact(4) → fact(3) → fact(2) → fact(1)`
* 반환 단계: `1`을 시작으로 `2*1 → 3*2 → 4*6`처럼 “마지막 호출부터” 값이 조립된다

이 흐름이 **스택 프레임이 pop되며 반환값이 전달되는 과정**과 정확히 일치한다. 

---

## 9) 피보나치 재귀가 느린 이유: 같은 계산을 너무 많이 한다

피보나치는 (F(n)=F(n-1)+F(n-2)) 구조다. 재귀로 작성하면 자연스럽지만, 호출 트리가 크게 퍼지면서 같은 값을 반복 계산한다. 자료에는 호출 트리가 커지며 시간 복잡도가 커진다는 점이 강조된다. 

예를 들어 `F(5)`를 구할 때 `F(3)` 같은 값이 여러 경로에서 반복 호출된다.
즉, “쓸데없이 똑같은 일을 다시 한다”가 병목이다.

---

## 10) 메모이제이션(Memoization): “이미 계산한 건 저장해두고 재사용”

메모이제이션은 “재귀의 중복 호출” 문제를 해결하기 위한 핵심 기법이다. 자료에서도 “이전에 계산한 값을 저장해두고 다시 계산하지 않도록 한다”는 취지로 정리되어 있다. 

### 메모이제이션의 본질

* 어떤 입력 n에 대한 결과를 `memo[n]`에 저장한다.
* 다음에 같은 n을 요청하면 계산하지 말고 `memo[n]`을 즉시 반환한다.

이렇게 하면 피보나치가 “지수적으로 느려지는 구조”에서 “한 번씩만 계산하는 구조”로 바뀐다. 

---

## 11) DP(동적 계획법): 메모이제이션을 “체계적으로” 푸는 방식

자료는 동적 계획법(DP)을 최적화/최적해를 위한 대표 알고리즘 패러다임으로 소개하고, 피보나치 예제로 재귀식과 누적 계산을 연결한다. 

DP를 한 문장으로 말하면:

> “큰 문제를 작은 문제로 쪼갤 수 있을 때, 작은 문제의 답을 저장해 큰 문제의 답을 만든다.”

### 피보나치에서 DP가 되는 순간

* 재귀: 필요할 때마다 내려가서 구한다(중복 계산 위험)
* DP(반복): 작은 값부터 차례대로 채우며 올라간다

이때 가장 중요한 감각은 **“테이블(리스트) 인덱스 = 문제의 크기”** 로 두는 것이다. 

---

## 12) DFS(깊이 우선 탐색): 스택이 만들어내는 “끝까지 가보기” 전략

자료 후반에는 DFS를 “한 방향으로 가능한 한 깊게 탐색하고, 더 갈 곳이 없으면 되돌아오는 탐색”으로 설명하고, 트리/그래프 예시에서 스택에 쌓이는 흐름을 그림으로 보여준다. 

### DFS가 스택과 맞는 이유

DFS는 “지금 가던 길을 끝까지 가자” 전략이다.

* 어떤 노드에서 다음 노드로 이동하면,

  * “돌아올 길(이전 위치)”을 기억해야 한다.
* 막히면 “가장 최근에 왔던 갈림길”로 돌아가야 한다.

이 “가장 최근”이라는 조건이 LIFO와 정확히 맞아서, DFS는 스택으로 구현하기가 자연스럽다. 

### DFS 구현 방식 2가지(둘 다 스택이다)

1. **재귀 DFS**
   함수 호출 스택이 곧 DFS 스택 역할을 한다.
2. **반복 DFS(직접 스택 사용)**
   스택에 다음 방문 후보를 push/pop 하며 진행한다.

재귀는 코드가 짧고 직관적이지만, 깊이가 너무 깊어지면 스택 오버플로우 위험이 있다. 반복 DFS는 그 위험을 줄이기 좋다.

---

## 마무리

* 스택은 **LIFO**라서 “가장 최근에 들어간 것”이 먼저 나온다. 
* 스택의 연산은 push/pop/peek/isEmpty가 기본 세트다. 
* 괄호 검사는 “여는 괄호 push → 닫는 괄호면 top과 매칭 후 pop” 흐름으로 해결된다. 
* 함수 호출은 스택 프레임이 쌓이는 과정이라, 재귀는 “내려가며 push, 올라오며 pop”으로 이해하면 된다. 
* 피보나치 재귀는 중복 계산이 폭발하고, 메모이제이션/DP는 그 중복을 제거한다. 
* DFS는 “끝까지 가고 막히면 되돌아오기”라서 스택(또는 재귀 호출 스택)과 본질적으로 동일하다. 

## 1) “문자”는 컴퓨터에서 어떻게 저장되는가

컴퓨터는 문자 자체를 저장하지 못하고 **숫자(코드값)** 를 저장한다. 즉, 화면에 보이는 ‘A’, ‘가’, ‘🙂’ 같은 문자는 내부적으로는 “특정 숫자”로 대응된다. 이 “문자 ↔ 숫자” 약속이 **코드 체계**다. 

### 왜 코드 체계가 중요하나

같은 숫자라도 “어떤 표(약속)로 해석하느냐”에 따라 화면에 다른 글자가 나온다.
그래서 파일을 저장할 때 인코딩을 잘못 선택하거나, 웹에서 `<meta charset=...>` 같은 설정이 맞지 않으면 글자가 깨진다. 

---

## 2) ASCII와 확장 ASCII

### ASCII(아스키)

초기에 널리 쓰인 표준 문자 코드로, 영어 중심 문자들을 코드값으로 매핑했다. 기본 ASCII는 7비트(0~127)를 많이 이야기하고, 그 안에 **제어문자 + 출력 가능한 문자(공백, 숫자, 알파벳, 기호 등)** 가 포함된다. 

### 확장 ASCII(Extended ASCII)

표준 ASCII 범위를 넘어 **추가 문자를 넣기 위해 1바이트(0~255)** 를 쓰는 방식들이 생겼다. 문제는 “0~255에 무엇을 넣는지”가 나라/시스템마다 달라서, 같은 바이트 값이 환경에 따라 다른 글자로 해석될 수 있다는 점이다. 

이 지점에서 “전 세계 문자를 한 번에 통일해서 다루자”가 필요해지고, 그 답이 유니코드다.

---

## 3) Unicode와 UTF 인코딩

### 유니코드(Unicode) = 전 세계 문자에 번호를 부여하는 ‘표준’

유니코드는 전 세계의 문자(여러 언어, 기호 등)에 대해 **고유한 코드 포인트(code point)** 를 부여한다. 예를 들어 어떤 글자 ‘A’는 U+0041처럼 표현된다. 

여기서 중요한 구분이 있다.

* **유니코드(코드 포인트)**: “문자에 번호를 붙인 표”
* **UTF(인코딩)**: “그 번호를 실제 바이트로 어떻게 저장할지 규칙”

즉, 유니코드는 ‘번호’이고 UTF는 ‘저장 방식’이다. 

### UTF-8 / UTF-16 / UTF-32 차이

* **UTF-8**: 1~4바이트 가변 길이. 영어는 1바이트로 매우 효율적이라 웹에서 사실상 표준처럼 쓰인다. 
* **UTF-16**: 2바이트(또는 일부는 4바이트) 기반. 자바/윈도 계열에서 자주 언급된다. 
* **UTF-32**: 보통 4바이트 고정 길이. 단순하지만 메모리를 많이 쓴다. 

### “인코딩이 맞는데도 깨질 수 있는” 엔디안(Endian)

2바이트 이상 단위로 저장할 때, 바이트 순서가 시스템에 따라 다를 수 있다.

* **Big-endian**: 큰 자리 바이트가 먼저
* **Little-endian**: 작은 자리 바이트가 먼저

같은 2바이트라도 순서가 바뀌면 완전히 다른 값으로 읽혀서 깨질 수 있다. 

---

## 4) 문자열(String)이란 무엇인가

문자열은 **문자들이 순서대로 나열된 데이터**다. 그리고 실전에서는 “단순 텍스트” 이상으로, 입력 처리/검색/치환/암호화 등 거의 모든 문제의 기반이 된다. 

---

## 5) 문자열의 대표 저장 방식 2가지

### (1) Length-Controlled(길이 기반)

문자열의 길이를 따로 저장해두고 그 길이만큼 읽는 방식이다.
장점은 길이를 바로 알 수 있다는 점이다.

### (2) Delimited(구분자 기반)

문자열 끝에 “문자열 종료”를 나타내는 특수 문자를 붙인다. C언어의 `'\0'`(널 문자) 방식이 대표적이다. 

이 차이가 중요한 이유는, 언어마다 문자열 내부 구조가 다르고 그에 따라 **길이 계산, 비교, 복사 비용**이 달라질 수 있기 때문이다.

---

## 6) Python 문자열의 핵심 특징

### (1) 유니코드 기반

파이썬3 문자열은 유니코드를 기본으로 다루고, 실제 저장은 UTF 계열 인코딩과 연결되어 이해하면 된다. 

### (2) 불변(Immutable)

파이썬 문자열은 한 번 만들어지면 내부 문자를 직접 바꿀 수 없다.

```py
s = "abc"
# s[0] = "z"  # 에러
```

문자열을 “수정”하는 것처럼 보이는 코드는 사실 **새 문자열을 만들어서 참조를 바꾸는 것**이다. 이 때문에 문자열을 반복해서 더하는 작업은 비효율이 될 수 있고, 리스트에 모아서 join하는 패턴이 자주 등장한다. 

### (3) 길이 구하기

파이썬은 `len(s)`로 길이를 구한다. 자바는 `length()` 같은 형태로 나온다(언어별 차이를 구분해서 이해해야 한다). 

---

## 7) 문자열 입력을 “문제 풀이용”으로 받는 방법

문자열을 입력받으면 기본적으로 한 줄이 통째로 문자열로 들어온다.

```py
text = input()
```

여기서 실전에서 자주 쓰는 변형이 있다. 

### (1) 한 줄 문자열을 “문자 리스트”로

```py
s = list(input())
```

문자 하나하나에 접근해야 하는 문제(회문, 슬라이싱, 카운팅 등)에서 편하다.

### (2) N줄 문자열을 리스트로

```py
N = int(input())
arr = [input() for _ in range(N)]
```

### (3) N×N 문자 격자(문자 보드)

예를 들어 한 줄이 `"SOF"` 같은 형태라면:

```py
N = int(input())
board = [list(input()) for _ in range(N)]
```

이렇게 하면 `board[r][c]`로 문자 접근이 가능해져서, 2차원 탐색 문제(단어 찾기, 미로 문자 탐색 등)에 바로 연결된다. 

---

## 8) 문자열 연산: 뒤집기, 회문, 비교의 본질

### (1) 뒤집기(Reverse)

파이썬에서는 슬라이싱이 매우 직관적이다.

```py
rev = s[::-1]
```

하지만 “왜 되는지”를 이해하려면, 결국은 인덱스를 양끝에서 움직이며 문자를 읽는다는 개념으로 연결해야 한다. 

### (2) 회문(Palindrome) 검사

회문은 앞에서 읽으나 뒤에서 읽으나 같은 문자열이다.
검사 방식은 크게 2가지다.

* 뒤집어서 같은지 확인: `s == s[::-1]`
* 양끝을 비교하면서 가운데로 좁히기

  * i번째 문자와 (끝-i)번째 문자를 비교
  * 하나라도 다르면 회문이 아니다

이 방식은 문자열/배열 모두에 그대로 적용된다. 

### (3) 문자열 비교의 함정: `==` vs `is`

* `==` : 값(내용)이 같은지
* `is` : 같은 객체(메모리)가 맞는지

문자열 값 비교는 항상 `==`를 써야 안전하다. `is`는 “우연히” True가 나오는 상황이 있어도 그걸 믿고 쓰면 틀릴 수 있다. 

---

## 9) 문자열과 숫자 변환(파싱)

문제 풀이에서 입력은 대부분 문자열로 들어오고, 그걸 숫자로 바꿔 계산한다.

* 문자열 → 정수: `int("123")`
* 문자열 → 실수: `float("3.14")`
* 숫자 → 문자열: `str(123)`

여기서 핵심은 “문자열의 각 문자는 코드값(숫자)로 저장되지만, 우리가 원하는 숫자 계산 값과는 다르다”는 점이다. 그래서 파싱이 필요하다. 

---

## 10) 패턴 매칭(문자열 검색)

문자열 검색은 “텍스트 T 안에서 패턴 P가 등장하는 위치를 찾는 문제”다. 여기서 대표 알고리즘이 3개가 나온다. 

### (1) 고지식한(Brute Force) 패턴 검색

가장 직관적인 방식이다.

* 텍스트의 각 위치 i에서 시작한다고 가정하고
* 패턴을 앞에서부터 하나씩 비교
* 중간에 틀리면 다음 위치 i+1로 이동해서 다시 비교

최악의 경우 비교가 많이 터져서 시간 복잡도가 커질 수 있다. 하지만 구현이 단순하고, 입력이 작을 때는 충분히 통한다. 

---

## 11) KMP 알고리즘: “이미 비교한 정보를 버리지 말자”

고지식한 검색이 느려지는 이유는, 중간에 불일치가 나면 **패턴을 한 칸만 옮기고** 다시 처음부터 비교하기 때문이다.
KMP는 여기서 “패턴 내부의 구조”를 이용해 **불필요한 재비교를 줄인다.** 

### 핵심 개념: LPS(가장 긴 접두사=접미사)

패턴 P에서 어떤 위치까지 봤을 때,

* “앞부분(prefix)”과
* “뒷부분(suffix)”
  이 겹치는 최대 길이를 기록해두면, 불일치가 발생했을 때 패턴을 어디까지 점프할지(shift)를 알 수 있다. 

### KMP의 직관

* 텍스트는 뒤로만 간다(되돌아가지 않는다)
* 패턴도 “가능한 만큼만” 되돌린다(LPS 기반)
  그래서 전체 비교 횟수가 크게 줄어들어 효율이 좋아진다. 

---

## 12) 보이어–무어(Boyer–Moore): 뒤에서 비교해서 “크게 점프”하기

보이어–무어는 패턴을 왼쪽부터가 아니라 **오른쪽 끝에서부터 비교**하는 대표적인 아이디어를 가진다. 

### Bad-Character Heuristic(불일치 문자 규칙)

패턴과 비교하다가 어떤 문자에서 불일치가 발생하면,

* “불일치가 난 그 문자”가 패턴 안에 마지막으로 등장하는 위치를 참고해서
* 패턴을 여러 칸 점프시킨다

즉, 고지식처럼 1칸씩 밀지 않고, 상황에 따라 3칸·5칸처럼 크게 이동할 수 있다. 

### Skip 배열

이 점프를 빠르게 하려고, 문자별로 “얼마나 건너뛸지”를 미리 계산해둔 배열/테이블이 Skip이다. 

---

## 13) 문자열 암호화: 시저(Caesar) 암호로 이해하는 “치환”의 개념

문자열 암호화 파트는 “문자를 다른 문자로 바꿔서 의미를 숨긴다”는 **치환(substitution)** 개념을 예로 든다. 

### 시저 암호의 원리

알파벳을 일정 칸수만큼 밀어서 바꾼다.

* 예: 3칸 이동이면 A→D, B→E …
* 복호화는 반대로 3칸 당기면 된다

여기서 실전 구현 포인트는 “알파벳 범위를 넘으면 다시 처음으로 돌아와야 한다”는 점이다(모듈러 연산 느낌). 

---

## 14) 마지막 

이 자료가 궁극적으로 말하는 실전 포인트는 다음 3가지로 요약 

1. **문자 인코딩/유니코드/UTF를 이해해야 글자 깨짐과 입력 처리에 흔들리지 않는다.**
2. **문자열은 불변이라는 성질 때문에 “수정/누적/치환”을 할 때 비용을 의식해야 한다.**
3. **패턴 검색은 고지식 → KMP(LPS) → 보이어무어(점프)로 갈수록 ‘재비교를 줄이는 설계’가 핵심이다.**

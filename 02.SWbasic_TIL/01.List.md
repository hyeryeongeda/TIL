

## 1) 알고리즘이란 무엇인가

알고리즘은 **문제를 해결하기 위한 절차(방법)** 이다.
같은 문제라도 절차가 다르면 “정답은 같아도” **걸리는 시간/필요한 자원**이 달라진다. 그래서 알고리즘을 공부할 때는 단순히 “동작한다”를 넘어서, **얼마나 효율적으로 동작하는지**까지 같이 본다. 

### 알고리즘 표현 방법

* **순서도(Flowchart)**: 네모(처리), 마름모(조건) 같은 도형으로 흐름을 그림으로 표현한다.
* **의사코드(Pseudocode)**: 실제 언어 문법에 딱 맞진 않아도, 사람이 읽기 좋게 절차를 적는다.
* **코드(Code)**: 파이썬/자바 같은 언어 문법대로 작성한 실제 프로그램이다.

핵심은 “표현 방식은 달라도 같은 로직”이라는 점이다. 의사코드를 정확히 이해하면 어떤 언어로든 구현이 쉬워진다.

---

## 2) 시간 복잡도와 Big-O 표기법

### 시간 복잡도(Time Complexity)가 보는 것

시간 복잡도는 “실행 시간”을 초 단위로 딱 재기보다는, 입력 크기 (n)이 커질 때 **연산 횟수가 어떻게 증가하는지**를 본다.
즉, “n이 10배가 되면 연산이 10배 늘어나는가? 100배 늘어나는가?” 같은 성장률을 보는 것이다.

### Big-O(Big-O Notation)의 핵심 규칙

Big-O는 시간 복잡도 식에서 **가장 크게 영향을 주는 항만 남겨서** 표현한다.

* (O(3n + 2)) → (O(n))

  * 상수 2는 커져도 영향이 작다
  * 계수 3도 “n에 비례”라는 본질을 바꾸지 않는다
* (O(2n^2 + 10n + 100)) → (O(n^2))

  * (n)이 커지면 (n^2)이 나머지를 압도한다
* (O(4)) → (O(1))

  * 입력 크기와 무관한 “상수 시간”이다

### 왜 이게 중요하나

입력이 작을 때는 어떤 알고리즘이든 빨라 보일 수 있다.
하지만 입력이 커지면 **(O(n))과 (O(n^2))** 는 체감이 아니라 “현실이 바뀌는 수준”으로 차이가 난다. 그래서 문제 풀이(특히 코테/APS)에서는 “정답을 만드는 로직”과 함께 “시간 제한을 통과하는 로직”이 동시에 필요하다. 

---

## 3) 배열(Array) 개념: 데이터를 “묶어서” 다루는 이유

배열은 같은 자료형의 값들을 **하나의 이름으로 묶어서** 다루는 자료구조다.
변수 6개를 `num0, num1, ...`로 따로 만들면 반복문으로 처리하기가 어렵다. 배열로 묶으면 다음이 가능해진다.

* 반복문으로 전체 합 구하기
* 최댓값 찾기
* 특정 값의 위치(인덱스) 찾기
* 정렬 같은 알고리즘을 적용하기

### 1차원 배열 기본 (파이썬 기준)

* 생성

  * `arr = []`
  * `arr = [0] * 10`  (길이 10짜리 0으로 초기화)
  * `arr = [1, 2, 3]`
* 접근/수정

  * `arr[0] = 10`
  * `arr[idx] = 20`

### 입력을 배열로 받는 패턴(코테에서 매우 자주 나옴)

* 첫 줄에 N, 다음 줄에 N개 정수라면

  * `N = int(input())`
  * `arr = list(map(int, input().split()))`
* 첫 줄에 `N V`(N개 중 V 찾기) 같은 형태면

  * `N, V = map(int, input().split())`
  * `arr = list(map(int, input().split()))`

---

## 4) 배열로 하는 대표 작업 4가지

### (1) 배열 원소의 합

아이디어는 “누적 변수”를 하나 두고, 배열을 돌면서 계속 더하는 것이다.

```py
s = 0
for i in range(N):
    s += arr[i]
# 또는
s = 0
for x in arr:
    s += x
```

* 시간 복잡도: (O(n))
* 포인트: `s`는 매 반복마다 “지금까지의 합”을 들고 다닌다.

### (2) 최댓값(max) 찾기

핵심은 “현재 최댓값 후보”를 하나 들고 비교하며 갱신하는 것이다.

```py
max_v = arr[0]          # 첫 원소를 최댓값으로 가정
for i in range(1, N):
    if max_v < arr[i]:
        max_v = arr[i]
```

* 시간 복잡도: (O(n))
* 포인트: `max_v`를 0 같은 값으로 시작하면 음수 배열에서 틀릴 수 있다. 그래서 보통 `arr[0]`으로 시작한다.

### (3) 최댓값의 인덱스(max_idx) 찾기

최댓값 자체가 아니라 “위치”가 필요하면 인덱스를 갱신한다.

```py
max_idx = 0
for i in range(1, N):
    if arr[max_idx] < arr[i]:
        max_idx = i
```

#### “최댓값이 여러 개”면?

* **가장 앞(첫 번째) 최댓값**: `<`만 사용하면 된다(같은 값이면 갱신하지 않음).
* **가장 뒤(마지막) 최댓값**: `<=`를 사용해 같은 값이어도 갱신하게 만든다.

```py
max_idx = 0
for i in range(1, N):
    if arr[max_idx] <= arr[i]:
        max_idx = i
```

### (4) 특정 값 V의 인덱스 찾기 (없으면 -1)

가장 기본은 선형 탐색이다.

```py
idx = -1
for i in range(N):
    if arr[i] == V:
        idx = i
        break
```

* 시간 복잡도: 최악 (O(n))
* 포인트: `break`는 “첫 번째로 찾은 위치”가 필요할 때 쓴다.
  “마지막 위치”가 필요하면 break 없이 끝까지 돈 뒤 갱신하면 된다.

---

## 5) 정렬(Sort)과 버블 정렬(Bubble Sort)

정렬은 여러 값을 **기준(키)** 에 따라 오름차순/내림차순으로 재배열하는 것이다. 

### 버블 정렬의 아이디어

“인접한 두 원소”를 비교해서 순서가 잘못되어 있으면 교환한다.
한 번 끝까지 훑으면 **가장 큰 값이 맨 뒤로 ‘밀려’ 올라간다**(거품이 올라가듯) 그래서 버블이라는 이름이 붙는다.

### 버블 정렬 과정(감각 잡기)

예를 들어 `[55, 7, 78, 12, 42]`를 오름차순으로 정렬한다고 하자.

* 1회전(첫 패스): 옆끼리 비교/교환을 끝까지 하면, 최댓값(78)이 맨 뒤로 간다.
* 2회전: 뒤의 78은 이미 확정이니 그 전까지만 비교하면 된다.
* … 이렇게 확정 구간이 늘어난다.

### 의사코드 형태(구조가 핵심)

바깥 반복: “정렬 범위의 끝”을 줄여나간다.
안쪽 반복: “인접 비교/교환”을 수행한다.

### 파이썬 구현 예시

```py
def bubble_sort(a):
    n = len(a)
    for end in range(n - 1, 0, -1):
        for j in range(end):
            if a[j] > a[j + 1]:
                a[j], a[j + 1] = a[j + 1], a[j]
```

### 시간 복잡도

* 평균/최악: (O(n^2))
* 직관: 비교가 대략 (n + (n-1) + ... + 1 \approx \frac{n^2}{2}) 수준으로 발생한다.

---

## 6) 카운팅 정렬(Counting Sort)

카운팅 정렬은 “비교로 정렬”하지 않는다.
대신 값의 범위가 제한된 정수일 때, **각 값이 몇 번 나왔는지 세어서** 정렬 결과를 만든다. 

### 언제 쓸 수 있나 (제한 조건이 핵심)

* 데이터가 **정수(또는 정수로 매핑 가능)** 이어야 한다.
* 최댓값 (k)를 알아야 하고, `0..k` 크기의 카운트 배열을 만들 수 있어야 한다.
  즉, 데이터 길이 (n)보다 (k)가 너무 크면 메모리/시간이 손해가 될 수 있다.

### 시간 복잡도

* (O(n + k))

  * (n): 데이터 개수
  * (k): 값의 최댓값(정확히는 범위 크기)

### 3단계로 이해하면 깔끔하다

#### 1단계: 개수 세기 (COUNTS)

`COUNTS[x] = 값 x가 나온 횟수`

예: 데이터가 `[0, 4, 1, 3, 1, 2, 4, 1]`이면

* 0은 1번, 1은 3번, 2는 1번, 3은 1번, 4는 2번처럼 기록된다.

#### 2단계: 누적합 만들기 (prefix sum)

`COUNTS[i] = i 이하의 값이 총 몇 개인지`

이 누적합은 “값 i가 결과 배열에서 **마지막으로 들어갈 위치(끝 인덱스)**” 정보를 준다.
예를 들어 누적합이 `[..., 4, 5, 6, 8]`이면

* 2 이하 값이 총 5개, 3 이하 값이 총 6개… 이런 의미다.

#### 3단계: 뒤에서부터 TEMP에 채우기 (안정 정렬)

데이터를 뒤에서부터 보면서,

* 현재 값이 `v`라면 `COUNTS[v] -= 1`
* 그 인덱스에 `v`를 배치한다: `TEMP[COUNTS[v]] = v`

“뒤에서부터” 채우는 이유는 **안정성(stable)** 을 지키기 위해서다.
같은 값이 여러 개 있을 때, 입력에서의 상대적 순서를 유지하고 싶으면 이 방식이 중요해진다(특히 (값, 추가정보) 같이 묶인 데이터를 정렬할 때).

### 구현 뼈대(이 구조를 외워두면 APS에서 바로 씀)

```py
def counting_sort(data, k):
    counts = [0] * (k + 1)

    # 1) count
    for x in data:
        counts[x] += 1

    # 2) prefix sum
    for i in range(1, k + 1):
        counts[i] += counts[i - 1]

    # 3) build output (stable)
    temp = [0] * len(data)
    for i in range(len(data) - 1, -1, -1):
        x = data[i]
        counts[x] -= 1
        temp[counts[x]] = x

    return temp
```

---

## 7) 정렬 알고리즘 비교 감각 잡기

정렬은 상황에 따라 선택이 달라진다.

* 버블/선택/삽입 같은 단순 정렬: 구현은 쉽지만 보통 (O(n^2))
* 퀵/병합: 평균적으로 빠르거나 안정적이지만 구현/메모리 특성이 다르다
* 카운팅: 값 범위가 작을 때 압도적으로 빠를 수 있으나 조건이 까다롭다

“시간 복잡도 표”는 외우는 게 목표가 아니라, **입력 크기/조건을 보고 어떤 정렬을 떠올릴지** 감을 만드는 게 목표다. 

---

## 8) 완전 검색(Brute Force)의 핵심: 전부 해보고 조건으로 걸러내기

완전 검색은 가능한 경우를 **전부 생성/검사**해서 답을 찾는 방식이다.
가장 확실하지만 경우의 수가 커지면 시간 초과가 나기 쉽다.

### Baby-gin(예시)의 포인트

* 0~9 카드에서 6장을 뽑는다.
* 3장 연속이면 run, 3장 동일이면 triplet
* 6장이 run/triplet로만 구성되면 baby-gin

이런 문제는 “조건(런/트리플릿)을 어떻게 판단할지”와 “경우를 어떻게 만들지”가 핵심이다.
단순하게는:

* 6자리의 모든 순열을 만들어서, 앞 3장/뒤 3장을 검사한다
* 또는 숫자 카운팅을 이용해 triplet/run을 빠르게 검사한다(카운팅 정렬 아이디어가 여기에도 연결된다)

즉, 완전 검색은 **정답 보장**이 장점이고, 카운팅 같은 기법은 **검사 비용을 줄여서** 완전 검색을 현실적으로 만들어 준다. 

---

## 9) 탐욕 알고리즘(Greedy)의 핵심: 매 순간 “최선처럼 보이는 선택”을 누적하기

탐욕은 선택의 순간마다 “지금 당장 최적”이라고 생각되는 것을 고르는 방식이다. 

### 탐욕의 특징(중요한 함정 포함)

* 각 단계의 선택은 **지역적으로는 좋아 보이지만**, 그 선택들이 쌓였을 때 **전체 최적해가 보장되지 않을 수 있다.**
* 그래서 탐욕을 쓸 때는 항상 질문해야 한다.
  **“이 문제는 탐욕 선택이 최적해로 이어진다는 근거가 있는가?”**

탐욕은 “생각 없이 구현하면 안 되는 알고리즘”이다. 반대로 말하면, 조건이 맞는 문제에서는 구현이 간단하고 매우 빠르게 풀린다.

---

## 요약

* 알고리즘은 절차이며, 효율은 시간 복잡도로 비교한다.
* Big-O는 최고차항만 남겨 성장률로 성능을 판단한다.
* 배열은 반복 처리의 기반이며, 합/최댓값/인덱스 찾기/탐색 패턴을 손에 익혀야 한다.
* 버블 정렬은 인접 교환으로 큰 값이 뒤로 가며 (O(n^2))이다.
* 카운팅 정렬은 “개수 세기 + 누적합 + 뒤에서 채우기”로 (O(n+k))를 만든다.
* 완전 검색은 전부 해보는 대신 경우의 수가 핵심이고, 탐욕은 매 순간 선택이지만 최적 보장은 증명이 필요하다.


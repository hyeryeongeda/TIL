## 1) 큐(Queue)의 정체: “먼저 온 사람 먼저 처리”를 코드로 만든 것

큐는 **선입선출(FIFO, First In First Out)** 자료구조다.
현실 비유로 가장 직관적인 예가 “번호표 뽑고 기다리는 은행/병원 대기줄”이다. 먼저 도착한 사람이 먼저 서비스받고 나간다. 이 원리를 자료구조로 만든 게 큐다. 

### 큐를 쓰는 순간의 공통점

* 처리해야 할 “대상”이 줄을 서듯 쌓인다.
* **도착 순서**가 매우 중요하다.
* “지금 들어오는 것”과 “지금 나가는 것”을 서로 독립적으로 관리해야 한다.

---

## 2) 큐의 핵심 용어 2개: front와 rear

큐를 배열로 구현하든, 연결리스트로 구현하든 결국 관리해야 하는 포인터(인덱스)가 2개다. 

* **front**: “꺼낼 위치(출구)”를 가리킨다.
  보통 `dequeue()`가 일어나는 쪽이다.
* **rear**: “넣을 위치(입구)”를 가리킨다.
  보통 `enqueue()`가 일어나는 쪽이다.

즉, 큐는 “뒤로 들어오고(front 반대), 앞으로 나간다(rear 반대)”는 직관을 코드로 고정한 구조다. 

---

## 3) 큐의 기본 연산 5개(이건 거의 세트로 외우는 게 편하다)

큐 슬라이드에서 반복해서 등장하는 표준 연산은 다음과 같다. 

* **enqueue(x)**: x를 큐의 뒤(rear)에 삽입한다.
* **dequeue()**: 큐의 앞(front)에서 1개를 삭제하고 반환한다.
* **is_empty()**: 비었는지 확인한다.
* **is_full()**: (배열 기반에서) 꽉 찼는지 확인한다.
* **peek()**: 삭제 없이 front에 있는 값을 “확인만” 한다.

여기서 포인트는 `peek()`이다.
많은 문제에서 “꺼내면 안 되고, 다음에 뭘 처리해야 하는지만 봐야 하는 상황”이 나온다. 그때 dequeue가 아니라 peek가 필요하다. 

---

## 4) 선형 큐(Linear Queue): 배열로 만드는 가장 기본 형태

선형 큐는 **배열**에 데이터를 넣고 빼는 가장 단순한 큐다. front/rear가 배열 인덱스를 움직이며 데이터를 관리한다. 

### (1) 초기 상태를 왜 `front = rear = -1`로 두는가

슬라이드 예시처럼 시작을 -1로 두면,

* “아무 것도 없는 상태”를 `front == rear`로 표현하기 쉬워진다.
* enqueue 시에는 rear를 먼저 증가시키고, 그 자리에 값을 넣는다.
* dequeue 시에는 front를 먼저 증가시키고, 그 자리에 있는 값을 꺼낸다. 

즉, **front는 ‘마지막으로 꺼낸 위치’**, rear는 **‘마지막으로 넣은 위치’** 로 생각하면 논리가 깔끔해진다.

### (2) 선형 큐의 “Empty / Full” 판정

* **Empty(비어있음)**: `front == rear` 
* **Full(가득 참)**: 보통 `rear == n - 1` (배열 끝까지 찼다면 더 못 넣는다) 

### (3) enqueue / dequeue 동작 흐름(실수 방지 포인트)

* enqueue:

  1. `rear += 1`
  2. `Q[rear] = item`
* dequeue:

  1. `front += 1`
  2. `return Q[front]`

이 “증가 먼저 / 접근 나중” 순서가 자주 헷갈린다. 슬라이드 그림도 이 흐름을 단계별로 보여준다. 

### (4) 선형 큐의 치명적 문제: “가짜 포화(공간 낭비)”

선형 큐는 dequeue를 반복하면 front가 계속 오른쪽으로 이동한다.
그런데 rear는 배열 끝까지 가면 멈춘다.
결과적으로 **앞쪽에 빈 칸이 많이 생겼는데도** rear가 끝에 도달해서 “Full”처럼 보이는 문제가 생긴다. 슬라이드의 원형 큐 도입 이유가 바로 이 공간 낭비다. 

---

## 5) 원형 큐(Circular Queue): 선형 큐의 공간 낭비를 해결한 버전

원형 큐는 배열을 **동그랗게 이어붙인 것처럼** 생각한다.
rear가 끝에 도달하면 다시 0으로 돌아오게 만들어서 앞쪽의 빈 공간을 재사용한다. 

### (1) 핵심 연산: mod(나머지)

원형 큐에서 인덱스를 한 칸 이동할 때는 이렇게 한다.

* `rear = (rear + 1) % n`
* `front = (front + 1) % n` 

이게 “끝까지 가면 다시 처음”을 수학적으로 보장해준다.

### (2) Empty/Full 판정이 바뀌는 이유

원형 큐는 “front == rear”를 계속 쓰고 싶다.
그런데 원형 큐에서 꽉 찬 상태도 front와 rear가 겹칠 수 있다. 그래서 보통 **한 칸을 비워두는 규칙**을 둔다.

* **Empty**: `front == rear`
* **Full**: `(rear + 1) % n == front` 

여기서 “한 칸 비워두기”가 감각적으로 중요하다.
배열 크기가 n이면 **실제로 저장 가능한 최대 원소 수는 n-1**이 된다. 이걸 이해 못하면 Full 조건이 계속 헷갈린다. 

---

## 6) 연결 큐(Linked Queue): 연결리스트로 만드는 큐

배열 기반 큐의 단점은 크기 제한(고정 길이)이다.
연결 큐는 노드를 연결한 연결리스트로 큐를 만들기 때문에, 메모리가 허용하는 한 크기를 유연하게 늘릴 수 있다. 

### 연결 큐에서 front/rear는 무엇을 가리키는가

* front: 맨 앞 노드(꺼낼 노드)
* rear: 맨 뒤 노드(새 노드가 붙을 자리)

enqueue는 rear 뒤에 새 노드를 붙이고 rear를 갱신한다.
dequeue는 front 노드를 제거하고 front를 다음 노드로 옮긴다. 

### 연결 큐에서 실수 포인트(매우 자주 나오는 버그)

1. dequeue로 마지막 노드를 꺼낸 순간

   * front가 None이 되면 rear도 None으로 같이 맞춰줘야 한다.
     그렇지 않으면 “빈 큐인데 rear는 남아 있는” 이상한 상태가 된다.
2. enqueue가 빈 큐에서 처음 일어나는 순간

   * front와 rear 둘 다 새 노드를 가리키게 해야 한다.

슬라이드의 단계별 그림이 바로 이 포인트를 보여준다. 

---

## 7) 파이썬에서 큐를 구현할 때의 현실적인 선택: `collections.deque`

파이썬 리스트로도 큐를 흉내낼 수 있지만, `pop(0)`은 내부적으로 원소들을 한 칸씩 당겨야 해서 비효율적이다.
그래서 파이썬에서는 큐를 만들 때 `collections.deque`를 쓰는 것이 표준에 가깝다. 슬라이드도 이 방식을 소개한다. 

```py
from collections import deque

q = deque()
q.append(1)     # enqueue
x = q.popleft() # dequeue (O(1))
```

* `append()` : 뒤로 넣기
* `popleft()` : 앞으로 빼기
  이 조합이 “진짜 큐” 동작을 가장 효율적으로 만든다. 

---

## 8) 우선순위 큐(Priority Queue): FIFO가 아니라 “우선순위가 먼저” 나간다

우선순위 큐는 이름 그대로, “먼저 들어온 것”이 아니라 **우선순위가 높은 것**이 먼저 나가는 큐다.
슬라이드에서도 FIFO가 아닌 구조라는 점을 강조한다. 

### 우선순위 큐를 구현하는 대표 방법 2가지

1. **배열/리스트 기반**

   * 매번 enqueue할 때 정렬 위치를 찾아 넣거나,
   * dequeue할 때 우선순위 최대/최소를 찾아 꺼낸다.
   * 구현은 쉬울 수 있지만, 보통 O(n)이 섞여 느려질 수 있다.
2. **힙(Heap) 기반**

   * `heappush`, `heappop`로 삽입/삭제가 O(log n)
   * 실전에서는 힙 기반이 사실상 표준이다.

---

## 9) 큐의 활용 1: 버퍼(Buffer)

버퍼는 **데이터가 한꺼번에 들어오거나, 처리 속도가 서로 다를 때** 중간에서 데이터를 임시로 쌓아두는 메모리 영역이다.
슬라이드에서도 “일시적으로 그 데이터를 보관하는 영역”으로 설명하고, 키보드 입력 버퍼 같은 예를 든다. 

### 버퍼에 큐가 잘 맞는 이유

* 들어오는 순서대로 처리하는 게 자연스럽다(FIFO).
* 생산자(입력) 속도와 소비자(처리) 속도가 달라도, 버퍼가 완충 역할을 해준다.
* 프린터 스풀, 네트워크 패킷 처리, 이벤트 루프(UI 이벤트) 같은 곳에서 큐/버퍼 조합이 자주 등장한다. 

---

## 10) 큐의 활용 2: 시뮬레이션(“마이쮸 나눠주기” 흐름의 핵심)

슬라이드에는 “마이쮸를 나눠주는 시뮬레이션”이 나오고, 시간 흐름에 따라 줄이 늘어나며 사람/개수 정보가 큐에 쌓이는 모습을 보여준다. 

이 유형의 본질은 이렇다.

* 큐에 “사람”이 들어와서
* 규칙에 따라 마이쮸를 받고(또는 작업을 하고)
* 경우에 따라 다시 큐 뒤로 들어가거나, 새로운 사람이 합류한다.
* 이 과정을 반복하다가 마이쮸가 떨어지는 순간(또는 특정 조건 만족)을 찾는다.

즉, **시간 순서대로 발생하는 사건을 처리하는 모델**을 만들 때 큐가 가장 자연스럽다. “먼저 줄 선 사람부터 처리”라는 규칙이 그대로 코드가 되기 때문이다. 

---

## 11) BFS(너비우선탐색): 큐를 쓰면 “가까운 것부터” 탐색이 보장된다

BFS는 그래프/트리에서 한 정점에서 시작해, **가까운 정점(같은 거리 레벨)**부터 넓게 퍼져나가며 방문하는 탐색이다.
슬라이드에는 DFS와 BFS 그림 비교와 함께 “인접 정점을 차례로 방문한다”는 BFS 정의가 나온다. 

### BFS에서 큐가 필요한 이유(핵심)

BFS는 “먼저 발견된 정점”부터 처리해야 레벨 순서가 유지된다.
그래서 “발견한 정점들을 줄 세워두고, 발견 순서대로 꺼내서 확장”해야 한다. 이 줄이 바로 큐다.

### BFS의 정석 흐름(visited가 왜 필요한지도 같이)

1. 시작 정점을 큐에 넣고 방문 표시를 한다.
2. 큐가 빌 때까지 반복한다.

   * 큐에서 하나를 꺼낸다(dequeue)
   * 그 정점의 인접 정점들을 확인한다.
   * 아직 방문하지 않았다면 방문 표시하고 큐에 넣는다(enqueue)

슬라이드의 코드/그림도 이 순서를 그대로 보여주며, `visited` 배열과 큐 상태가 같이 변하는 과정을 예시로 설명한다. 

### BFS가 “최단거리(간선 가중치가 동일할 때)”에 강한 이유

큐가 “발견 순서(=거리 순서)”를 유지하기 때문에,

* 먼저 꺼내지는 정점은 항상 현재까지 발견된 것 중 가장 가까운 레벨에 있다.
* 그래서 처음 어떤 정점에 도달했을 때의 거리가 곧 최단거리가 된다.

---

## 마무리

* 큐는 FIFO이며, **rear로 넣고 front로 뺀다**. 
* 선형 큐는 구현이 쉽지만 dequeue가 누적되면 **공간 낭비(가짜 포화)**가 생긴다. 
* 원형 큐는 mod로 인덱스를 돌리고, 보통 **한 칸 비워 Full을 판정**한다. 
* 연결 큐는 크기 제한이 없고, 빈 큐 처리(front/rear 동시 갱신)가 핵심이다. 
* 파이썬은 `deque`의 `append / popleft`가 큐의 표준이다. 
* BFS는 “발견한 순서대로 처리”해야 해서 큐가 필수이며, visited로 중복 방문을 막는다. 
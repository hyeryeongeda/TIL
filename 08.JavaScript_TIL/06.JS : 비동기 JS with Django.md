
---

## 1. 오늘 주제 한 줄 요약

> **버튼 클릭 → JS에서 axios로 서버에 요청 → Django가 팔로우/좋아요 처리를 하고 JSON으로 돌려줌 → JS가 그걸 받아서 버튼 글자랑 숫자만 바꾼다.**

이 패턴 하나를 몸에 익히는 게 목표라고 생각하면 편해.

---

## 2. Ajax + Django 전체 흐름 스토리

내가 “팔로우” 버튼을 눌렀을 때,
예전 방식이면:

1. `<form>` 제출
2. 서버에서 처리
3. HTML 통째로 다시 보내기
4. 브라우저 전체 새로고침

이렇게 “페이지 전체 리셋”이 일어나.

근데 우리가 하고 싶은 거는:

1. 팔로우 버튼 클릭
2. **페이지는 그대로 있고**, 버튼 글자만 `팔로우 ↔ 언팔로우` 로 바꾸고
3. 팔로워 숫자만 슥 바꾸기

그래서 하는 게 **Ajax + JSON + 비동기 JS** 조합이야.

흐름을 단계로 정리하면:

1. HTML에서 버튼/폼에 **식별자, 데이터 속성, CSRF 토큰**을 잘 심어 둔다.
2. 자바스크립트에서 **submit / click 이벤트를 가로채서** `preventDefault()`로 기본 동작을 막는다.
3. 그 대신 **axios로 Django URL에 요청**을 보낸다.
4. Django view에서 **팔로우/좋아요 토글**을 처리하고,
   그 결과를 **JSON 데이터(예: `is_followed`, `followers_count`)로 응답**한다.
5. JS에서 이 JSON을 받아서 **DOM을 직접 조작해서** 버튼 글자, 숫자, 아이콘 클래스를 바꾼다.

이게 반복되면 “모든 비동기 UI”는 다 이런 식으로 느껴지기 시작해.

---

## 3. 비동기 팔로우 구현 – 한 번에 흐름 잡기

### 3-1. HTML 마크업: 뭘 미리 심어둬야 하는지

팔로우는 보통 **프로필 페이지**에서 처리한다고 치자.

HTML에서 핵심은 세 가지야:

1. **폼 + 버튼**
2. **어떤 유저를 팔로우할지 식별할 user pk**
3. **CSRF 토큰**

```html
<form id="follow-form" data-user-id="{{ person.pk }}">
  {% csrf_token %}
  <button type="submit" id="follow-btn">
    {% if is_followed %}Unfollow{% else %}Follow{% endif %}
  </button>
  <span id="followers-count">{{ person.followers.count }}</span>
</form>
```

* `data-user-id`
  → 이 폼이 “어떤 유저를 팔로우 하는지” JS에서 알 수 있게 해주는 데이터.
* `{% csrf_token %}`
  → 장고가 요구하는 필수 보안 토큰. 나중에 axios 요청 헤더로 실어 보낼 것.

`data-`로 시작하는 속성은 JS에서 `element.dataset.userId`처럼 접근 가능해서,
**HTML ↔ JS 사이에 값을 넘기는 통로**라고 생각하면 된다.

---

### 3-2. JS 준비: axios CDN + 이벤트 등록

먼저 템플릿에 axios CDN 스크립트를 추가해 둔다.

```html
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

그리고 `<script>` 안에서 비동기 처리를 한다:

```js
const form = document.querySelector('#follow-form')
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value

form.addEventListener('submit', (event) => {
  event.preventDefault()  // 원래 폼 제출(새로고침)을 막는다.

  const userId = event.currentTarget.dataset.userId

  axios({
    method: 'post',
    url: `/accounts/${userId}/follow/`,
    headers: { 'X-CSRFToken': csrftoken },
  })
    .then((response) => {
      // 여기서 DOM 업데이트
    })
    .catch((error) => {
      console.error(error)
    })
})
```

여기서 포인트 몇 가지:

* **`event.preventDefault()`**
  → 안 쓰면 폼이 그냥 서버로 날아가고 페이지가 새로고침된다.
* **`event.currentTarget` vs `event.target`**

  * `currentTarget`은 **이 리스너가 달려 있는 요소**(여기서는 form).
  * `target`은 **실제로 클릭된 요소**(여기서는 button).
    form에 `data-user-id`를 달아놨으니까 `currentTarget.dataset.userId`를 쓰는 게 맞다.
* **CSRF 토큰을 헤더에 붙이기**

  * 장고는 POST 요청에 CSRF 토큰이 없으면 403 Forbidden을 준다.
  * 그래서 axios 요청에 `headers: { 'X-CSRFToken': csrftoken }` 이렇게 붙여준다.

---

### 3-3. Django view: 팔로우 토글하고 JSON으로 응답

이제 서버 쪽.
URL 예: `/accounts/<int:user_pk>/follow/`

뷰의 흐름은 딱 두 가지:

1. 이미 팔로우 하고 있으면 → **언팔로우**
2. 안 하고 있으면 → **팔로우**

그리고 그 결과를 **JSON으로 보내주는 것**이 핵심이야.

```python
from django.contrib.auth.decorators import login_required
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model

User = get_user_model()

@login_required
def follow(request, user_pk):
    person = get_object_or_404(User, pk=user_pk)

    # 자기 자신은 팔로우 못 하게 막는 처리도 보통 같이 넣는다.
    if request.user == person:
        return JsonResponse({'error': 'self follow not allowed'}, status=400)

    # 이미 팔로우 중이면 → 제거
    if request.user in person.followers.all():
        person.followers.remove(request.user)
        is_followed = False
    else:
        person.followers.add(request.user)
        is_followed = True

    context = {
        'is_followed': is_followed,
        'followers_count': person.followers.count(),
    }
    return JsonResponse(context)
```

여기서 중요한 개념들:

* **`JsonResponse`**

  * 장고에서 **파이썬 딕셔너리를 JSON으로 바꿔서 보내주는 클래스**.
  * Ajax에서는 HTML 덩어리보다 숫자/불린 같은 **데이터만 필요한 경우가 많아서** JSON으로 주고받는 게 훨씬 편하다.
* `is_followed`

  * 지금 요청 이후에 “팔로우 상태인가, 아닌가”를 표시하는 불린 값.
  * JS에서 버튼 글자를 바꿀 때 사용한다.
* `followers_count`

  * 현재 팔로워 수. span 태그 안의 텍스트를 이 값으로 덮어 씌운다.

---

### 3-4. 응답 받은 뒤, JS에서 DOM 업데이트

이제 다시 JS로 돌아와서, `response.data`를 이용해 화면을 조작한다.

```js
const btn = document.querySelector('#follow-btn')
const followersCount = document.querySelector('#followers-count')

form.addEventListener('submit', (event) => {
  event.preventDefault()
  const userId = event.currentTarget.dataset.userId

  axios({
    method: 'post',
    url: `/accounts/${userId}/follow/`,
    headers: { 'X-CSRFToken': csrftoken },
  })
    .then((response) => {
      const data = response.data

      // 버튼 글자 바꾸기
      if (data.is_followed) {
        btn.innerText = 'Unfollow'
      } else {
        btn.innerText = 'Follow'
      }

      // 팔로워 수 바꾸기
      followersCount.innerText = data.followers_count
    })
    .catch((error) => {
      console.error(error)
    })
})
```

이렇게 하면:

* 서버에서 로직을 처리하고
* JSON으로 결과만 보내주고
* 화면은 JS가 “필요한 부분만” 직접 고친다.

새로고침은 한 번도 일어나지 않는다.

---

## 4. 비동기 좋아요 구현 + 이벤트 버블링 / 위임

좋아요는 팔로우랑 거의 똑같은 구조인데, **게시글이 여러 개**라는 점이 다르다.

* 게시글마다 **각각 좋아요 버튼, 좋아요 수 span**이 있다.
* 심지어 Ajax로 새 글이 추가될 수도 있다.
* 이럴 때 **모든 버튼에 `addEventListener`를 일일이 붙이면 너무 번거롭고, 동적으로 생긴 요소는 또 안 잡힌다.**

그래서 쓰는 개념이 **이벤트 버블링 + 이벤트 위임**이야.

---

### 4-1. 이벤트 버블링(bubbling) 개념

버튼을 클릭하면 이벤트가 **안쪽 → 바깥쪽으로 올라간다.**

```html
<div id="article-container">
  <article data-article-id="1">
    <button class="like-btn">좋아요</button>
    <span class="like-count">3</span>
  </article>
  <!-- 이런 article이 여러 개 있다고 가정 -->
</div>
```

위 구조에서 버튼을 클릭하면:

1. `button`에서 클릭 발생
2. `article`로 이벤트가 전파
3. `div#article-container`까지 전파

이 “위로 올라가는 전파”를 **버블링**이라고 부른다.

---

### 4-2. 이벤트 위임(delegation) – 왜 필요한지

게시글이 100개 있으면 버튼도 100개다.
각 버튼마다 `addEventListener`를 붙이면 코드도 길고,
나중에 Ajax로 글을 새로 그렸을 때는 **새 버튼에 이벤트가 안 붙는 문제**가 생긴다.

그래서,

> “가장 바깥 컨테이너 하나에만 이벤트를 달고,
> 실제로 어떤 버튼이 눌렸는지는 `event.target`으로 구분하자.”

라는 아이디어가 **이벤트 위임**.

JS 예시는 이런 식:

```js
const articleContainer = document.querySelector('#article-container')
const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]').value

articleContainer.addEventListener('click', (event) => {
  // 실제로 클릭된 요소가 좋아요 버튼인지 확인
  if (!event.target.matches('.like-btn')) {
    return
  }

  const articleId = event.target.dataset.articleId

  axios({
    method: 'post',
    url: `/articles/${articleId}/likes/`,
    headers: { 'X-CSRFToken': csrftoken },
  })
    .then((response) => {
      const data = response.data
      const likeCountSpan = event.target
        .closest('article')
        .querySelector('.like-count')

      likeCountSpan.innerText = data.like_count

      if (data.is_liked) {
        event.target.classList.add('liked')
      } else {
        event.target.classList.remove('liked')
      }
    })
    .catch((error) => console.error(error))
})
```

핵심 포인트:

* `articleContainer` **하나에만** 이벤트 리스너를 달았다.
* `event.target`이 실제로 클릭된 버튼이니까,
  `.matches('.like-btn')`로 필터링한다.
* `closest('article')`로 같은 글 안에 있는 좋아요 수 span을 찾아서 수정한다.
* Django view에서는 팔로우 때랑 비슷하게

  ```python
  context = {
      'is_liked': is_liked,
      'like_count': article.like_users.count(),
  }
  return JsonResponse(context)
  ```

  이런 식으로 JSON을 돌려준다.

---

## 5. CSRF, JSONResponse, dataset 정리 – 개념 한 번에 잡기

### 5-1. CSRF 토큰이 뭔지, 왜 axios에 꼭 넣는지

* **CSRF (Cross-Site Request Forgery)**
  → “내가 의도하지 않았는데, 악성 사이트가 내 브라우저를 이용해서
  다른 사이트에 POST 요청을 날리는 공격”을 막기 위한 장치.
* 장고는 POST/PUT/DELETE 같이 **데이터를 바꾸는 요청**에 대해
  CSRF 토큰이 없으면 기본적으로 차단한다.
* 원래는 `<form>` 안에 `{% csrf_token %}`가 있으면 장고가 자동으로 처리해 주지만,
* 우리는 **폼 제출 대신 axios로 직접 요청을 보내고 있으니까**
  JS에서 헤더에 이 토큰을 직접 붙여서 보내야 한다.

정리하면:

> “장고한테 ‘진짜 이 사이트에서 보낸 요청 맞아요’라고 인증해주는 티켓을
> axios가 같이 들고 가야 한다.”

라고 기억해두면 된다.

---

### 5-2. 왜 HTML 대신 JSONResponse를 쓰는지

* 전통 방식: 서버가 **HTML을 렌더링해서 전체 페이지를 다시 보냄.**
* Ajax 방식: 이미 HTML은 클라이언트에 그려져 있고,
  **바꿔야 하는 건 숫자 1개, 상태값 하나 정도**인 경우가 대부분.

그래서

* 서버는 딱 필요한 값만 JSON으로 보내고 (`is_liked`, `like_count`…)
* 화면에서 “어디를 어떻게 바꿀지”는 JS가 결정한다.

이렇게 하면

1. **네트워크로 주고받는 데이터가 적고**
2. 프론트/백이 **역할 분리가 잘 되고**
3. 같은 API를 나중에 모바일 앱에서도 재사용하기 좋다.

---

### 5-3. `data-` + `dataset` 요약

* HTML 쪽에서 `data-user-id="3"` 이런 식으로 적어둔다.
* JS에서 `element.dataset.userId`로 바로 가져올 수 있다.
* 장점:

  * 굳이 `id`를 여러 개 만들지 않아도 되고
  * 템플릿에서 넘겨준 pk / 상태 값들을 JS에서 쉽게 읽어올 수 있다.

Ajax에서 항상 “어떤 대상에 대한 요청인지” 알아야 하니까,
**pk를 data 속성으로 심어두고 `dataset`으로 읽어온다**라는 패턴을 잘 기억해두면 좋다.

---

## 6. 오늘 TIL로 적을 수 있는 핵심 포인트 정리

마지막으로, 오늘 내용을 TIL에 바로 붙여넣을 수 있게 요약해볼게.

1. **Ajax + Django 비동기 흐름**

   * 버튼 클릭 → JS에서 기본 동작 막기(`preventDefault`)
   * JS에서 axios로 Django URL에 POST 요청 보내기(헤더에 CSRF 토큰 포함)
   * Django view에서 팔로우/좋아요 토글 처리하고 JSON으로 상태값 응답
   * JS에서 JSON을 받아 DOM 요소의 글자/숫자/클래스를 직접 수정

2. **팔로우/좋아요 공통 패턴**

   * HTML: `data-` 속성으로 pk 저장, csrf token 포함
   * JS: `event.currentTarget.dataset.xxx` 또는 `event.target.dataset.xxx`로 pk 가져오기
   * Django: `JsonResponse`로 `is_…`, `…_count` 형식으로 돌려주기

3. **이벤트 버블링 & 이벤트 위임**

   * 버블링: 안쪽에서 발생한 이벤트가 바깥 요소로 전파되는 현상.
   * 위임: 부모 요소 하나에만 리스너를 달고, `event.target`으로 실제 버튼을 판별하는 패턴.
   * 게시글/좋아요처럼 요소가 많거나 동적으로 생기는 경우에 특히 유용하다.

4. **CSRF / JSONResponse / dataset 정리**

   * CSRF: 장고에서 POST 요청이 진짜 우리 사이트에서 온 건지 확인하기 위한 토큰.
   * JSONResponse: HTML 대신 JSON으로 필요한 데이터만 응답할 때 사용.
   * dataset: HTML의 `data-` 속성을 JS에서 쉽게 접근하게 해주는 인터페이스.

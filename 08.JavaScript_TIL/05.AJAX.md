
---

## 1. 동기(Synchronous) vs 비동기(Asynchronous)

### 1) 동기 – “줄 서서 한 명씩 처리”

* 동기 방식은 **작업이 순서대로 차례차례** 진행된다.
* 앞에 있는 일이 끝나야 그 다음 일이 시작된다.
* 즉, **하나의 작업이 끝날 때까지 다른 작업은 기다려야 한다.**

카페 주문으로 비유하면

1. 내가 줄에 서서 주문한다.
2. 바리스타가 내 커피를 만들고, 완전히 다 만든 다음에야
3. 다음 손님 주문을 받는다.

→ 앞 사람이 길게 잡으면 **뒤에 있는 사람들은 무조건 기다려야 한다.**

자바스크립트 코드로 보면

```js
console.log('주문 받기')
기다리기_3초()
console.log('커피 내주기')
console.log('다음 손님')
```

이런 식이면 `기다리기_3초()`가 끝나기 전까지 **그 아래 코드가 전혀 실행되지 않는다.**

---

### 2) 비동기 – “기다리는 동안 다른 일도 같이”

* 비동기는 **기다리는 작업이 있어도, 그 사이에 다른 일을 먼저 진행**할 수 있게 해주는 방식.
* “예약해 두고, 나중에 결과가 준비되면 알려줘”라는 패턴.

카페 비유로 다시 보면

1. 내가 주문을 한다.
2. 바리스타가 “진동벨”을 준다.
   (→ 이게 나중에 실행될 **콜백 함수 등록** 같은 느낌)
3. 나는 자리에 가서 다른 일을 한다.
4. 커피가 준비되면 벨이 울린다.
   (→ **비동기 작업이 끝났음을 알려주는 시점**)

→ 이렇게 하면, “기다리는 시간”을 그냥 버리지 않고 **다른 작업과 겹쳐서 사용할 수 있다.**

자바스크립트에서 대표적인 비동기 예시는

* `setTimeout`
* HTTP 요청(AJAX / Axios로 API 요청)
* 파일 읽기, 이벤트 리스너 등

---

## 2. 자바스크립트는 왜 비동기가 중요할까? (Single Thread)

### 1) Single Thread라는 특성

* 자바스크립트는 기본적으로 **한 번에 하나의 작업만 처리**할 수 있는 **Single Thread** 언어다.
* 즉, CPU 한 명이 줄 서 있는 작업들을 하나씩 처리하는 느낌.

만약 네트워크 요청 같은 느린 작업을 “동기”로 처리하면?

* 서버 응답이 올 때까지 **브라우저 전체가 멈춘 것처럼** 반응이 없어진다.
* 사용자 입장에서는 “페이지 죽었나?”라고 느끼게 된다.

그래서 자바스크립트는 **느리고 오래 걸리는 일은 비동기로 처리**하고,
메인 쓰레드(Call Stack)는 **빠르게 처리할 수 있는 일들만 계속 진행**하게 만드는 구조를 사용한다.

---

## 3. 자바스크립트 런타임 구조 이해하기

자바스크립트가 비동기를 다루는 핵심 구성 요소는 크게 네 가지라고 정리할 수 있다.

1. **Call Stack (호출 스택)**
2. **Web APIs (브라우저가 제공하는 비동기 기능)**
3. **Task Queue (또는 Callback Queue)**
4. **Event Loop**

### 1) Call Stack

* **현재 실행 중인 함수들이 쌓여 있는 스택 구조**.
* 우리가 작성한 자바스크립트 함수들은 전부 여기서 실행된다.
* 예:

```js
function a() {
  b()
}
function b() {
  console.log('hi')
}
a()
```

실행 흐름

1. `a()`가 Call Stack에 들어감
2. `a` 안에서 `b()` 호출 → `b`가 Stack 위에 쌓임
3. `b` 실행 끝 → Stack에서 빠짐
4. 다시 `a` 실행 마무리 → `a`도 빠짐

→ Stack이 비면, 이제 **다음에 처리할 일을 Event Loop가 가져와서 올려준다.**

---

### 2) Web APIs (브라우저의 비동기 담당자)

* 브라우저가 제공하는 **타이머, 네트워크 요청, DOM 이벤트 등록** 같은 기능을 담당하는 별도 영역.
* `setTimeout`, `fetch`, `XMLHttpRequest`, `addEventListener` 등은 **Call Stack이 아니라 Web API 영역에서 실제 타이머/요청을 처리**한다.

흐름 예시:

```js
console.log('시작')

setTimeout(() => {
  console.log('3초 뒤')
}, 3000)

console.log('끝')
```

1. `console.log('시작')` → Stack에서 바로 실행.
2. `setTimeout` 함수가 호출되면

   * 일정 시간(3000ms) 체크는 **Web API 영역**으로 넘어간다.
   * 콜백 함수 `() => { console.log('3초 뒤') }`는 “나중에 실행할 작업”으로 등록.
3. `console.log('끝')` 바로 실행.
4. 3초가 지나면 Web API가 “이 콜백 실행해도 돼요” 라고 **Task Queue**에 콜백을 넣는다.

---

### 3) Task Queue (Callback Queue)

* “**나중에 실행해야 할 콜백 함수들이 줄 서 있는 곳**” 이라고 생각하면 편하다.
* Web API에서 작업이 끝나면, 그 결과로 실행해야 할 콜백이 이 큐에 쌓인다.

하지만 **큐에 들어왔다고 바로 실행되는 게 아니다.**

* **Call Stack이 완전히 비었을 때만**
  Event Loop가 Task Queue에서 하나씩 꺼내서 Stack으로 올려준다.

---

### 4) Event Loop

* **“지금 Stack 비었어? 그럼 Queue에 기다리는 애 있니?”**를 계속 확인하는 관리자.
* 역할은 단순하지만 중요하다.

동작 요약

1. Call Stack이 비어있는지 확인
2. 비어 있고, Task Queue에 콜백이 있다면
3. 그 콜백을 Stack으로 올려서 실행하게 만든다

이 구조 때문에, `setTimeout(…, 0)`처럼 **지연 시간을 0으로 줘도 바로 실행되지 않고**,
현재 실행 중인 동기 코드가 끝난 후에야 실행된다.

---

## 4. Ajax란 뭘까?

이제 비동기를 이용해서 **서버와 데이터를 주고받는 패턴**이 Ajax.

* **Asynchronous JavaScript and XML**의 줄임말.
* 핵심은

  * **페이지 전체를 새로고침하지 않고도 서버와 데이터만 주고받을 수 있게 해주는 기법**.
  * 오래된 이름이라 XML이 들어가 있지만, 요즘은 거의 다 **JSON**으로 쓴다.

Ajax를 쓰면 할 수 있는 것들

1. 글 작성 후, 전체 페이지 새로고침 대신 **일부 영역만 업데이트**
2. 스크롤 끝에 도달했을 때 **추가 데이터만 가져오기(인피니트 스크롤)**
3. 검색창에서 입력할 때마다 **자동완성 리스트 갱신** 등

---

### 1) 전통적인 방식 vs Ajax 방식

**전통적인 방식**

* `<form>`을 제출하면

  * 브라우저가 서버로 요청을 보내고
  * 서버가 새로운 HTML 페이지를 만들어서 보내주고
  * 브라우저는 **전체 페이지를 통째로 다시 그림**.
* 로그인, 글 작성 후 항상 전체 화면이 깜빡이면서 새로 로딩되는 경험.

**Ajax 방식**

* 자바스크립트 코드에서 서버에 요청을 보내고(비동기)
* JSON 등의 데이터만 응답으로 받아서
* 그 데이터에 맞게 **DOM 일부만 바꾼다.**

→ 사용자 입장에서는 “페이지가 계속 이어지는 느낌”
→ 개발자 입장에서는 **프론트(뷰)와 백(데이터)를 분리해서 설계하기 좋다.**

---

## 5. XHR 객체(XMLHttpRequest) – 옛날 Ajax 방식

Ajax의 옛날 구현은 **XMLHttpRequest(XHR)** 객체를 직접 사용하는 방식이다.

특징

* 자바스크립트에서 서버로 HTTP 요청을 보낼 수 있게 해주는 내장 객체.
* GET/POST 요청을 직접 만들고, 상태 코드, 응답 처리 등을 일일이 관리해야 한다.

XHR를 직접 쓰면 코드가 대략 이런 느낌으로 길어진다:

```js
const xhr = new XMLHttpRequest()
xhr.open('GET', '/api/articles')
xhr.onreadystatechange = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    const data = JSON.parse(xhr.responseText)
    // DOM 조작
  }
}
xhr.send()
```

* 상태값(`readyState`) 체크
* 응답 코드(`status`) 체크
* 문자열(JSON) → 객체로 파싱

→ 이런 반복 코드가 많아서, 요즘은 **Axios 같은 라이브러리를 훨씬 더 많이 사용**한다.

---

## 6. Axios – 요즘 쓰는 Ajax 도구

### 1) Axios가 해주는 일

Axios는 **브라우저와 서버 사이의 HTTP 요청을 쉽게 보내고 응답을 관리**하게 해주는 자바스크립트 라이브러리.

장점 정리

1. **Promise 기반**이라 then / catch로 비동기 흐름을 깔끔하게 다룰 수 있다.
2. JSON 파싱, 헤더 설정, 에러 처리 등 번거로운 부분을 많이 대신해 준다.
3. 코드가 짧고 가독성이 좋다.

### 2) 기본 사용 패턴

```js
axios.get('https://example.com/api/articles')
  .then((response) => {
    // response.data에 서버에서 넘겨준 데이터가 들어있음
    console.log(response.data)
  })
  .catch((error) => {
    console.error(error)
  })
```

* `axios.get(url)` → 서버로 GET 요청을 보냄
* 성공하면 `.then()` 안의 콜백이 실행되고,
* 실패하면 `.catch()` 안이 실행된다.

POST 예시

```js
axios.post('/api/articles', {
  title: '제목',
  content: '내용'
})
  .then((res) => {
    console.log('작성 완료', res.data)
  })
  .catch((err) => {
    console.error(err)
  })
```

---

## 7. Promise와 비동기 콜백

### 1) 비동기 콜백의 문제 – 콜백 지옥

비동기 처리를 콜백만으로 계속 이어가면 이렇게 된다:

```js
doA((resultA) => {
  doB(resultA, (resultB) => {
    doC(resultB, (resultC) => {
      doD(resultC, (resultD) => {
        console.log('끝')
      })
    })
  })
})
```

* 괄호가 계속 안으로 파고들면서 **코드 가독성이 최악**이 된다.
* 에러 처리도 중간중간 해줘야 해서 더 복잡한 구조가 만들어진다.

이런 걸 **Callback Hell(콜백 지옥)**이라고 부른다.

---

### 2) Promise의 등장

Promise는 **“미래에 완료될 수도, 실패할 수도 있는 비동기 작업”을 표현하는 객체**.

핵심 개념

* 상태: `pending` → `fulfilled`(성공) 또는 `rejected`(실패)
* `.then()` : 성공했을 때 실행할 콜백 등록
* `.catch()` : 실패했을 때 실행할 콜백 등록
* 여러 `then`을 **체이닝(chaining)**해서 콜백 지옥을 평평하게 만든다.

예시:

```js
axios.get('/api/a')
  .then((resA) => {
    return axios.get(`/api/b?id=${resA.data.id}`)
  })
  .then((resB) => {
    return axios.get(`/api/c?id=${resB.data.id}`)
  })
  .then((resC) => {
    console.log('최종 결과', resC.data)
  })
  .catch((error) => {
    console.error('어딘가에서 에러 발생', error)
  })
```

* 콜백을 안으로 파묻지 않고,
  `.then().then().then()`처럼 **가로로 쭉 이어서** 표현할 수 있다.

---

## 8. then / catch / chaining 정리

### 1) then

* Promise가 성공 상태가 되었을 때 실행된다.
* `then` 안에서 **다른 Promise를 리턴**하면, 그 다음 `then`에서 그 결과를 이어받을 수 있다.

```js
axios.get('/api/a')
  .then((res) => {
    console.log(res.data)
    return axios.get('/api/b')
  })
  .then((resB) => {
    console.log(resB.data)
  })
```

### 2) catch

* 어떤 단계에서 에러가 나더라도,
  아래쪽에 한 번만 `.catch()`를 두면 거기서 한꺼번에 처리 가능하다.
* `try / catch`의 비동기 버전 느낌.

### 3) chaining의 장점(직접 정리)

* **가독성**: 코드가 위에서 아래로 자연스럽게 읽힌다.
* **유지보수**: 중간 과정이 추가/삭제되더라도 구조를 이해하기 쉽다.
* **에러 처리 일원화**: 마지막 `.catch` 하나로 대부분의 에러 처리 가능.
* **순차 비동기 흐름 표현**에 딱 맞는다.

---

## 9. 비동기 처리와 사용자 경험(UX)

비동기를 제대로 사용하면:

1. **브라우저가 멈추지 않는다.**

   * 서버에서 응답을 기다릴 때도, 화면은 반응하고 버튼도 눌리고 스크롤도 된다.
2. **로더(스피너)를 보여줄 수 있다.**

   * “지금 데이터를 불러오는 중입니다.”라는 피드백을 사용자가 받게 만들어 준다.
3. **부분 업데이트로 부드러운 화면 전환**이 가능하다.

하지만 비동기를 막 쓰면

* 언제 데이터가 준비되는지 헷갈려서
* 아직 오지 않은 데이터를 사용하려고 하고
* “undefined 에러” 같은 걸 자주 만나게 된다.

그래서 중요한 포인트는

> “**비동기 작업이 ‘언제 끝나는지’가 아니라, ‘끝났을 때 무엇을 할지’를 기준으로 코드를 구조화해야 한다**”

라는 사고방식.

---

## 10. 오늘 내가 이해한 포인트 정리 (TIL 요약용)

1. 자바스크립트는 **Single Thread**라서, 오래 걸리는 작업을 동기로 돌리면 브라우저가 멈춘다.
2. 그래서 **비동기** 개념이 중요하고,
   그걸 관리하기 위해 **Call Stack, Web API, Task Queue, Event Loop** 구조가 있다.
3. Ajax는 **전체 페이지 새로고침 없이 서버와 데이터만 주고받는 기법**이고,
   옛날에는 XHR을 직접 썼지만 지금은 대부분 **Axios** 같은 라이브러리를 사용한다.
4. 비동기 콜백만으로 흐름을 이어가면 **콜백 지옥**이 생긴다.
5. Promise와 `then / catch / chaining`을 사용하면
   비동기 로직을 **“위에서 아래로 읽히는 순차 코드처럼”** 정리할 수 있다.
6. 잘 설계된 비동기 처리는 **빠르고 부드러운 사용자 경험(UX)**을 만든다.

---

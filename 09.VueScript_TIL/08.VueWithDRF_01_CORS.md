---

# 📌 Vue + DRF + CORS 완전 이해하기 (나의 개념서 & TIL)

오늘은 **Vue 프론트**와 **Django REST Framework 백엔드**를 연결하면서
왜 항상 등장하는지 이해하기 힘들었던 **CORS / SOP(동일 출처 정책)** 을
처음부터 끝까지 정리했다.

* 덤으로 이 구조에서 **axios, Pinia, Router**가 어떻게 연결되는지도 복습했다.

---

## 1. 오늘 만든 전체 구조 한 눈에 보기

### 1-1. 백엔드: DRF로 Article API 서버 만들기

백엔드는 “화면”은 하나도 안 그리고, **JSON으로만 통신하는 API 서버** 역할을 한다.

* `articles` 앱

  * `models.py` : `Article` 모델 (id, title, content)
  * `serializers.py` : `ArticleSerializer` (ModelSerializer)
  * `views.py` :

    * 전체 목록 조회 / 생성 API
    * 단일 조회 / 수정 / 삭제 API
  * `urls.py` :

    * `/api/v1/articles/`
    * `/api/v1/articles/<pk>/`
  * `fixtures/articles.json` : 샘플 게시글 데이터

실행 흐름:

```bash
python manage.py makemigrations
python manage.py migrate
python manage.py loaddata articles.json
python manage.py runserver
```

→ `http://127.0.0.1:8000/api/v1/articles/` 로 접속하면 브라우저에서 JSON 목록이 보이게 된다.
(아직 Vue 연결은 안 한 상태)

---

### 1-2. 프론트엔드: Vue + Pinia + Router

프론트는 **화면 구성 + 사용자 입력 처리**만 담당하고,
실제 데이터는 DRF 서버에 요청해서 가져오거나 저장한다.

구조 예시:

* `views/`

  * `ArticleView.vue`   : 게시글 목록 페이지
  * `DetailView.vue`    : 단일 게시글 상세 페이지
  * `CreateView.vue`    : 글 작성 페이지
  * (Login / Signup 뼈대도 함께 만들어 둔 형태)
* `components/`

  * `ArticleList.vue`
  * `ArticleListItem.vue`
* `stores/articles.js`

  * state: `articles`, `selectedArticle` 등
  * actions: `getArticles()`, `getArticle(id)` 등
* `router/index.js`

  * `/articles`
  * `/articles/:id`
  * `/create`
* `main.js`

  * `createApp(App)`
  * `createPinia()` + `pinia-plugin-persistedstate` (옵션)
  * `app.use(router).use(pinia).mount('#app')`

실행:

```bash
npm install
npm run dev
```

→ 보통 `http://localhost:5173` 같은 주소에서 Vue 앱이 뜬다.

---

## 2. Vue에서 DRF로 데이터 가져오는 기본 흐름

먼저, CORS 생각은 잠깐 잊고 **“원래는 이렇게 돌아가야 한다”** 흐름부터 잡았다.

### 2-1. 화면 구성 흐름

```text
ArticleView
 └─ ArticleList
     └─ ArticleListItem
```

1. `ArticleView`

   * store에서 `articles`를 가져오거나
   * `onMounted`에서 `store.getArticles()` 실행
2. `ArticleList`

   * `v-for`로 `articles`를 반복 렌더링
3. `ArticleListItem`

   * 제목/내용 일부 보여주고, 상세 페이지로 이동하는 링크 역할

초기 개발 순서:

1. Pinia `state`에 더미 데이터 넣고 → 화면 레이아웃 먼저 완성
2. 그 후 `axios`로 **실제 DRF API와 연결**해서 더미 데이터를 교체

### 2-2. Pinia store에서 axios로 DRF 호출

```js
// stores/articles.js
import { defineStore } from 'pinia'
import axios from 'axios'

const BASE_URL = 'http://127.0.0.1:8000'

export const useArticleStore = defineStore('article', {
  state: () => ({
    articles: [],
  }),
  actions: {
    async getArticles() {
      const res = await axios.get(`${BASE_URL}/api/v1/articles/`)
      this.articles = res.data
    },
  },
})
```

그리고 `ArticleView.vue`:

```js
<script setup>
import { onMounted } from 'vue'
import { useArticleStore } from '@/stores/articles'

const articleStore = useArticleStore()

onMounted(() => {
  articleStore.getArticles()
})
</script>
```

이게 우리가 **“머리로는 이렇게 되겠지”** 라고 생각하는 이상적인 흐름이다.
근데 실제로 실행해 보면… 브라우저 콘솔에 CORS 에러가 뜬다.

---

## 3. CORS 에러가 왜 뜨는지: SOP & Origin

### 3-1. 문제 상황 정리

* Vue dev 서버 : `http://localhost:5173`
* DRF 서버     : `http://127.0.0.1:8000`

Vue에서 이렇게 요청을 보냈다:

```js
axios.get('http://127.0.0.1:8000/api/v1/articles/')
```

* DRF 쪽 로그를 보면 응답은 **정상 200 OK**로 나간다.
* 그런데 브라우저 devtools 콘솔에 빨간 글씨:

  > “CORS policy: No 'Access-Control-Allow-Origin' header …”

이 말은
“서버는 잘 응답했는데 **브라우저가 보안 정책 때문에 응답을 막아버렸다**”는 뜻이다.

그 보안 정책이 바로 **SOP(Same-Origin Policy, 동일 출처 정책)**.

---

### 3-2. Origin(출처)란?

**Origin = scheme + host + port**

예를 들어:

* `http://localhost:3000/articles`

  * scheme: `http`
  * host:   `localhost`
  * port:   `3000`
* `http://127.0.0.1:8000/api/v1/articles/`

  * scheme: `http`
  * host:   `127.0.0.1`
  * port:   `8000`

이 세 가지가 **모두 같으면 same-origin**,
하나라도 다르면 **cross-origin** 이다.

비교해 보면:

| URL                               | 같은 출처? | 다른 점        |
| --------------------------------- | ------ | ----------- |
| `http://localhost:3000/articles`  | 동일     | path만 다름    |
| `http://localhost:8000/articles`  | 다름     | port 다름     |
| `https://localhost:3000/articles` | 다름     | protocol 다름 |
| `http://127.0.0.1:3000/articles`  | 다름     | host 다름     |

우리 상황:

* 프론트: `http://localhost:5173`
* 백엔드: `http://127.0.0.1:8000`

→ host, port 둘 다 다르기 때문에 **완전 다른 origin**이다.

---

### 3-3. SOP(Same-Origin Policy) = 브라우저의 기본 보안 룰

브라우저는 기본적으로 이렇게 생각한다:

> “**같은 origin**에서 온 스크립트끼리는 자유롭게 리소스를 공유해도 된다.
> 하지만 **다른 origin**에서 온 리소스는 위험할 수 있으니 기본적으로 막자.”

그래서 JS 코드(axios 요청)가
“다른 출처” 서버에 요청을 보내고 응답을 받으면,

1. 서버는 200 OK로 응답을 줬지만
2. 브라우저는 **응답 헤더를 검사**
3. 서버가 “이 origin은 허용해도 돼” 라고 말하지 않으면
4. **CORS 에러를 띄우고 응답을 JS에게 전달하지 않는다**

즉, **CORS 에러는 백엔드 코드 에러가 아니라 “브라우저 보안 정책” 때문이다.**

---

## 4. CORS(Cross-Origin Resource Sharing)란?

SOP는 기본적으로 “다른 출처는 다 막자”라는 규칙이고,
그냥 두면 프론트-백엔드 분리 구조에서는 개발이 거의 불가능하다.

그래서 나온 개념이 **CORS**.

### 4-1. CORS의 핵심 아이디어

> 서버가 응답에
> `Access-Control-Allow-Origin` 같은 **특별한 헤더**를 넣어서
> “이 origin에서 오는 요청은 허용해도 돼”라고 브라우저에게 알려주는 것.

즉:

* SOP : “원래는 다 막는 게 기본”
* CORS: “그중에 얘네는 예외로 허용해 줘”

### 4-2. 흐름 정리

1. Vue 앱에서 DRF 서버로 AJAX 요청을 보낸다.
2. DRF 서버는 응답을 보낼 때 HTTP 헤더에
   `Access-Control-Allow-Origin: http://localhost:5173`
   를 포함해서 돌려준다.
3. 브라우저는 이 헤더를 보고:

   * 현재 페이지의 origin이 `http://localhost:5173`인지 확인
   * 같으면 → 응답을 JS 코드에게 넘겨준다.
   * 다르면 → CORS 에러로 막는다.

중요한 포인트:

* **CORS 설정은 항상 서버 쪽에서 한다.**
* 프론트는 “어디로 요청을 보낼지” 결정할 뿐,
  브라우저의 SOP/CORS 판단에는 개입할 수 없다.

---

## 5. Django에서 CORS 해결하기: django-cors-headers

Django/DRF에서 CORS를 쉽게 설정해 주는 라이브러리가
바로 `django-cors-headers`다.

### 5-1. 설치

```bash
pip install django-cors-headers
```

requirements.txt에도 추가.

### 5-2. settings.py 설정

```python
INSTALLED_APPS = [
    ...
    'corsheaders',
    ...
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    ...
]
```

그리고 **어떤 origin을 허용할지** 명시한다.

```python
CORS_ALLOWED_ORIGINS = [
    "http://localhost:5173",  # Vue dev 서버 주소
]
```

이제 DRF 서버는 `http://localhost:5173`에서 오는 요청에 대해
응답 헤더에 다음을 자동으로 붙여준다.

```http
Access-Control-Allow-Origin: http://localhost:5173
```

개발할 때는 편하게 이렇게도 쓸 수 있지만,
실서비스에는 추천하지 않는다:

```python
CORS_ALLOW_ALL_ORIGINS = True
```

### 5-3. CORS 해결 확인 방법

1. 브라우저에서 Vue 앱을 띄운다.
2. Vue에서 `getArticles()` 같은 axios 호출을 실행.
3. DevTools의 **Network 탭**에서 DRF 응답을 클릭해 Header를 보면
   `Access-Control-Allow-Origin` 이 설정되어 있는지 확인.
4. 더 이상 콘솔에 CORS 관련 에러가 뜨지 않고,
   실제로 `articles` 리스트가 화면에 잘 표시되면 성공.

---

## 6. CORS 해결 이후: CRUD 흐름 마저 정리

CORS를 해결한 뒤에는
기본적인 게시글 **조회 / 상세 / 작성**을 다음 순서로 구현한다.

### 6-1. 전체 게시글 조회

* `ArticleView` 화면 진입 → `onMounted`에서 `store.getArticles()` 호출
* store의 `getArticles` 액션은 DRF `/api/v1/articles/`로 GET 요청
* 응답 데이터를 `this.articles`에 저장 → 화면에서 `v-for`로 출력

### 6-2. 단일 게시글 조회

1. Router 설정

```js
{
  path: '/articles/:id',
  name: 'detail',
  component: DetailView,
}
```

2. `ArticleListItem`에서 상세 페이지로 이동

```html
<RouterLink :to="`/articles/${article.id}`">
  {{ article.title }}
</RouterLink>
```

3. `DetailView`에서 `useRoute`로 id 읽기

```js
import { useRoute } from 'vue-router'
import { useArticleStore } from '@/stores/articles'
import { onMounted } from 'vue'

const route = useRoute()
const store = useArticleStore()

onMounted(() => {
  store.getArticle(route.params.id)
})
```

4. store `getArticle` 액션

```js
async getArticle(id) {
  const res = await axios.get(`${BASE_URL}/api/v1/articles/${id}/`)
  this.selectedArticle = res.data
}
```

5. 템플릿에서는 `selectedArticle.title`, `selectedArticle.content` 표시

### 6-3. 게시글 작성 (Create)

1. Router에 `/create` 등록 후, 메뉴나 버튼에서 이동

```html
<RouterLink to="/create">글 작성</RouterLink>
```

2. `CreateView`에서 `v-model`로 제목, 내용 입력 받기

```vue
<script setup>
import { ref } from 'vue'
import { useArticleStore } from '@/stores/articles'
import { useRouter } from 'vue-router'

const title = ref('')
const content = ref('')
const store = useArticleStore()
const router = useRouter()

const onSubmit = async () => {
  await store.createArticle({ title: title.value, content: content.value })
  router.push('/articles')
}
</script>

<template>
  <form @submit.prevent="onSubmit">
    <input v-model="title" placeholder="제목" />
    <textarea v-model="content" placeholder="내용" />
    <button type="submit">작성</button>
  </form>
</template>
```

3. store `createArticle` 액션

```js
async createArticle(payload) {
  const res = await axios.post(`${BASE_URL}/api/v1/articles/`, payload)
  this.articles.push(res.data)
}
```

→ 이제 Vue에서 글을 작성하면 DRF 서버에 저장되고,
다시 목록을 조회하면 새 글이 포함된다.

---

## 7. “오늘 배운 핵심” 한 장 요약

> ### 1) 구조

* **백엔드(DRF)** : JSON API 제공 (Article 목록/상세/작성 등)
* **프론트(Vue)** : 화면 + 사용자 입력, 데이터를 axios로 DRF에 요청

> ### 2) 출처(origin)와 SOP

* origin = **프로토콜 + 호스트 + 포트**
* 브라우저는 **다른 origin** 간의 JS 접근을 기본적으로 막음 (SOP)
* 그래서 `localhost:5173`(Vue) → `127.0.0.1:8000`(DRF)는
  **cross-origin** 이고, 그냥 요청하면 CORS 에러가 난다.

> ### 3) CORS

* CORS = 서버가 “이 origin은 허용해도 돼” 라고 브라우저에 알려주는 장치
* 응답 헤더 `Access-Control-Allow-Origin` 으로 허용 origin 명시
* CORS 설정은 항상 **서버(Django)** 에서 한다.

> ### 4) django-cors-headers 설정

* `pip install django-cors-headers`
* `INSTALLED_APPS` + `MIDDLEWARE` 에 `corsheaders` 추가
* `CORS_ALLOWED_ORIGINS` 에 Vue dev 서버 주소 등록
* Network 탭에서 `Access-Control-Allow-Origin` 헤더 확인

> ### 5) 구현 흐름

* Pinia store에서 axios로 DRF API 호출
* `ArticleView`에서 `getArticles()` 실행 → 전체 조회
* Router + `useRoute`로 `/articles/:id` 처리 → 단일 조회
* `CreateView` + `v-model` + `axios.post` → 게시글 작성

---

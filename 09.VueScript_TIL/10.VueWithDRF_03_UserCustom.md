
---

# Vue + DRF 인증 & User 커스터마이징 개념 정리 (TIL)

## 0. 오늘 내용 한 줄 요약

> **DRF에서 토큰 기반 인증을 쓰고, Vue + Pinia로 토큰을 보관·사용하면서,
> dj-rest-auth의 회원가입 로직을 커스터마이징해서 User에 `age` 같은 필드를 추가하는 흐름 정리.**

---

## 1. 전체 구조 먼저 잡기

### 1) 백엔드(장고 + DRF + dj-rest-auth)

* `User` 모델

  * 기본 User를 상속해서 `age` 같은 **추가 필드**를 가진 커스텀 User로 사용
* `dj-rest-auth`

  * `/accounts/registration/` : 회원가입
  * `/accounts/login/` : 로그인 → Token 발급
  * `/accounts/logout/` : 로그아웃
* 커스텀 `RegisterSerializer`

  * 회원가입 시 추가 필드(`age`)를 같이 받도록 수정
* 토큰 기반 인증

  * DRF 설정에 `TokenAuthentication` 추가
  * 인증 필요한 API 에서는 `Authorization: Token <토큰>` 검증

### 2) 프론트(Vue + Pinia + Router)

* **Pinia store (`useAccountStore` 같은 이름)**

  * `token` 상태 관리
  * `isLogin` : `!!token` 으로 계산되는 computed
  * `signup`, `login`, `logout` 액션
* View 컴포넌트

  * `SignUpView` : 회원가입 폼
  * `LoginView` : 로그인 폼
* Router

  * `/signup`, `/login` 등 라우트 정의
  * Navigation Guard(`beforeEach`)로

    * 로그인 안 한 사람은 특정 페이지 접근 막고
    * 이미 로그인한 사람은 `/login`, `/signup` 못 가게 막기
* 인증이 필요한 API 호출

  * `getArticles`, `createArticle` 등에서
    store의 `token`을 읽어서 `Authorization` 헤더에 붙이기

---

## 2. 회원가입(SignUp) 흐름 개념 정리

### 2-1. Vue Router에 `/signup` 라우트 추가

```js
// router/index.js
import SignUpView from '@/views/SignUpView.vue'

const routes = [
  {
    path: '/signup',
    name: 'signup',
    component: SignUpView,
  },
  // ...
]
```

* 사용자는 `/signup` 으로 들어가서 회원가입 폼을 본다.
* App 상단 메뉴에서 `RouterLink`로 이동 버튼을 만들어 둔다.

### 2-2. SignUpView 폼 구성

```vue
<template>
  <div>
    <h1>Sign Up Page</h1>
    <form @submit.prevent="onSubmit">
      <label>username</label>
      <input v-model="username" />
      <label>password</label>
      <input v-model="password1" type="password" />
      <label>password confirmation</label>
      <input v-model="password2" type="password" />
      <!-- User 커스텀 후에는 age 같은 필드도 추가 -->
      <button type="submit">signup</button>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useAccountStore } from '@/stores/accounts'

const username = ref('')
const password1 = ref('')
const password2 = ref('')
// age 추가 후에는 const age = ref('') 같은 것 추가

const accountStore = useAccountStore()

const onSubmit = () => {
  accountStore.signup({
    username: username.value,
    password1: password1.value,
    password2: password2.value,
    // age: age.value
  })
}
</script>
```

* 폼에서 입력 받은 값을 **Pinia store의 `signup` 액션으로 넘긴다.**

### 2-3. Pinia store의 `signup` 액션 개념

```js
// stores/accounts.js
import { defineStore } from 'pinia'
import axios from 'axios'

const BASE_URL = 'http://127.0.0.1:8000'

export const useAccountStore = defineStore('account', {
  state: () => ({
    token: null,
  }),
  actions: {
    async signup(payload) {
      try {
        const res = await axios.post(
          `${BASE_URL}/accounts/registration/`,
          payload
        )
        console.log('회원가입 성공', res.data)
        // 필요하면 여기서 바로 login까지 연결 가능 (아래에서 설명)
      } catch (error) {
        console.error(error)
      }
    },
  },
  persist: true, // pinia-plugin-persistedstate 로 새로고침해도 토큰 유지
})
```

* `payload` 형식은 dj-rest-auth의 `RegisterSerializer`가 기대하는 필드랑 일치해야 한다.
* **회원가입 성공** 시에는 DB에 User가 생성되지만
  토큰까지 같이 발급받는 구조인지, 아니면 회원가입만 하고 로그인은 따로인지는 설정에 따라 다르다
  (여기서는 보통 “회원가입 → 로그인 별도” 흐름을 사용).

---

## 3. 로그인(Login) & 토큰 저장

### 3-1. LoginView 구성

```js
// router/index.js
import LoginView from '@/views/LoginView.vue'

{
  path: '/login',
  name: 'login',
  component: LoginView,
}
```

`LoginView.vue` 예시:

```vue
<template>
  <div>
    <h1>Login Page</h1>
    <form @submit.prevent="onSubmit">
      <label>username</label>
      <input v-model="username" />
      <label>password</label>
      <input v-model="password" type="password" />
      <button type="submit">login</button>
    </form>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useAccountStore } from '@/stores/accounts'

const username = ref('')
const password = ref('')
const accountStore = useAccountStore()

const onSubmit = () => {
  accountStore.login({
    username: username.value,
    password: password.value,
  })
}
</script>
```

### 3-2. Pinia store의 `login` 액션

```js
actions: {
  async login(payload) {
    try {
      const res = await axios.post(
        `${BASE_URL}/accounts/login/`,
        payload
      )
      // dj-rest-auth 기본 응답: { key: '토큰값' }
      this.token = res.data.key
      console.log('로그인 성공, token:', this.token)
    } catch (error) {
      console.error('로그인 실패', error)
    }
  },
}
```

* 로그인 성공 시 **서버가 토큰을 발급해 주고**,
  store에서 `this.token`으로 저장한다.
* `persist: true` 옵션 덕분에 **새로고침해도 token 유지**.

### 3-3. 토큰이 필요한 API 요청에 붙이는 방식

토큰은 요청 헤더에 이렇게 보내야 한다:

```http
Authorization: Token <발급받은 토큰>
```

Pinia의 다른 액션에서 예시:

```js
import { useAccountStore } from './accounts'

export const useArticleStore = defineStore('article', {
  state: () => ({
    articles: [],
  }),
  actions: {
    async getArticles() {
      const accountStore = useAccountStore()
      const res = await axios.get(`${BASE_URL}/api/v1/articles/`, {
        headers: {
          Authorization: `Token ${accountStore.token}`,
        },
      })
      this.articles = res.data
    },

    async createArticle(payload) {
      const accountStore = useAccountStore()
      const res = await axios.post(
        `${BASE_URL}/api/v1/articles/`,
        payload,
        {
          headers: {
            Authorization: `Token ${accountStore.token}`,
          },
        }
      )
      this.articles.push(res.data)
    },
  },
})
```

* 이제 **로그인 안 하면 token이 없어서 요청이 실패**하고,
* 로그인 후에는 token을 가지고 있기 때문에 인증된 요청이 가능해진다.

---

## 4. “로그인 여부” 상태와 Navigation Guard

### 4-1. isLogin computed 만들기

store 안에서 토큰 유무로 로그인 여부를 계산한다:

```js
export const useAccountStore = defineStore('account', {
  state: () => ({
    token: null,
  }),
  getters: {
    isLogin(state) {
      return state.token ? true : false
    },
  },
  // 또는 setup 스타일이면 computed 사용
})
```

이제 어디서든 `accountStore.isLogin`으로 로그인 여부를 쓸 수 있다.

### 4-2. 헤더에서 로그인/로그아웃 버튼 제어

```vue
<template>
  <header>
    <RouterLink to="/articles">Articles</RouterLink>

    <template v-if="!accountStore.isLogin">
      <RouterLink to="/signup">SignUpPage</RouterLink>
      <RouterLink to="/login">LoginPage</RouterLink>
    </template>

    <template v-else>
      <span>{{ username }}님 환영합니다</span>
      <button @click="onLogout">logout</button>
    </template>
  </header>
</template>

<script setup>
import { useAccountStore } from '@/stores/accounts'
import { useRouter } from 'vue-router'

const accountStore = useAccountStore()
const router = useRouter()

const onLogout = () => {
  accountStore.logout()
  router.push({ name: 'login' })
}
</script>
```

### 4-3. Navigation Guard로 “페이지 접근 제한”

#### 1) 로그인 안 한 사용자는 못 들어가게

예: `/create` 는 인증된 사용자만 접근 가능하도록

```js
// router/index.js
import { useAccountStore } from '@/stores/accounts'

router.beforeEach((to, from) => {
  const accountStore = useAccountStore()

  // 특정 라우트에 meta.requiresAuth 설정했다고 가정
  if (to.meta.requiresAuth && !accountStore.isLogin) {
    // 로그인 안 된 상태 → 로그인 페이지로 보냄
    return { name: 'login' }
  }
})
```

라우트 정의:

```js
{
  path: '/create',
  name: 'article-create',
  component: CreateView,
  meta: { requiresAuth: true },
}
```

#### 2) 이미 로그인한 사용자는 `/login`, `/signup` 못 가게

```js
router.beforeEach((to, from) => {
  const accountStore = useAccountStore()

  if (
    (to.name === 'login' || to.name === 'signup') &&
    accountStore.isLogin
  ) {
    // 이미 로그인한 상태면 글 목록 페이지 등으로 보냄
    return { name: 'articles' }
  }
})
```

이렇게 하면

* **로그인 안 한 상태** : 보호된 페이지 접근 → 강제 로그인 페이지
* **이미 로그인 된 상태** : 로그인/회원가입 페이지 접근 → 메인 페이지로 리다이렉트

---

## 5. User 모델 커스터마이징 – `age` 필드 추가

이제 **User 모델에 나이(age)를 넣는 작업**을 한다.

### 5-1. User 모델에 필드 추가

`accounts/models.py` (예시) :

```python
from django.contrib.auth.models import AbstractUser
from django.db import models

class User(AbstractUser):
    age = models.PositiveIntegerField(null=True, blank=True)
```

* `AbstractUser`를 상속해서 커스텀 User를 사용한다는 전제.
* `PositiveIntegerField` : 0 이상의 정수
* `null=True, blank=True` 로 선택 입력 가능

`settings.py` 에

```python
AUTH_USER_MODEL = 'accounts.User'
```

이미 되어 있어야 한다.

### 5-2. 마이그레이션

```bash
python manage.py makemigrations
python manage.py migrate
```

DB에 `accounts_user` 테이블에 `age` 컬럼이 추가된다.

---

## 6. Vue 쪽 회원가입 폼에 age 추가

`SignUpView.vue` 수정:

```vue
<input v-model="age" type="number" />

// ...
const age = ref(null)

const onSubmit = () => {
  accountStore.signup({
    username: username.value,
    password1: password1.value,
    password2: password2.value,
    age: age.value,
  })
}
```

이제 Vue는 `age` 값도 백엔드로 보내고 싶다.
하지만 dj-rest-auth의 기본 `RegisterSerializer`에는 `age` 필드가 없다.
→ **RegisterSerializer를 커스터마이징**해야 한다.

---

## 7. dj-rest-auth RegisterSerializer 커스터마이징

### 7-1. CustomRegisterSerializer 만들기

`accounts/serializers.py`:

```python
from dj_rest_auth.registration.serializers import RegisterSerializer
from rest_framework import serializers

class CustomRegisterSerializer(RegisterSerializer):
    # 추가로 받을 필드 정의
    age = serializers.IntegerField(required=False)

    def get_cleaned_data(self):
        # 기존 필드 + age를 포함해서 반환
        data = super().get_cleaned_data()
        data['age'] = self.validated_data.get('age', None)
        return data

    def save(self, request):
        # 기본 저장 로직 먼저 실행 (username, email, password 등)
        user = super().save(request)
        # 추가 필드 저장
        user.age = self.cleaned_data.get('age')
        user.save()
        return user
```

핵심 아이디어:

1. **필드 선언** : `age = serializers.IntegerField()`
2. `get_cleaned_data` 오버라이드
   → 기본 RegisterSerializer가 사용하던 `cleaned_data` 딕셔너리에 `age` 도 포함
3. `save` 오버라이드
   → `super().save()`로 기본 저장 로직 실행 후,
   반환된 user에 `age` 값을 넣고 `user.save()` 한 번 더

### 7-2. settings.py에 등록

```python
# settings.py
REST_AUTH_REGISTER_SERIALIZERS = {
    'REGISTER_SERIALIZER': 'accounts.serializers.CustomRegisterSerializer',
}
```

이제 `/accounts/registration/` 엔드포인트는
기본 RegisterSerializer 대신 **CustomRegisterSerializer**를 사용한다.

### 7-3. 결과

* Vue의 회원가입 폼에서 `age`를 입력해서 전송
* CustomRegisterSerializer가 `age`를 받아 검증 후
* 새로 만들어지는 User row에 `age`까지 함께 저장

---

## 8. 로그아웃 구현

Pinia store에 `logout` 액션 추가:

```js
actions: {
  logout() {
    this.token = null
  },
}
```

* `persist: true` 때문에 localStorage에도 저장되는데,
  이 라이브러리는 state가 바뀌면 자동으로 로컬스토리지를 갱신해 준다.
  → `token = null`이면 로컬스토리지에서도 null로 바뀜.

App 헤더에서 버튼 클릭 시:

```vue
<button @click="onLogout">logout</button>
```

`onLogout`에서:

```js
const onLogout = () => {
  accountStore.logout()
  router.push({ name: 'login' })
}
```

추가로 백엔드 `/accounts/logout/` API를 부르고 싶다면,
store.logout 안에서 axios.post로 호출한 뒤 token을 비워도 된다.

---

## 9. 회원가입 성공 후 자동 로그인 연결 (선택)

회원가입 후 바로 로그인까지 시키고 싶다면:

```js
// stores/accounts.js
actions: {
  async signup(payload) {
    await axios.post(`${BASE_URL}/accounts/registration/`, payload)
    // 회원가입 후, 곧바로 login 액션 호출
    await this.login({
      username: payload.username,
      password: payload.password1,
    })
  },
}
```

또는 `SignUpView`에서 회원가입 성공 후 `router.push({ name: 'login' })` 으로 보내는 방식도 가능.

---

## 10. Django Signals & 환경변수(간단 개념)

### 10-1. Django Signals (간단 개념만)

> **특정 이벤트(예: User가 생성될 때, 저장될 때)가 발생했을 때,
> 자동으로 호출되는 콜백 함수를 등록하는 기능**

* 예:

  * User가 생성되면 자동으로 Profile 객체도 만드는 signal
  * 회원가입 시 환영 메일 보내기
* 이번 자료에서는 “이런 것도 있다” 정도로만 등장.

### 10-2. 환경변수(Environment Variable)

> **코드에 직접 쓰기 민감한 값(비밀번호, API KEY, SECRET KEY 등)을
> .env 파일이나 OS 환경변수에 두고 사용하는 방식**

* 장점

  * 깃에 올려도 민감 정보가 유출되지 않는다.
  * 개발/운영 환경마다 다른 값을 쓸 수 있다.
* Vite에서:

  * `.env` 파일에 `VITE_` prefix를 붙여 변수를 만들고
  * `import.meta.env.VITE_SOMETHING` 으로 접근

예:

```env
VITE_API_URL=http://127.0.0.1:8000
```

```js
const BASE_URL = import.meta.env.VITE_API_URL
```

---

## 11. 오늘 전체 흐름 다시 한 번 정리

1. **로그인/회원가입 API 준비 (dj-rest-auth)**

   * `/accounts/registration/`, `/accounts/login/`
   * DRF TokenAuthentication 설정

2. **Vue + Pinia에서 회원가입 / 로그인 구현**

   * SignUpView, LoginView 폼
   * `signup`, `login` 액션에서 axios로 DRF와 통신
   * 로그인 성공 시 token을 store에 저장 (`persist: true`)

3. **요청에 토큰 붙여서 인증된 요청 보내기**

   * `Authorization: Token <token>` 헤더
   * 게시글 목록/생성 API에서 store.token 읽어서 헤더에 추가

4. **로그인 여부에 따른 UI & 라우팅 제어**

   * `isLogin = !!token`
   * 헤더에서 로그인/로그아웃 버튼 표시 분기
   * Navigation Guard로

     * 비로그인 사용자의 보호 페이지 접근 막기
     * 로그인 사용자의 `/login`, `/signup` 접근 막기

5. **User 커스터마이징 (age 필드 추가)**

   * User 모델에 `age` 필드 추가 → makemigrations/migrate
   * Vue 회원가입 폼에 `age` 입력 추가
   * `CustomRegisterSerializer` 작성 + settings에 등록
   * 이제 회원가입 시 age까지 함께 저장

6. **로그아웃 & 추가 기능**

   * store.logout으로 token 삭제
   * 회원가입 후 자동 로그인, 특정 페이지로 자동 이동 등은
     `router.push`와 store 액션을 적절히 조합해서 구현

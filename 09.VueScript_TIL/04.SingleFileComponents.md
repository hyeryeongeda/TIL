# 📌 Vue Single-File Component(SFC) & 프로젝트 구조 정리 (TIL)

오늘은 **Vue Single-File Component(SFC)** 개념이랑
Vite로 만든 Vue 프로젝트 구조, npm / 모듈 / 번들러,
Virtual DOM, Composition API vs Option API까지 한 번에 정리해봤다.

---

## 1. 컴포넌트(Component) 개념부터 잡기

### 1) 컴포넌트가 왜 필요한가?

일단 Vue에서 화면은 **컴포넌트 단위**로 쪼개서 관리한다.

* 하나의 페이지는 여러 개의 컴포넌트로 이루어짐

  * 예: 상단 네비게이션바, 왼쪽 메뉴, 메인 콘텐츠, 댓글 영역 등
* **UI를 재사용 가능한 단위로 쪼개서** 각각 독립적으로 개발/관리할 수 있음
* 각각의 컴포넌트는

  * 자기 템플릿(template)
  * 자기 로직(script)
  * 자기 스타일(style)
    을 가진 **작은 화면 조각**이라고 보면 된다.

즉,

> “큰 웹 서비스를 작게 쪼갠 조립 부품들 = 컴포넌트”

---

## 2. Single-File Component(SFC)란?

### 1) 정의

> **SFC = 하나의 `.vue` 파일 안에
> `template` + `script` + `style`를 모두 담은 파일**

즉, 하나의 UI 조각(컴포넌트)을
**한 파일 안에 템플릿, 로직, 스타일까지** 같이 모아둔 것.

### 2) SFC 구조 예시

```vue
<!-- MyComponent.vue -->
<template>
  <div class="box">
    <h1>{{ msg }}</h1>
  </div>
</template>

<script setup>
const msg = 'Hello SFC!'
</script>

<style scoped>
.box {
  color: red;
}
</style>
```

* `<template>` : 화면에 어떻게 보일지(HTML 구조)
* `<script setup>` : 데이터/함수/이벤트 등 로직
* `<style scoped>` : 이 컴포넌트에만 적용되는 CSS

이 세 개를 **한 파일 안에** 묶어놓으니까

* 관련 코드가 흩어지지 않고
* 컴포넌트 단위로 찾기/수정하기 쉬움
* 재사용, 삭제, 이동이 훨씬 편해진다.

---

## 3. SFC 구성 요소 자세히

### 3-1. `<template>` 블록

* **필수**는 아니지만 보통 하나 만든다.
* 화면에 렌더링되는 **HTML 구조**를 정의하는 부분.

```vue
<template>
  <div>
    <p>{{ greeting }} {{ name }}</p>
  </div>
</template>
```

* `{{ }}` 안에 JS 표현식(주로 데이터)을 쓸 수 있다.
* Vue에서는 이 템플릿을 최종적으로 **Virtual DOM → 실제 DOM**으로 렌더링한다.

### 3-2. `<script setup>` 블록

* 컴포넌트의 로직을 담당하는 부분.
* Vue 3 기준 **가장 권장되는 방식**이 `script setup` 문법.

```vue
<script setup>
import { ref } from 'vue'

const name = ref('Vue')
const greeting = ref('Hello')

const changeName = () => {
  name.value = 'SFC'
}
</script>
```

* `ref`, `computed`, `onMounted` 같은 Composition API를 여기서 사용
* `setup()` 함수 안에서 할 일을 **더 간단한 문법으로 풀어쓴 느낌**

### 3-3. `<style>` / `<style scoped>`

* 해당 컴포넌트의 스타일을 작성하는 부분.

```vue
<style>
.box {
  color: red;
}
</style>
```

* 이렇게 쓰면 **전역 CSS**처럼 동작해서 같은 클래스 이름을 가진 다른 컴포넌트에도 영향을 줄 수 있음.

```vue
<style scoped>
.box {
  color: red;
}
</style>
```

* `scoped`를 붙이면

  * 이 컴포넌트 내부에 한해서만 스타일이 적용되도록
  * Vue가 자동으로 클래스에 고유한 data-속성을 붙여서 범위를 제한한다.
* 즉, **“이 컴포넌트에만 스타일을 가둬서”** 스타일 충돌을 막는 기능.

---

## 4. Vite & Vue 프로젝트 생성 흐름

### 4-1. Vite가 하는 일

> **Vite = 빠른 개발 서버 + 빌드 도구**

* 개발 중에

  * 코드 수정 → 브라우저 자동 새로고침 / HMR(Hot Module Replacement)
  * ES Module 기반으로 매우 빠른 반응
* 빌드할 때

  * 소스 코드를 번들링하여(묶어서)
  * 실제 배포용 정적 파일로 만들어줌

### 4-2. 프로젝트 생성 명령

```bash
npm create vite@latest
# 또는
npm create vue@latest  (Vue 공식 템플릿)
```

프롬프트 흐름:

1. 프로젝트 이름 입력
2. 프레임워크 선택 → Vue
3. Variant 선택 → JavaScript or TypeScript
4. 패키지 설치 여부 → 보통 npm 선택
5. 완료 후

   ```bash
   cd 프로젝트이름
   npm install
   npm run dev
   ```

---

## 5. Node, npm, 모듈, 번들러 개념

### 5-1. Node.js

* 크롬 V8 엔진을 브라우저 밖에서 돌릴 수 있게 만든 런타임
* 덕분에 **자바스크립트를 서버/터미널에서도 실행 가능**

### 5-2. npm (Node Package Manager)

> **npm = Node.js용 패키지(라이브러리) 관리 도구**

* `npm install 패키지명` 으로 라이브러리 설치
* `package.json`에 의존성 기록
* 다른 개발자는 `npm install`만 하면 동일한 환경 다시 구축 가능

### 5-3. 모듈(Module)

> **모듈 = 각각 독립된 JS 파일(기능 단위 블록)**

* 파일마다 export/import로 서로 기능을 주고받는다.
* “모듈” 개념 덕분에 코드가 파일 단위로 잘 쪼개질 수 있다.

### 5-4. 번들러(Bundler)

> 여러 JS 모듈, CSS, 이미지 등을 **하나(or 소수)의 파일로 묶어주는 도구**

* 예: Vite, Webpack, Parcel 등
* 이유:

  * 브라우저가 너무 많은 파일을 하나씩 요청하면 느려짐
  * 의존성 관계를 자동으로 따라가서 적절히 묶어주는 게 번들러의 역할

---

## 6. Vue 프로젝트 기본 구조 뜯어보기

### (1) public 디렉터리

* 빌드 시 **그대로 복사**되는 정적 파일들

  * 파비콘, 고정된 이미지 등
* `/public/xxx.png`는 최종 빌드에서 루트 경로로 복사된다.

### (2) src 디렉터리 – 우리가 메인으로 만지는 곳

`src` 안에는 보통 이런 것들이 있다.

1. `assets/`

   * 이미지, 폰트, 공통 CSS 등
   * JS에서 `import`해서 쓰는 정적 자원들

2. `components/`

   * 재사용 가능한 Vue 컴포넌트들
   * 예: `MyComponent.vue`, `Navbar.vue`, `TodoItem.vue` …

3. `App.vue`

   * 최상위(root) 컴포넌트
   * 다른 모든 컴포넌트를 품고 있는 “앱의 뼈대” 역할

4. `main.js`

   * Vue 앱을 생성해서 실제 DOM에 마운트하는 진입 파일

### (3) main.js 흐름

```js
import { createApp } from 'vue'
import App from './App.vue'

createApp(App).mount('#app')
```

* `#app`은 `index.html` 안의 `<div id="app"></div>`를 가리킴
* 즉,

  * index.html → 껍데기
  * main.js → Vue 앱을 올리는 스위치
  * App.vue → Vue 컴포넌트 트리의 시작점

### (4) index.html

* 실제로 브라우저가 처음 로딩하는 HTML 파일
* 여기서 `<div id="app"></div>` 만 있고
* Vue 앱은 main.js가 실행되면서 이 안에 들어간다.

---

## 7. 패키지 관리 파일들: package.json, package-lock.json, node_modules

### 7-1. package.json

> “이 프로젝트의 기본 정보 + 어떤 라이브러리를 쓰는지”를 정리해 둔 파일

* 프로젝트 이름, 버전, 스크립트, 의존성 목록 등
* 중요한 항목:

```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "vue": "^3.5.0",
    "pinia": "^2.x",
    ...
  },
  "devDependencies": {
    "vite": "^5.x",
    ...
  }
}
```

* `dependencies` : 실제 실행 시 필요한 라이브러리
* `devDependencies` : 개발 과정에서만 필요한 라이브러리(예: vite, eslint)

### 7-2. package-lock.json

* 정확하게 **“어떤 버전”의 패키지가 설치되었는지**를 기록한 파일
* 팀원들 간에 패키지 버전 차이로 인한 오류를 줄여줌
* `npm install` 시 이 파일을 보고 동일한 버전을 설치

### 7-3. node_modules

* 실제로 라이브러리 파일들이 저장되는 폴더
* 용량이 매우 크다. (git에 올리지 않음)
* 삭제해도 package.json / package-lock.json 만 있으면

  * `npm install`로 다시 재생성 가능

> 정리
>
> * `package.json` : “이 프로젝트는 vue 3가 필요해요”
> * `package-lock.json` : “실제로는 vue 3.5.2, pinia 2.1.7을 설치했어요”
> * `node_modules` : 그 실제 코드 파일들

---

## 8. 컴포넌트 직접 만들어 등록하기

### 8-1. 컴포넌트 파일 생성

예: `src/components/MyComponent.vue`

```vue
<template>
  <h2>My Component</h2>
</template>

<script setup>
</script>
```

### 8-2. App.vue에서 등록해서 사용

```vue
<!-- App.vue -->
<template>
  <div>
    <h1>App Root</h1>
    <MyComponent />
  </div>
</template>

<script setup>
import MyComponent from '@/components/MyComponent.vue'
</script>
```

* `import`로 가져와서
* 템플릿에서 `<MyComponent />`로 사용
* 이제 Vue devtools에서 컴포넌트 트리에서 `MyComponent`가 자식으로 보인다.

---

## 9. Virtual DOM 개념

### 9-1. Vanilla JS에서 DOM 조작의 문제

보통 순수 JS로 DOM 조작을 하면:

```js
const el = document.querySelector('#app')
el.textContent = 'Hello'
```

* DOM은 실제 브라우저 렌더 트리라서

  * 자주, 많이 바꾸면 **비용이 크다**.
* 큰 화면에서 부분만 바꿔야 할 때

  * 어디가 바뀌었는지 직접 비교하고, find, remove, append… 해야 함

Vue는 이런 저수준 DOM 조작을 우리가 직접 하지 않도록 설계되어 있다.

### 9-2. Virtual DOM이란?

> **Virtual DOM = 실제 DOM의 가벼운 복사본(자바스크립트 객체 트리)**

* 렌더링 과정:

  1. 현재 상태로부터 Virtual DOM 트리를 만든다.
  2. 상태가 바뀌면 새로운 Virtual DOM 트리를 만든다.
  3. 이전 트리와 새로운 트리를 비교(diff)해서
  4. 달라진 부분만 실제 DOM에 반영한다.

### 9-3. 장점

1. **효율성**

   * 전체 DOM을 갈아엎지 않고 **변경된 부분만** 업데이트
2. **추상화**

   * 개발자는 `template`만 선언하면 되고,
   * DOM 조작은 Vue가 알아서 해줌
3. **코드 가독성**

   * “상태 → UI” 관계를 선언적으로 작성할 수 있다.

### 9-4. Virtual DOM 쓸 때 주의할 점

* `document.querySelector`, `createElement`로 직접 DOM 조작을 많이 하면

  * Vue가 관리하는 Virtual DOM과 실제 DOM 사이에 불일치가 생길 수 있다.
* DOM에 직접 접근해야 할 때는

  * `ref`를 사용하거나
  * Vue의 lifecycle hook을 적절히 사용해야 한다는 점을 기억.

---

## 10. Composition API vs Option API 간단 비교

### 10-1. Option API

```vue
<script>
export default {
  data() {
    return {
      msg: 'Hello',
    }
  },
  methods: {
    sayHi() {
      console.log(this.msg)
    },
  },
  mounted() {
    this.sayHi()
  },
}
</script>
```

* `data`, `methods`, `computed`, `mounted` 등

  * **옵션 이름으로 로직을 분리**하는 스타일
* Vue 2에서 기본이었고, Vue 3에서도 여전히 지원된다.

### 10-2. Composition API (`<script setup>`)

```vue
<script setup>
import { ref, onMounted } from 'vue'

const msg = ref('Hello')

const sayHi = () => {
  console.log(msg.value)
}

onMounted(() => {
  sayHi()
})
</script>
```

* 관련 있는 로직들을 함수/변수 기준으로 **한 덩어리로 묶기 쉽다.**
* 타입스크립트, 재사용 composable 함수 작성에 유리
* Vue 3에서는 이 스타일을 공식적으로 추천

둘 다 쓸 수 있지만,
새로 시작하는 프로젝트라면 Composition API + `<script setup>` 이 일반적.

---

## 11. Single Root Element 규칙

Vue SFC의 `<template>` 안에는 **최상위 요소가 하나만 있어야** 한다.

```vue
<!-- ❌ 잘못된 예 -->
<template>
  <h1>Title</h1>
  <p>내용</p>
</template>
```

```vue
<!-- ✅ 올바른 예 -->
<template>
  <div>
    <h1>Title</h1>
    <p>내용</p>
  </div>
</template>
```

* 이렇게 `<div>`, `<section>`, `<main>` 같은 태그로 감싸서

  * “Single Root Element”를 만들어줘야 한다.
* 이유:

  * Virtual DOM 트리 구조가 명확해지고
  * 최상위 노드 하나로 컴포넌트를 대표시키기 위함.

(Vue 3에서는 `<template>` 내 여러 root를 지원하긴 하지만,
강의/실습에서는 주로 단일 root 패턴을 사용한다는 느낌으로 이해하면 된다.)

---

## 12. CSS scoped 정리

**문제**

* 전역 CSS로 스타일을 작성하면

  * 여러 컴포넌트에서 같은 클래스명을 사용할 때 충돌할 수 있음.

**해결**

* `<style scoped>`를 사용하면

  * 해당 컴포넌트의 HTML에 자동으로 고유 속성이 붙어서
  * 스타일이 컴포넌트 내부에만 적용된다.

```vue
<template>
  <p class="text">안녕</p>
</template>

<style scoped>
.text {
  color: red;
}
</style>
```

* 다른 컴포넌트에서 `.text { color: blue }`를 scoped로 써도 서로 영향을 안 준다.
* **UI가 많은 프로젝트일수록 scoped 스타일은 거의 필수에 가깝다.**

---

## 13. 오늘 핵심 정리 (진짜 한 장 요약)

1. **SFC (.vue 파일)**

   * `template` + `script` + `style`를 한 파일에 모은 컴포넌트 단위
   * 관리/재사용이 편하고, Vue 3의 기본 개발 방식

2. **Vite & 프로젝트 구조**

   * `npm create vite@latest` 로 프로젝트 생성
   * `src/` : 우리가 코딩하는 곳

     * `assets/`, `components/`, `App.vue`, `main.js`
   * `public/` : 그대로 복사되는 정적 파일
   * `package.json`, `package-lock.json`, `node_modules` 로 패키지 관리

3. **컴포넌트 등록**

   * `components/`에 `.vue` 파일 생성
   * `App.vue` 등에서 `import` 후 `<MyComponent />`로 사용

4. **Virtual DOM**

   * 실제 DOM 대신 가벼운 객체 트리로 한 번 계산
   * 이전/이후 차이를 비교해 변경된 부분만 실제 DOM에 반영
   * 개발자는 DOM 직접 만지지 않고 template만 작성

5. **Composition API vs Option API**

   * Option: `data/methods/mounted` 등 옵션으로 나누는 방식
   * Composition: `ref`, `onMounted` 등 함수 기반, `<script setup>` 형태
   * Vue 3에서는 Composition API를 추천

6. **Single Root Element & scoped CSS**

   * `<template>` 안에는 최상위 요소 하나 (보통 `<div>`)
   * `<style scoped>` 로 컴포넌트별 CSS 범위를 제한해서 스타일 충돌 방지

---

이걸 바탕으로 앞으로는

* “지금 고치고 싶은 UI 조각이 어느 컴포넌트인지”
* “그 컴포넌트 파일 안에서 template / script / style이 어떻게 연결되어 있는지”
* “프로젝트 구조에서 어떤 파일을 건드려야 하는지”

를 훨씬 더 자신 있게 파악할 수 있을 것 같다.
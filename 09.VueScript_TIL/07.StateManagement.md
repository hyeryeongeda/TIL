## 1. 왜 상태 관리가 필요해? (단방향 데이터 흐름의 한계)

### 1-1. 기본 Vue 구조 복습

* Vue 앱은 보통 이렇게 생각할 수 있어:

  * **State(상태)**: 실제 데이터
  * **View(화면)**: 템플릿에 그려지는 모습
  * **Action(동작)**: 사용자의 입력, 클릭 등으로 상태를 바꾸는 함수들

→ Vue는 원래 “**단방향 데이터 흐름**”을 권장해.
부모 → 자식으로는 `props`, 자식 → 부모로는 `emit` 으로만 데이터를 주고받는 구조.

---

### 1-2. 언제까지는 props/emit으로도 괜찮음

초반에는 구조가 단순해서 이렇게만 해도 충분해:

```text
App
 └─ Child
     └─ GrandChild
```

* 부모 → 자식: `props`로 값 내려주기
* 자식 → 부모: `emit`으로 이벤트 올리기

구조가 얕고, 공유해야 하는 데이터가 많지 않으면 괜찮아.

---

### 1-3. 그런데 규모가 커지면 문제가 터진다

#### 문제 1. 컴포넌트 깊이가 깊어질 때

* 최상단 App의 데이터를 맨 아래 컴포넌트까지 보내야 할 때
* 중간 단계 컴포넌트는 그 데이터를 **직접 쓰지도 않는데** `props`로 계속 전달만 해야 함 (이걸 **props drilling**이라고 부름)

```text
App (실제 데이터 있음)
 └─ A (안 씀, 그냥 props 전달만)
     └─ B (조금 씀)
         └─ C (진짜 필요한 곳)
```

→ 중간 컴포넌트들이 다 `props`를 받아야 해서 코드가 지저분해지고, 리팩토링도 어려워짐.

#### 문제 2. 형제/멀리 떨어진 컴포넌트끼리 상태를 공유해야 할 때

예를 들어:

```text
Parent
 ├─ SearchForm       <- 검색어 입력
 └─ SearchResultList <- 검색 결과 출력
```

* `SearchForm`에서 입력한 값을 `SearchResultList`에서도 쓰고 싶을 때
* 원칙적으로는 `Parent`가 상태를 들고 있고, 두 컴포넌트는 `props/emit`으로만 연결해야 함
* 이런 구조가 페이지 여러 곳에서 반복되면 상태 이동 경로를 따라가기가 매우 힘들어짐

➡ 이런 상황에서 **“공통 저장소(store)”**가 필요해진다.
모든 컴포넌트가 같은 저장소를 바라보면서 상태를 공유하는 방식이 **상태 관리 라이브러리**의 역할이야.

---

## 2. Pinia란?

> **Pinia = Vue 공식 상태 관리 라이브러리**

* Vue 3 기준으로 **공식** 추천 상태 관리 도구
* 예전에는 Vuex를 많이 썼지만, 요즘은 **Pinia가 표준**이라고 보면 됨.
* 특징

  * 타입스크립트 친화적
  * 문법 단순
  * Composition API와 잘 어울림
  * Devtools 지원, 플러그인 시스템 제공

---

### 2-1. Pinia 설치 & 기본 세팅 흐름

1. **패키지 설치**

   ```bash
   npm install pinia
   ```

2. **main.js에서 전역으로 등록**

   ```js
   import { createPinia } from 'pinia'
   import { createApp } from 'vue'
   import App from './App.vue'

   const app = createApp(App)
   const pinia = createPinia()
   app.use(pinia)
   app.mount('#app')
   ```

→ 이렇게 하면 **어떤 컴포넌트에서도 store를 불러다 쓸 수 있는 환경**이 준비된다.

---

## 3. Pinia 핵심 구성요소 정리

Pinia는 결국 **store** 안에 **state / getters / actions**를 묶어둔 구조야.

---

### 3-1. store

> “어떤 주제의 상태와 관련 로직을 모아둔 저장소”

* 보통 `src/stores` 폴더 안에 파일을 만든다.
* **`defineStore()`** 함수로 store를 정의하고,
* 보통 `useSomethingStore` 같이 **use + 이름 + Store** 패턴으로 이름을 짓는다.

```js
// src/stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  // 여기 안에 state, getters, actions를 정의
})
```

* `'counter'` : 이 store의 고유 id (devtools에서 보일 이름이기도 함)

---

### 3-2. state

> “실제 데이터가 들어가는 곳 (반응형)”

* 컴포지션 API 스타일에서는 **`state: () => ({ ...초기값 })`** 형태로 작성
* 항상 **함수 형태**로 리턴해줘야 컴포넌트마다 독립적인 상태 인스턴스를 가질 수 있음

```js
export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0,
    todos: [
      { id: 1, text: '할 일1', isDone: false }
    ],
  }),
})
```

* 컴포넌트에서 사용할 때

```js
const counterStore = useCounterStore()
console.log(counterStore.count) // state 접근
```

---

### 3-3. getters

> “state 기반으로 계산된 값 (computed 같은 역할)”

* `state`를 이용해서 새로운 값을 **읽기 전용으로** 만들어주는 친구
* 컴포넌트마다 같은 계산을 반복하고 싶지 않을 때 사용

```js
getters: {
  doubleCount: (state) => state.count * 2,
  doneTodos: (state) => state.todos.filter(todo => todo.isDone),
  doneTodosCount() {
    return this.todos.filter(todo => todo.isDone).length
  },
}
```

* 사용 예시

```js
const counterStore = useCounterStore()
console.log(counterStore.doubleCount)
console.log(counterStore.doneTodosCount)
```

---

### 3-4. actions

> “state를 **변경**하는 함수들 (methods 역할)”

* 비즈니스 로직, 비동기 처리(Ajax, API 호출 등)도 여기에서 수행.
* `this`로 state와 다른 actions에 접근 가능.

```js
actions: {
  increment() {
    this.count++
  },
  addTodo(text) {
    this.todos.push({
      id: Date.now(),
      text,
      isDone: false,
    })
  },
  deleteTodo(selectedId) {
    this.todos = this.todos.filter(todo => todo.id !== selectedId)
  },
}
```

* 사용 예시

```js
const counterStore = useCounterStore()

counterStore.increment()
counterStore.addTodo('새 할 일')
```

---

### 3-5. store 반환값 / 사용 형태 포인트

* `defineStore`는 **“store를 생성하는 함수”**를 반환한다.
* 실제 컴포넌트 안에서는 `const store = useCounterStore()` 처럼 호출해서 사용.
* `store` 객체 안에는:

  * `state`의 각 속성
  * `getters`의 각 속성
  * `actions`의 각 메서드
    가 다 들어있다고 생각하면 된다.

---

## 4. Todo 예제로 보는 CRUD + 상태 관리 흐름

자료에서 Todo 앱 예제가 나온 것 같아서, 흐름 위주로 정리해볼게.

---

### 4-1. 구조

```text
App
 ├─ TodoForm   : 새 Todo 입력 (Create)
 └─ TodoList   : Todo 목록 표시 + 삭제/수정 버튼 (Read / Update / Delete)
     └─ TodoListItem (선택사항)
```

공통 데이터인 `todos`는 **store에서 관리**하고,
각 컴포넌트가 store를 불러서 자기 역할만 한다.

---

### 4-2. state에 todos 두기

```js
// stores/counter.js
export const useCounterStore = defineStore('counter', {
  state: () => ({
    todos: [
      { id: 1, text: '샘플 Todo', isDone: false },
    ],
  }),
  actions: {
    addTodo(text) { ... },
    deleteTodo(id) { ... },
    updateTodo(payload) { ... },
  },
})
```

---

### 4-3. 조회(Read)

#### 1) TodoList에서 store 불러오기

```js
// TodoList.vue <script setup>
import { useCounterStore } from '@/stores/counter'

const store = useCounterStore()
```

#### 2) 템플릿에서 목록 렌더링

```html
<li v-for="todo in store.todos" :key="todo.id">
  <span>{{ todo.text }}</span>
</li>
```

→ **중요 포인트**: 이제 `todos`를 `App`에서 내려주지 않고,
`TodoList`가 직접 store에서 가져와서 사용한다.

---

### 4-4. 생성(Create)

#### 1) store에 addTodo 액션 정의

```js
actions: {
  addTodo(text) {
    const newTodo = {
      id: Date.now(),
      text,
      isDone: false,
    }
    this.todos.push(newTodo)
  },
}
```

#### 2) TodoForm에서 사용

```vue
<script setup>
import { ref } from 'vue'
import { useCounterStore } from '@/stores/counter'

const store = useCounterStore()
const todoText = ref('')

const onSubmit = () => {
  if (!todoText.value.trim()) return
  store.addTodo(todoText.value)
  todoText.value = ''
}
</script>

<template>
  <form @submit.prevent="onSubmit">
    <input v-model="todoText" placeholder="할 일을 입력하세요" />
    <button type="submit">추가</button>
  </form>
</template>
```

---

### 4-5. 삭제(Delete)

#### 1) store에 deleteTodo 정의

```js
actions: {
  deleteTodo(selectedId) {
    this.todos = this.todos.filter(todo => todo.id !== selectedId)
  },
}
```

#### 2) TodoListItem에서 사용

```vue
<script setup>
import { useCounterStore } from '@/stores/counter'

const props = defineProps({
  todo: Object,
})

const store = useCounterStore()
const onDelete = () => {
  store.deleteTodo(props.todo.id)
}
</script>

<template>
  <li>
    <span>{{ todo.text }}</span>
    <button @click="onDelete">삭제</button>
  </li>
</template>
```

---

### 4-6. 수정(Update) – isDone 토글

#### 1) store 액션

```js
actions: {
  toggleTodo(id) {
    const target = this.todos.find(todo => todo.id === id)
    if (target) {
      target.isDone = !target.isDone
    }
  },
}
```

#### 2) 컴포넌트에서 사용

```vue
<button @click="store.toggleTodo(todo.id)">
  {{ todo.isDone ? '취소' : '완료' }}
</button>
```

→ 자료에서는 `watch`나 `ref`를 사용해서 isDone 상태 변화를 감지하는 방식도 소개했을 텐데, 핵심 아이디어는:

* **화면에서 어떤 조작이 일어나든 결국 최종적으로는 store의 state를 바꾸는 action 한 군데로 모으는 것**이 포인트야.

---

## 5. Todo 개수 세기 (getters 활용)

“완료된 Todo가 몇 개인지” 같은 파생 정보는 **getter**로 두는 게 깔끔해.

```js
getters: {
  doneTodosCount(state) {
    return state.todos.filter(todo => todo.isDone).length
  }
}
```

사용할 때:

```vue
<p>완료된 Todo : {{ store.doneTodosCount }}</p>
```

→ 이렇게 하면 컴포넌트마다 따로 `filter`와 `length`를 계산하지 않아도 됨.

---

## 6. Local Storage + pinia-plugin-persistedstate

### 6-1. Local Storage란?

* 브라우저 안에 있는 **key-value 저장소**
* 페이지를 새로고침해도, 브라우저를 껐다 켜도 데이터가 남아있음
* 단, **같은 브라우저, 같은 도메인**에서만 유지

Todo 앱에 적용하면:
**새로고침해도 목록이 사라지지 않고 유지**되게 만들 수 있음.

---

### 6-2. Pinia에서 Local Storage 쓰는 방법 (persist 플러그인)

수업 자료에 있는 내용 기준으로 요약해볼게.

1. 패키지 설치

   ```bash
   npm install pinia-plugin-persistedstate
   ```

2. main.js에서 플러그인 등록

   ```js
   import { createPinia } from 'pinia'
   import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

   const pinia = createPinia()
   pinia.use(piniaPluginPersistedstate)

   const app = createApp(App)
   app.use(pinia)
   app.mount('#app')
   ```

3. store에서 persist 옵션 켜기

   ```js
   export const useCounterStore = defineStore('counter', {
     state: () => ({
       todos: [],
     }),
     actions: { ... },
     persist: true,   // <= 이 한 줄
   })
   ```

→ 이렇게 하면 `todos` 상태가 자동으로 Local Storage에 저장되고,
앱을 다시 켰을 때 Local Storage에서 불러와 복원해준다.

---

## 7. 모든 데이터를 store에 넣어야 할까?

자료 마지막 부분에 있는 핵심 결론을 정리해보면:

> **Pinia를 쓴다고 해서 모든 데이터를 store에서 관리해야 하는 건 아니다.**

* 일시적으로만 쓰는 값, 특정 컴포넌트 내부에서만 쓰이는 값

  * 예: 모달 열려있는지 여부, 특정 입력 폼 내부의 입력값 등
  * → 이런 것들은 그냥 **컴포넌트 로컬 상태(ref, reactive)** 로 관리해도 충분하다.
* 여러 화면/컴포넌트에서 **공유해야 하는 데이터**

  * 로그인 유저 정보, 장바구니, Todo 목록, 필터 상태 등
  * → 이런 것들은 store에 두면 좋다.

**정리 기준**

* “이 데이터를 다른 페이지/컴포넌트에서도 써야 하나?”

  * 아니오 → 컴포넌트 로컬 state
  * 예 → Pinia store

---

## 8. 전체 흐름 한 번에 정리

1. **기본 Vue**

   * 단방향 데이터 흐름: 부모 → 자식 `props`, 자식 → 부모 `emit`
2. **문제 상황**

   * 컴포넌트 트리가 깊어질수록 `props drilling` 심해짐
   * 형제/멀리 떨어진 컴포넌트 사이 상태 공유가 복잡해짐
3. **해결책**

   * **Pinia** 같은 중앙 저장소(store)에 상태를 모아 관리
4. **Pinia 구조**

   * `defineStore('id', { state, getters, actions })`
   * `state`: 실제 데이터
   * `getters`: 계산된 값 (computed 역할)
   * `actions`: state를 변경하는 함수 (동기/비동기 로직 가능)
5. **Todo 예제**

   * state에 `todos` 배열
   * actions로 `addTodo / deleteTodo / toggleTodo / updateTodo`
   * components에서 `useCounterStore()`로 불러 사용
6. **Local Storage**

   * `pinia-plugin-persistedstate` + `persist: true`로 새로고침 후에도 상태 유지
7. **언제 store를 쓰나?**

   * “여러 컴포넌트/페이지가 같이 써야 하는 중요한 상태”만 store에
   * 나머지는 컴포넌트 내부 state로 관리

---

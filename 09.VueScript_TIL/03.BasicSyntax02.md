한 줄로 요약하면:

> “Vue에서 조금 더 똑똑하게 상태를 다루는 방법들(computed, v-if/v-show, v-for, watch, lifecycle, 스타일 가이드)”

---

# 🧠 1. computed 속성 – “계산된 상태”를 캐싱해서 쓰기

## 1-1. computed가 뭐 하는 애인지 한 문장으로

> **기존 반응형 상태(ref, reactive)를 이용해서 ‘새로운 값’을 계산해내고,
> 그 계산 결과를 캐싱해서 필요한 순간에만 다시 계산해주는 속성**

즉,

* `data` / `ref` : “원본 상태”
* `computed` : 그 상태들로부터 **파생되는 값(derived state)**

예를 들어:

```js
const firstName = ref('Kim')
const lastName = ref('Hyeryeong')

const fullName = computed(() => {
  console.log('계산 중…')
  return `${lastName.value} ${firstName.value}`
})
```

* 템플릿에서 `{{ fullName }}` 을 여러 번 써도

  * `lastName`이나 `firstName`이 바뀌지 않는 한
    `console.log('계산 중…')`는 **한 번만 실행**된다.
* 의존하고 있는 값이 변경될 때만 다시 계산됨 → “캐싱(cache)”라고 부름.

## 1-2. method랑 뭐가 다른지

같은 일을 method로도 할 수 있다:

```js
const getFullName = () => {
  console.log('계산 중…')
  return `${lastName.value} ${firstName.value}`
}
```

템플릿에서:

```html
<p>{{ fullName }}</p>        <!-- computed -->
<p>{{ getFullName() }}</p>   <!-- method -->
```

차이:

| 구분    | computed           | method              |
| ----- | ------------------ | ------------------- |
| 호출 시점 | 의존 값이 바뀔 때만 다시 계산  | 호출할 때마다 **매번** 실행   |
| 특징    | 결과를 캐싱해서 재사용       | 항상 새로 계산            |
| 사용 목적 | **파생된 값**을 얻고 싶을 때 | **동작/함수 실행** 자체가 목적 |

그래서…

* 단순히 “클릭하면 alert 띄우기” 같은 건 → method
* “todos 중 완료된 개수/남은 개수, 필터링된 목록” 같은 파생 상태 → computed

## 1-3. computed로 필터링/정렬하기

**예: todo 중에서 완료된 것만 보여주기**

```js
const todos = ref([
  { id: 1, title: '밥 먹기', isComplete: false },
  { id: 2, title: 'Vue 공부', isComplete: true },
])

const completedTodos = computed(() => {
  return todos.value.filter((todo) => todo.isComplete)
})
```

템플릿:

```html
<li v-for="todo in completedTodos" :key="todo.id">
  {{ todo.title }}
</li>
```

장점:

* `todos`가 바뀔 때만 필터를 다시 돌림
* 여러 곳에서 `completedTodos`를 써도 반복 계산X

## 1-4. computed 쓸 때 주의할 점

1. **반드시 “새 값을 리턴하는 함수”여야 한다.**

   * 사이드 이펙트(API 요청, 콘솔 출력 등)는 watch에 맡기는 게 좋다.
2. **원본 배열을 직접 mutate 하지 말기**

   * `numbers.value.reverse()` 처럼 원본을 뒤집어버리면
     다른 곳에서도 예상치 못한 영향이 생김
   * `numbers.value.slice().reverse()` 처럼 **복사본에 작업**하기
3. “한 번 계산해두고 계속 재사용하고 싶은 값”인지 스스로 물어보고
   맞다면 computed, 아니면 method로.

---

# 👀 2. 조건부 렌더링 – v-if / v-else-if / v-else / v-show

## 2-1. v-if – DOM 자체를 만들었다가/없앴다가

```html
<p v-if="isSeen">보일 때만 렌더링</p>
<p v-else>안 보일 때 렌더링</p>
```

특징:

* `isSeen === true` → DOM에 **실제로 요소를 생성**
* `false` → 아예 DOM에서 제거
* 조건이 바뀔 때마다 요소를 생성/파괴하기 때문에

  * **초기 렌더링 비용이 싸고**
  * **토글(자주 켰다 껐다)이 비싸다**

`v-else-if`, `v-else`로 여러 조건 묶어서 사용 가능.

템플릿 태그로 감싸서 여러 요소에 동시에 조건을 걸 수도 있다:

```html
<template v-if="isLogin">
  <p>안녕하세요</p>
  <button>로그아웃</button>
</template>
```

## 2-2. v-show – DOM은 항상 있고, display만 켰다 껐다

```html
<p v-show="isOpen">이건 display로만 숨김</p>
```

특징:

* 요소는 **항상 DOM 안에 존재**
* `true/false`에 따라 `style="display: none"`을 붙였다 뗐다
* 그래서

  * **초기 렌더링 비용은 v-if보다 비싸고**
  * **토글 비용은 매우 싸다**

## 2-3. v-if vs v-show 언제 무엇을 쓸까?

* **자주 바뀌는 것 (탭, 열고닫는 메뉴, 드롭다운)** → `v-show`
* **거의 안 바뀌는 것 (페이지 처음에만 한 번 체크, 권한에 따라 요소 노출)** → `v-if`

---

# 📋 3. 리스트 렌더링 – v-for, 그리고 key

## 3-1. 기본 v-for 문법

```html
<li v-for="(item, index) in items" :key="item.id">
  {{ index }} / {{ item.name }}
</li>
```

* `(item, index) in items`

  * `item` : 배열의 각 요소
  * `index` : 0부터 시작하는 인덱스
* 객체도 `value, key, index` 형태로 순회 가능

## 3-2. key가 중요한 이유

> **key는 “이 DOM 요소가 어떤 데이터와 연결된 것인지”를 구분하기 위한 식별자**

Vue가 리스트를 업데이트할 때:

* 단순히 인덱스만 믿으면

  * 중간에 새 항목이 끼어들었을 때
    DOM 재활용이 꼬여서 로직/애니메이션/포커스가 이상해질 수 있음.
* `:key="item.id"`처럼 **항상 고유한 id를 key로 주는 게 베스트**

**tip**

* `index`를 key로 쓰는 건 **항목이 절대 안 바뀌거나, 정렬/추가/삭제가 없는 정적 리스트**일 때만.
* 대부분의 실제 앱에서는 **서버에서 내려오는 고유 id를 key로 사용**하는 게 안전.

---

# ⚠️ 4. v-for + v-if 같이 쓸 때의 함정과 해결법

## 4-1. 같은 엘리먼트에 동시에 쓰지 말기

```html
<!-- 권장 X -->
<li v-for="todo in todos" v-if="todo.isComplete">
  {{ todo.title }}
</li>
```

문제:

* v-if가 **v-for보다 우선** 적용된다.
* 렌더링/업데이트 과정이 복잡해지고, 인덱스나 key가 꼬이기 쉽다.
* 배열 길이가 변경될 때 이상한 에러가 날 수 있음.

## 4-2. 해결 1 – computed로 “필터된 리스트” 만들기

```js
const todos = ref([...])

const completedTodos = computed(() =>
  todos.value.filter((todo) => todo.isComplete)
)
```

템플릿:

```html
<li v-for="todo in completedTodos" :key="todo.id">
  {{ todo.title }}
</li>
```

**핵심 아이디어**

> “보여줄 목록을 먼저 computed에서 필터링한 뒤
> 템플릿에서는 v-for만 쓴다.”

## 4-3. 해결 2 – template 래퍼 사용

```html
<ul>
  <template v-for="todo in todos" :key="todo.id">
    <li v-if="todo.isComplete">
      {{ todo.title }}
    </li>
  </template>
</ul>
```

* `v-for`는 `<template>`에
* 그 안의 실제 `<li>`에 `v-if` 적용

그래도 실제 프로젝트에서는 **computed로 미리 필터링하는 패턴**이 더 깔끔하다.

---

# 👂 5. watch – “변화를 감시해서 반응하기”

## 5-1. watch가 하는 일

> **특정 반응형 데이터의 변화를 지켜보다가, 값이 바뀌면 콜백을 실행하는 함수**

구조:

```js
watch(source, (newValue, oldValue) => {
  // 값이 바뀔 때마다 실행할 로직
})
```

* `source` : 감시할 대상을 의미

  * `ref` 변수
  * `() => state.value.someField` 같은 getter 함수
  * `[a, () => b.value]` 같은 배열 (다중 감시)
* 콜백 인자:

  * `newValue`
  * `oldValue`

## 5-2. 기본 예시

```js
const count = ref(0)

watch(count, (newVal, oldVal) => {
  console.log(`count가 ${oldVal} → ${newVal} 로 바뀜`)
})
```

* `count.value++` 할 때마다 콜백이 호출된다.

문자열 길이 감시 예시:

```js
const message = ref('hello')
const messageLength = ref(message.value.length)

watch(message, (newVal) => {
  messageLength.value = newVal.length
})
```

템플릿:

```html
<input v-model="message" />
<p>Message length: {{ messageLength }}</p>
```

## 5-3. computed vs watch 차이 정리

| 구분    | computed              | watch                              |
| ----- | --------------------- | ---------------------------------- |
| 목적    | 다른 상태로부터 **새 값을 계산**  | 상태 변화에 따라 **부수효과(side effect)** 실행 |
| 결과    | 항상 **값(value)**를 반환   | 아무것도 반환하지 않아도 됨 (함수 실행이 목적)        |
| 캐싱    | 의존 상태가 바뀌지 않으면 재계산X   | 그런 개념 없음, 변할 때마다 콜백 실행             |
| 사용 예시 | 필터링된 목록, 합계, 포맷팅된 문자열 | API 호출, 로컬스토리지 저장, 콘솔 로그, 알림       |

**요약**

* “템플릿에서 쓸 새로운 값이 필요하다” → computed
* “어떤 값이 바뀔 때마다 뭔가 일을 해야 한다” → watch

---

# 🔄 6. Lifecycle Hooks – 컴포넌트의 인생주기

## 6-1. Vue 컴포넌트가 겪는 단계

대략 이런 흐름으로 생각하면 편하다:

1. **생성(create)** – setup 실행, 반응형 상태/함수 준비
2. **마운트(mount)** – 실제 DOM에 붙고, 화면에 처음 등장
3. **업데이트(update)** – 반응형 데이터가 바뀌어 DOM이 다시 그려짐
4. **언마운트(unmount)** – 화면에서 제거, 정리 작업

이 각 단계에서 코드를 끼워 넣을 수 있게 해주는 게 **Lifecycle Hook**.

## 6-2. 자주 쓰는 훅들

Composition API 기준:

```js
import { onMounted, onUpdated, onUnmounted } from 'vue'

onMounted(() => {
  console.log('처음 화면에 나타났을 때 한 번 실행')
})

onUpdated(() => {
  console.log('반응형 데이터 변경으로 DOM이 다시 그려졌을 때 실행')
})

onUnmounted(() => {
  console.log('이 컴포넌트가 화면에서 사라질 때 실행')
})
```

### onMounted – “화면에 처음 등장했을 때”

가장 자주 쓰는 사용처: **처음 렌더링할 때 API 호출**

```js
onMounted(async () => {
  const res = await fetch('https://api.thecatapi.com/v1/images/search')
  // state에 res 결과 저장
})
```

### onUpdated – “업데이트 이후”

* 텍스트/DOM이 실제로 다시 렌더된 뒤에 뭔가를 하고 싶을 때
* 예: 스크롤 위치 조정, 애니메이션 트리거 등

### onUnmounted – “정리(clean-up)”

* setInterval, 이벤트 리스너 등 제거
* 메모리 누수 방지

## 6-3. lifecycle 훅 사용할 때 주의

* `setup()` 최상위에서 **조건문/루프 안이 아닌 곳**에서 호출해야 한다.

  * `if (isLogin) { onMounted(... }` 이런 식으로 쓰면 안 됨
* 훅 안에서 직접 DOM 조작이 필요할 땐

  * `ref`로 요소를 잡은 뒤, onMounted 안에서 접근

---

# 🎨 7. Vue Style Guide에서 강조하는 베스트 프랙티스

1. **v-if와 v-for를 같은 엘리먼트에 같이 쓰지 말기**

   * computed로 필터링하거나, `<template>`을 이용해서 분리
2. **필터링/정렬은 computed에서**

   * 템플릿 안에 `items.filter(...).map(...)`처럼 쓰지 말고
     미리 computed로 뽑아 두기
3. **computed 안에서는 원본을 mutate하지 말기**

   * 항상 복사본을 만들어 다루기 (`slice`, `filter`, `concat` 등)
4. **Lifecycle Hook은 반드시 setup의 최상위에서 호출**

   * 조건문/함수 안에서 훅 선언 X

---

# ✅ 마지막 한 장 요약 (TIL 마무리용)

* **computed**

  * 다른 상태로부터 파생되는 값을 만드는 속성
  * 결과를 캐싱해서 의존 값이 바뀔 때만 재계산
  * 필터링/정렬/카운트 등 “derived state”는 웬만하면 computed로

* **v-if / v-show**

  * v-if: DOM을 만들었다/지웠다 (초기 싸고, 토글 비쌈)
  * v-show: DOM은 항상 있고 display만 조절 (초기 비싸고, 토글 싸다)
  * 자주 토글 → v-show / 드물게 토글 → v-if

* **v-for + key**

  * `v-for="item in items" :key="item.id"`
  * key는 각 요소를 고유하게 식별하기 위해 꼭 필요
  * 잘 변하는 리스트에서 index를 key로 쓰면 버그 위험 ↑

* **v-for + v-if**

  * 같은 엘리먼트에 같이 쓰지 말기
  * 보여줄 리스트를 먼저 computed로 필터링한 다음 v-for만 쓰기

* **watch**

  * 특정 반응형 값의 변화를 감시해서 side effect 실행
  * “값을 만들고 싶으면 computed, 일을 하고 싶으면 watch”

* **Lifecycle Hooks**

  * onMounted / onUpdated / onUnmounted 등
  * API 호출, 이벤트 등록/해제, DOM 기반 로직을 적절한 시점에 넣는 도구
  * 항상 setup 최상위에서 호출

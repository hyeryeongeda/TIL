# 🧠 Vue 컴포넌트 상태 흐름 완전 정리 (Props & Emit)

오늘은 **Vue에서 컴포넌트끼리 데이터가 어떻게 흐르는지** 정리했다.
핵심 키워드는 딱 두 개다.

> **부모 → 자식 : props**
> **자식 → 부모 : emit(event)**

그리고 이 둘이 합쳐져서 **one-way data flow(단방향 데이터 흐름)** 을 만든다.

---

## 1. 전체 그림 먼저: 단방향 데이터 흐름(One-Way Data Flow)

Vue에서 상태 흐름은 기본적으로 **위에서 아래로만 흘러간다.**

* 공통 데이터는 보통 **상위 컴포넌트(부모)** 가 들고 있음
* 이 데이터가 필요하면 **자식 컴포넌트로 내려보내기만 가능**
* 자식은 직접 부모 데이터를 수정할 수 없고,

  * 값이 바뀌어야 한다면 **“이벤트를 올려서 부모한테 알려주고 부모가 상태를 수정”**한다.

이 구조가 중요한 이유:

1. 데이터가 어디서 바뀌는지 추적하기 쉬움
   → “이 값은 항상 여기서만 바뀐다”라는 규칙을 갖게 된다.
2. 테스트‧디버깅이 쉬워짐
3. 규모 커졌을 때 **상태 꼬임 지옥**을 어느 정도 예방해 줌

정리하면:

> * **부모는 “상태(source of truth)”를 가진다.**
> * **자식은 “받은 값(props)”과 “이벤트 발신”만 한다.**

---

## 2. Props – 부모가 자식에게 주는 데이터

### 2-1. Props 한 줄 정의

> **Props = 부모 컴포넌트가 자식 컴포넌트에게 내려주는 “읽기 전용 데이터”**

* 읽기 전용(read-only)이라는 점이 포인트
* 자식은 props를 **읽고 보여주기만 해야 한다.**
* 바꾸고 싶으면? → emit으로 부모에게 알려야 함

---

### 2-2. 가장 기본적인 예시

#### 부모 컴포넌트 (Parent.vue)

```vue
<template>
  <div>
    <ParentChild my-msg="안녕, 자식아!" />
  </div>
</template>

<script setup>
import ParentChild from '@/components/ParentChild.vue'
</script>
```

* `my-msg="안녕, 자식아!"`
  → `my-msg`라는 이름의 props로 문자열을 내려줌
  (HTML에서는 kebab-case)

#### 자식 컴포넌트 (ParentChild.vue)

```vue
<template>
  <div>
    <p>부모가 준 메시지: {{ myMsg }}</p>
  </div>
</template>

<script setup>
// defineProps로 받을 props 정의
const props = defineProps({
  myMsg: String,
})

// 구조분해도 가능 (선호 취향)
const { myMsg } = props
</script>
```

* `defineProps` 안에서 JS에서는 **camelCase**로 사용 (`myMsg`)
* 템플릿에서는 바로 `{{ myMsg }}`로 사용

> 💡 규칙
>
> * 템플릿/HTML에서 사용 → `my-msg` (kebab-case)
> * JS 코드에서 사용 → `myMsg` (camelCase)

---

### 2-3. Props 타입 선언 (문자열 말고도 여러 타입)

`defineProps`는 객체 형태로 타입과 옵션을 줄 수 있다.

```js
const props = defineProps({
  myMsg: {
    type: String,    // 타입
    required: true,  // 필수 여부
    default: '기본값', // 기본값
  },
  count: Number,
  isDone: Boolean,
  items: Array,
  user: Object,
})
```

* `type`은 JS 생성자 사용: `String`, `Number`, `Boolean`, `Object`, `Array`…
* `required: true`인데 부모가 안 내려주면 콘솔에 경고 뜸
* `default`는 값이 안 내려왔을 때 사용

> 왜 타입을 쓰냐?
>
> * 협업할 때, “이 props는 뭐가 들어오는지” 바로 알 수 있음
> * 잘못된 타입이 들어오면 경고를 띄워줘서 실수를 줄여줌

---

### 2-4. Static props vs Dynamic props

#### 1) Static props (그냥 문자열 리터럴)

```vue
<ParentChild my-msg="안녕" />
```

* `"안녕"`이라는 **문자열 그대로**가 내려간다.

#### 2) Dynamic props (`:` / `v-bind`)

```vue
<script setup>
const message = ref('Hello')
</script>

<template>
  <ParentChild :my-msg="message" />
</template>
```

* `:`을 붙이면 JS 표현식을 평가한 결과가 내려간다.
* 숫자, 배열, 객체 등도 전부 `:`으로 내려야 한다.

```vue
<SomeComponent num-props="1" />   <!-- 문자열 "1" -->
<SomeComponent :num-props="1" />  <!-- 숫자 1 -->
```

이거 헷갈리면 진짜 자주 버그남…
**숫자 / 배열 / 객체는 항상 `:` 붙이기!**

---

### 2-5. Props는 왜 “읽기 전용”일까?

Vue의 원칙: **부모가 준 데이터를 자식이 마음대로 바꾸면 안 된다.**

```vue
<script setup>
const props = defineProps({ myMsg: String })

// ❌ 이렇게 하면 안 됨!
props.myMsg = '바꿔버릴게요'
</script>
```

* 이건 경고가 뜬다: “props를 직접 수정하지 마세요”
* 왜냐면 부모는 여전히 예전 값을 가지고 있고,
  자식만 변경하면 데이터 흐름이 꼬인다.

**바꾸고 싶으면 → emit으로 부모에게 요청 → 부모가 자기 state를 바꿈 → 그게 다시 props로 내려옴** 이 흐름을 지켜야 한다.

---

### 2-6. 여러 단계 아래까지 props 전달하기

구조가 이렇게 있다고 해보자.

```text
App
 └─ Parent
     └─ ParentChild
         └─ ParentGrandChild
```

`App`에서 내려준 데이터를 `ParentGrandChild`까지 보내고 싶으면:

* App → Parent : props
* Parent → ParentChild : props
* ParentChild → ParentGrandChild : props

이렇게 **중간 컴포넌트들이 데이터 실제로 안 써도 ‘중간 전달자’ 역할**을 하게 된다.
이걸 “props drilling”이라고도 부른다.

> 규모가 커지면 이런 패턴 때문에 Pinia 같은 중앙 store를 쓰게 되는 것.

---

## 3. Props를 v-for와 같이 쓰기

**목록을 렌더링할 때, 한 항목씩 자식에게 넘기는 패턴**이 자주 나온다.

### 3-1. 부모 – 리스트 컴포넌트

```vue
<script setup>
import UserItem from '@/components/UserItem.vue'

const users = [
  { id: 1, name: 'Alice', age: 20 },
  { id: 2, name: 'Bob', age: 25 },
]
</script>

<template>
  <ul>
    <UserItem
      v-for="user in users"
      :key="user.id"
      :user="user"
    />
  </ul>
</template>
```

### 3-2. 자식 – 단일 항목 컴포넌트

```vue
<script setup>
const props = defineProps({
  user: Object,
})
</script>

<template>
  <li>{{ user.name }} ({{ user.age }}세)</li>
</template>
```

* 부모는 “리스트 전체”를 가지고 있음
* 자식은 “한 아이템의 데이터”를 props로 받음
* 이 패턴이 Vue에서 **가장 자주 쓰이는 props 활용법** 중 하나

---

## 4. Emit – 자식이 부모에게 올리는 이벤트

이제 **반대 방향**이다.

> **자식 → 부모로 정보(또는 신호)를 보내는 방법 = emit 이벤트**

---

### 4-1. $emit 개념

* 자식 컴포넌트 안에서 `emit()`을 호출하면

  * 부모 컴포넌트에서 그 이벤트 이름을 `v-on`(혹은 `@`)으로 들을 수 있다.
* 함수 시그니처:

```ts
emit(eventName: string, ...args: any[])
```

* 첫 번째 인자: 이벤트 이름
* 두 번째 이후: 부모에게 전달할 데이터(여러 개 가능)

### 4-2. 가장 기본적인 패턴

#### 자식 (ChildButton.vue)

```vue
<script setup>
const emit = defineEmits(['myEvent'])

const onClick = () => {
  emit('myEvent')      // 데이터 없이 신호만
}
</script>

<template>
  <button @click="onClick">눌러줘</button>
</template>
```

#### 부모 (Parent.vue)

```vue
<script setup>
import ChildButton from '@/components/ChildButton.vue'

const onChildClick = () => {
  console.log('자식 버튼 눌림!')
}
</script>

<template>
  <ChildButton @myEvent="onChildClick" />
</template>
```

흐름:

1. 사용자가 ChildButton을 클릭
2. 자식에서 `emit('myEvent')`
3. 부모 템플릿의 `@myEvent="onChildClick"` 가 호출됨

이게 바로 **“부모로 신호를 올리는”** 흐름이다.

---

### 4-3. 이벤트에 데이터 함께 보내기 (Event Arguments)

숫자, 문자열, 객체 등 원하는 데이터도 같이 보낼 수 있다.

#### 자식

```vue
<script setup>
const emit = defineEmits(['sendMessage'])

const send = () => {
  emit('sendMessage', '안녕하세요', 123)
}
</script>

<template>
  <button @click="send">메시지 보내기</button>
</template>
```

#### 부모

```vue
<script setup>
import Child from '@/components/Child.vue'

const onMessage = (msg, num) => {
  console.log(msg) // '안녕하세요'
  console.log(num) // 123
}
</script>

<template>
  <Child @sendMessage="onMessage" />
</template>
```

이 패턴을 이용해서:

* input 내용 보내기
* 체크박스 상태 보내기
* “이 Todo를 삭제해줘” 하면서 id 보내기

등을 구현하게 된다.

---

### 4-4. emit Name Casing (이벤트 이름 표기)

* JS 코드에서 정의할 때: 보통 camelCase 사용

```js
const emit = defineEmits(['someEvent'])
emit('someEvent')
```

* 부모 템플릿에서 들을 때: kebab-case로 쓰는 것이 일반적

```vue
<ChildComponent @some-event="handler" />
```

Vue가 자동으로 camelCase ↔ kebab-case를 매칭해 준다.

이 규칙은 props랑 비슷하다.

---

## 5. 여러 단계 위로 이벤트 올리기 (이벤트 버블링 느낌)

구조가 이렇게 있다고 하자.

```text
App
 └─ Parent
     └─ ParentChild
         └─ ParentGrandChild
```

**가장 아래에 있는 ParentGrandChild에서 버튼을 누르면, 최상위 Parent의 name을 바꾸고 싶다.**

1. ParentGrandChild → emit으로 `changeName` 같은 이벤트 발생
2. ParentChild는 그 이벤트를 받아서 **다시 emit** (중계)
3. Parent는 최종적으로 이벤트를 받아서 자기 state를 수정

### 5-1. ParentGrandChild (이벤트 최초 발신)

```vue
<script setup>
const emit = defineEmits(['changeName'])

const onClick = () => {
  emit('changeName', '새 이름')
}
</script>

<template>
  <button @click="onClick">이름 바꾸기</button>
</template>
```

### 5-2. ParentChild (이벤트를 받아 다시 올려보내기)

```vue
<script setup>
import ParentGrandChild from './ParentGrandChild.vue'

const emit = defineEmits(['changeName'])

const onGrandChildChange = (newName) => {
  emit('changeName', newName)  // 그대로 다시 위로 전달
}
</script>

<template>
  <ParentGrandChild @changeName="onGrandChildChange" />
</template>
```

### 5-3. Parent (최종 처리)

```vue
<script setup>
import { ref } from 'vue'
import ParentChild from './ParentChild.vue'

const name = ref('기존 이름')

const onChangeName = (newName) => {
  name.value = newName
}
</script>

<template>
  <div>
    <p>현재 이름: {{ name }}</p>
    <ParentChild @changeName="onChangeName" />
  </div>
</template>
```

이렇게 **이벤트도 props처럼 여러 단계를 타고 올라갈 수 있다.**

* props: 위에서 아래로 전달
* emit: 아래에서 위로 전달

이 둘을 잘 조합하면, 컴포넌트가 여러 단계로 깊어져도
데이터 흐름이 여전히 “한 방향”으로 유지된다.

---

## 6. 왜 props/emit을 이렇게 “엄격하게” 쓰는지

정리해 보면 규칙은 꽤 빡세 보인다.

* props는 읽기 전용, 자식은 직접 변경 금지
* 자식이 뭔가 바꾸고 싶으면 emit으로 요청
* 실제 state 변경은 항상 상위에서

하지만 이렇게 하면 좋은 점:

1. **“이 데이터는 어디서 바뀌지?”**가 명확하다.
   → 항상 부모(혹은 store)에서만 변경됨.
2. 자식 컴포넌트는 **순수하게 UI + 이벤트 발행만 담당**하게 돼서 재사용성이 높아진다.

   * 같은 자식 컴포넌트를 다른 부모에서도 쉽게 재활용 가능.
3. 구조가 커져도 **흐름을 머릿속으로 따라가기 쉽다.**

   * 위에서 아래로 내려가기
   * 아래에서 위로 올릴 때는 항상 이벤트

---

## 7. 오늘 내용 한 장 요약 (암기용)

> ### 데이터 방향

* **부모 → 자식 : props**
* **자식 → 부모 : emit(event)**
* 전체적으로 **One-Way Data Flow** 유지

> ### Props

* 부모가 자식에게 내려주는 **읽기 전용 데이터**
* `defineProps`로 선언
* HTML 템플릿: `my-msg` (kebab-case)
  JS 코드: `myMsg` (camelCase)
* `:`를 붙이면 **동적 props** – 숫자/배열/객체는 꼭 `:` 사용
* 직접 변경 ❌ → 변경해야 하면 emit으로 부모에 요청

> ### Emit

* 자식이 부모에게 **이벤트 + 데이터**를 올리는 방식
* `const emit = defineEmits(['eventName'])`
* `emit('eventName', payload...)`
* 부모: `<Child @event-name="handler" />`
* 여러 단계 위까지 이벤트를 다시 emit해서 전달 가능

> ### 패턴

* 리스트 → `v-for`로 항목 돌리면서 각 아이템을 props로 자식에게 전달
* 자식에서 버튼 클릭/입력 변경 → emit으로 부모에게 알림 → 부모가 state 변경

---

이제 앞으로 Vue 컴포넌트를 짤 때

* “이 데이터는 어디서 들고 있어야 하지?”
* “이 값이 바뀌려면 어느 방향으로 흘러가야 하지?”

를 항상 **props & emit + 단방향 흐름** 기준으로 생각하면
구조 잡는 게 훨씬 쉬워질 것 같다.

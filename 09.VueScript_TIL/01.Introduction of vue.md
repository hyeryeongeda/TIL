
---

# 0. 오늘 내용 한 줄 요약

> **왜 Vue 같은 프론트엔드 프레임워크가 필요한지(SPA, CSR 개념)**
>
> * **Vue 앱을 만드는 최소 구조(createApp, mount, setup, ref)**
> * **Vue의 핵심 철학: 반응형 상태 + 컴포넌트 기반 UI**

---

# 1. 프론트엔드 개발이 하는 일 & Client-side Framework

## 1-1. 프론트엔드 개발이란?

* 사용자가 실제로 눈으로 보는 **웹 화면(UI)** 을 만드는 영역
* HTML, CSS, JavaScript로

  * 버튼, 폼, 리스트, 모달, 탭 등 인터페이스를 구현
  * 사용자 경험(UX)을 설계

과거에는 “정적인 페이지”가 많았지만,
지금은 **웹앱(Web Application)** 처럼 앱에 가까운 동적인 UI가 대부분이라
복잡한 상태 관리와 화면 전환이 필요해졌고, 그래서 프레임워크가 등장.

## 1-2. Client-side Framework가 필요한 이유

자료에서 Vue 로고 옆에 React, Angular가 같이 나와 있었지. 전부 **클라이언트(브라우저) 쪽에서 돌아가는 JS 프레임워크**. 

필요한 이유를 정리하면:

1. **복잡한 UI를 효율적으로 관리**

   * 예: 무한 스크롤, 실시간 검색, 필터링, 모달, 알림 등
   * 이런 걸 바닐라 JS로만 하면 코드가 길고 중복이 많아짐.

2. **상태(State)와 화면을 자동으로 연결**

   * “데이터가 바뀌면 알아서 화면이 바뀐다”는 규칙을 제공
   * 개발자는 `document.querySelector` 같은 DOM 조작을 일일이 안 써도 됨.

3. **SPA(Single Page Application) 구조를 쉽게 구현**

   * 페이지 전환을 서버가 아니라 **브라우저에서** 처리
   * 부드러운 화면 전환, 모바일앱 같은 느낌 구현 가능.

---

# 2. SPA(Single Page Application) 개념

## 2-1. SPA가 뭐야?

> **한 장의 HTML 페이지 위에서 JavaScript로 화면을 갈아끼우며 동작하는 웹 애플리케이션**

전통적인 방식(MPA: Multi Page Application):

* `/home` 요청 → 서버가 `home.html` 통째로 보냄
* `/about` 요청 → 서버가 `about.html` 통째로 보냄
* URL 바뀔 때마다 **페이지 전체 새로고침**

SPA:

* 처음에 `index.html` 한 장만 받음
* 이후에는

  * 필요한 데이터만 서버에서 JSON으로 받거나
  * 프론트 라우터(Vue Router)가 URL에 따라 **컴포넌트만 교체**
* 브라우저는 “한 페이지 안에서” 화면만 바꿔줌

장점:

* 화면 전환이 빠르고 부드러움
* 네이티브 앱처럼 끊김이 적음

단점:

* 처음 로딩 시 JS 번들을 한 번에 받기 때문에 초기 로딩이 조금 무거울 수 있음
* SEO(검색엔진 최적화)를 별도로 신경 써야 함 (CSR/SSR 파트에서 다시).

---

# 3. CSR(Client Side Rendering) vs SSR

## 3-1. CSR(Client Side Rendering)

> **브라우저(클라이언트)에서 JavaScript로 화면을 렌더링하는 방식**

동작 흐름:

1. 서버는 최소한의 HTML + JS 파일만 내려줌.
2. 브라우저가 JS를 실행해서

   * API 요청으로 데이터를 가져오고
   * 그 데이터를 이용해 DOM 구조를 만들어서 화면을 채움.
3. 이후 화면 변경은 거의 다 브라우저 안에서 처리.

HTML이 아주 단순하고 대부분 렌더링이 브라우저 안에서 일어나는 구조로 표현되어 있음. 

장점:

* 사용자와 상호작용이 많은 UI에 적합
* 서버는 API 위주로 단순해질 수 있음

단점:

* 초기 로딩 시 “콘텐츠 없는 빈 HTML + JS만 있는 상태”라서
  검색엔진이 내용을 못 읽을 수 있음 → SEO에 불리

## 3-2. SSR(Server Side Rendering)

> **서버에서 HTML을 다 만든 뒤, 완성된 페이지를 브라우저로 보내는 방식**

* 예전 전통 웹 방식과 유사
* 검색엔진이 HTML 내용을 바로 읽을 수 있어서 SEO에 유리
* 초기 화면을 빨리 보여줄 수 있음
* 단, 상호작용이 많은 SPA 느낌을 내기 위해선 추가 설정/하이브리드 구조 필요

실무에서는 보통

* SPA + CSR(순수 프론트 렌더링)
* SSR 프레임워크(Next.js, Nuxt 등)로 “하이브리드” 구성

이런 식으로 선택한다.

---

# 4. Vue란 무엇인가?

## 4-1. Vue의 정의

자료에 딱 이렇게 적혀 있었어: **“사용자 인터페이스를 구축하기 위한 JavaScript 프레임워크”**. 

Vue는:

* Evan You가 2014년에 만든 프레임워크
* React나 Angular처럼 **컴포넌트 기반**으로 UI를 만들고,
* **반응형 데이터 바인딩**을 제공해서
  “상태가 변하면 자동으로 화면이 변한다” 방식을 쉽게 쓸 수 있게 해줌.

## 4-2. Vue를 쓰는 이유(특징 정리)

자료에서 정리된 Vue 장점들을 내가 보기 쉽게 다시 써보면:

1. ✨ **반응형 데이터 바인딩**

   * `ref`, `reactive`로 상태를 만들면 템플릿과 자동 연동
   * 상태만 바꾸면 DOM은 Vue가 알아서 업데이트

2. 🧩 **컴포넌트 기반 구조**

   * UI를 재사용 가능한 컴포넌트로 쪼갤 수 있음
   * 유지보수, 협업에 좋다

3. 📜 **선언적 렌더링**

   * “어떻게 DOM을 조작할까?”가 아니라
     “이 상태일 때 화면이 이렇게 보였으면 좋겠다” 를 템플릿에 선언

4. 💡 **간결한 API & 비교적 쉬운 러닝커브**

   * React에 비해 문법이 직관적이고 템플릿 기반이라 입문자에게 친절
   * SSAFY 커리큘럼에서도 Vue를 선택한 이유 중 하나

---

# 5. Component 개념

## 5-1. 컴포넌트란?

> **UI를 재사용 가능한 작은 단위로 나눈 것**

예:

* 헤더 컴포넌트
* 사이드바 컴포넌트
* 카드 컴포넌트
* 댓글 리스트 컴포넌트

한 서비스 화면을 보면, 사실 여러 개의 컴포넌트가 조립되어 있는 구조라는 걸 예시 이미지가 보여줬다. 

장점:

* 한 번 만든 UI 조각을 여러 화면에서 재사용 가능
* 각 컴포넌트는 자기 데이터/로직/스타일을 가지므로 독립성이 높음
* 유지보수할 때 “이 기능은 이 컴포넌트만 보면 된다” 라고 경계가 생김

---

# 6. Vue Application 생성 기본 흐름 (CDN 방식 기준)

수업 자료에서는 **CDN + 순수 HTML** 환경에서 Vue를 처음 써 보는 예제를 보여줬다. 
SPA 프로젝트(Vite) 만들기 전에 기초 감각 잡는 용도.

## 6-1. 기본 HTML 구조

```html
<div id="app">
  {{ message }}
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
  const { createApp, ref } = Vue

  const app = createApp({
    setup() {
      const message = ref('hello vue!')
      return { message }
    },
  })

  app.mount('#app')
</script>
```

이 코드가 의미하는 것을 단계별로 뜯어보자.

---

## 6-2. createApp – Application Instance 만들기

```js
const { createApp, ref } = Vue

const app = createApp({
  setup() {
    const message = ref('hello vue!')
    return { message }
  },
})
```

* `createApp(옵션)` :

  * **Vue 애플리케이션 인스턴스**를 만드는 함수
  * 옵션 객체 안에 `setup()` 같은 컴포넌트 옵션을 넣는다.
* 여기서 옵션 객체는 곧 **Root Component(최상위 컴포넌트)** 역할을 한다.

  * SPA 프로젝트에서는 `App.vue`가 이 역할을 함.

---

## 6-3. mount – 어느 DOM에 붙일지 지정

```js
app.mount('#app')
```

* `mount(selector)` :

  * 해당 셀렉터를 가진 DOM 요소에 Vue 앱을 “장착”하는 함수
* 이 예제에서는 `<div id="app"></div>` 자리에
  Vue가 템플릿을 렌더링해서 넣게 된다.

정리하면:

1. `createApp()` 으로 앱 인스턴스를 만들고
2. `app.mount('#app')` 으로 실제 HTML 요소에 연결하는 구조.

---

# 7. 반응형 상태(ref)와 Vue 기본 구조

## 7-1. ref() – 반응형 상태 선언

자료에서 가장 강조하는 함수가 바로 `ref()`였음.

> **ref() = 값 하나를 반응형으로 감싸주는 함수**

```js
const count = ref(0)
```

* `count`는 “ref 객체”
* 실제 값은 `count.value`에 들어 있음

```js
console.log(count.value) // 0
count.value++
console.log(count.value) // 1
```

Vue가 이 `value`를 감시하다가 값이 바뀌면,
해당 값을 사용하고 있는 템플릿 부분만 다시 렌더링해 준다.

### 왜 .value 가 필요할까?

* JavaScript에서는 원시값(number, string…)을 그냥 변수에 넣으면
  그 값의 변화를 추적하기 어렵다.
* Vue는 `ref` 안의 `value`를 Proxy로 감싸서
  이 값이 바뀌는지 감시할 수 있도록 만드는 것.
* 그래서 **JS 코드에서는 항상 `.value`로 접근**해야 한다.

---

## 7-2. template 안에서는 .value 안 써도 되는 이유 (unwrap)

자료 뒤쪽에 “ref 변수 vs 일반 변수”, “unwrap 시 주의사항”이 나왔지. 핵심만 요약하자면:

* `setup()` 안 **JS 코드**에서는

  * `count.value` 처럼 `.value`를 붙여야 한다.
* **template 안**에서는

  * `{{ count }}`, `v-model="count"`, `:class="{ active: count > 0 }"` 처럼
    자동으로 `.value`가 풀려서(unwrapped) 실제 값이 쓰인다.

즉,

```vue
<script setup>
const count = ref(0)
</script>

<template>
  <p>{{ count }}</p>          <!-- 내부적으로는 count.value -->
  <button @click="count++">+</button> <!-- 여기서도 자동으로 value에 접근 -->
</template>
```

이렇게 쓸 수 있는 이유가 바로 **템플릿에서 ref를 자동 unwrap**해 주기 때문.

주의할 점:

* 객체/배열 ref를 다룰 때는
  `const state = ref({ id: 1 })` 와 같이 쓰고
  JS 코드에서는 `state.value.id` 형태로 접근해야 함.
* `setup`에서 구조분해할 때도 ref 특성이 유지되는지 주의
  (강의에서는 나중에 자세히 다룰 예정이라고 했으니, 여기선 “템플릿에서는 .value 생략 OK” 정도만 기억해도 충분.)

---

## 7-3. Vue 기본 구조 요약

Vue 앱이 작동하는 최소 구조는 이런 느낌이다:

1. **HTML에 마운트 지점 준비**

   ```html
   <div id="app">
     {{ message }}
   </div>
   ```

2. **createApp으로 앱 & Root Component 정의**

   ```js
   const app = createApp({
     setup() {
       const message = ref('hello vue!')
       return { message }
     },
   })
   ```

3. **mount로 Vue를 DOM에 연결**

   ```js
   app.mount('#app')
   ```

4. **템플릿과 상태 연결**

   * 템플릿: `{{ message }}`
   * 상태: `ref('hello vue!')`

상태가 변하면(Vue가 ref를 감시 중이니까),
템플릿에서 이 값을 쓰는 부분이 알아서 다시 그려진다.

---

# 8. 이벤트 리스너(v-on) 기초

마지막 부분에 `v-on` 예시도 살짝 나왔어.

```html
<div id="app">
  <p>count: {{ count }}</p>
  <button v-on:click="increase">+</button>
</div>
```

```js
const app = createApp({
  setup() {
    const count = ref(0)
    const increase = () => {
      count.value++
    }
    return { count, increase }
  },
})
```

포인트:

* `v-on:click="increase"`
  → 버튼 클릭 시 `increase` 함수를 호출
* 함수 안에서 `count.value++` 하면
  템플릿의 `{{ count }}` 가 자동으로 갱신

나중에 `v-on`은 `@click`으로 줄여 쓰고,
이벤트 수정자(`@submit.prevent`)도 배운다는 예고 정도로 이해하면 된다.

---

# 9. SEO, SPA, CSR/SSR 관계 정리

## 9-1. SEO란?

> 구글/네이버 같은 검색엔진에서 내 서비스가 잘 노출되도록
> HTML 구조와 콘텐츠를 최적화하는 작업

SPA + CSR의 문제:

* 초기에 내려오는 HTML 안에 **실제 콘텐츠가 거의 없음**
* JS를 실행해서 데이터를 받아온 뒤에야 화면이 채워짐
* 검색엔진 크롤러가 JS를 제대로 실행하지 못하는 경우,
  “내용이 없는 페이지”로 인식될 수 있다.

## 9-2. 그래서 SSR이 중요해지는 이유

* SSR 방식으로 렌더링하면

  * 서버에서 이미 HTML에 콘텐츠가 다 들어있는 상태로 응답
  * 크롤러가 HTML만 읽어도 내용 파악 가능 → SEO에 유리
* Vue 생태계에서는 **Nuxt** 같은 프레임워크가 SSR/SSG를 담당한다.

지금은 “SPA + CSR은 사용자 경험에 좋지만 SEO에는 불리할 수 있다,
이걸 보완하는 게 SSR” 정도로만 기억해도 충분하다.

---

# 10. 오늘 TIL용 핵심 요약

마지막으로, TIL에 붙여넣기 좋은 **한 장 요약** 정리해볼게.

---

## ✅ 개념 한 번에 정리

1. **Client-side Framework**

   * 브라우저에서 돌아가는 JS 프레임워크(Vue, React, Angular 등)
   * 복잡한 UI/상태를 효율적으로 관리하고 SPA를 쉽게 구현하게 해줌.

2. **SPA (Single Page Application)**

   * 하나의 HTML 페이지에서 JS로 화면을 갈아끼우는 웹앱 구조
   * 페이지간 전환이 빠르고 부드럽지만, 초기 로딩/SEO에 주의 필요.

3. **CSR vs SSR**

   * CSR: 브라우저에서 JS로 화면 렌더링 (SPA, 동적 인터랙션에 강함)
   * SSR: 서버에서 HTML을 만들어 전송 (초기 로딩/SEO에 강함)
   * 실제 서비스는 필요에 따라 둘을 적절히 조합.

4. **Vue**

   * 사용자 인터페이스를 만들기 위한 JS 프레임워크
   * 특징: 반응형 데이터 바인딩, 컴포넌트 기반, 선언적 렌더링, 간단한 API

5. **Component**

   * 재사용 가능한 UI 조각 단위
   * 한 서비스 화면은 여러 컴포넌트의 조합으로 이루어짐.

6. **Vue 앱 기본 구조 (CDN 버전)**

   * `createApp({ setup() { ... } })` 로 애플리케이션 인스턴스 생성
   * `app.mount('#app')` 으로 HTML 요소와 연결
   * 템플릿에서는 `{{ message }}` 처럼 상태를 표시

7. **ref & 반응형 상태**

   * `const count = ref(0)` : 값 하나를 반응형으로 감싼다.
   * JS 코드에서는 `count.value` 로 접근/수정
   * template에서는 `{{ count }}`, `@click="count++"` 처럼 `.value` 생략 가능
     (Vue가 자동으로 unwrap)

8. **v-on (이벤트 리스너)**

   * `v-on:click="handler"` / `@click="handler"`
   * 버튼 클릭 같은 DOM 이벤트를 Vue 함수와 연결
   * 함수 안에서 ref 값을 변경하면 화면이 자동으로 갱신

---

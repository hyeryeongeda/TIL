## 0. 큰 그림 먼저: 인증 / 권한 / 토큰 / Vue 역할

### 0-1. 인증(Authentication) vs 권한(Permission)

* **인증(Authentication)**

  * “너 누군데?” → **사용자를 확인하는 단계**
  * 로그인해서 `request.user` 가 실제 User인지, Anonymous인지 구분하는 것
* **권한(Permission)**

  * “너 이 행동 해도 돼?” → **무엇을 할 수 있는지 결정하는 단계**
  * 예: 로그인한 사람만 글쓰기 허용, 관리자만 삭제 허용 등

> DRF에서
>
> * 인증 실패 → 보통 **401 Unauthorized**
> * 인증은 됐는데 권한 없음 → **403 Forbidden**

---

### 0-2. 왜 굳이 이렇게까지 나누나?

* 웹 서비스는 “누구나 볼 수 있는 정보”와 “로그인해야만 볼/쓸 수 있는 정보”가 섞여 있음
* 예: 게시글 목록은 아무나 볼 수 있지만, **글 작성 / 수정 / 삭제는 로그인 사용자만**
* 이걸 Django+DRF에서 체계적으로 관리하기 위해

  * **인증 시스템 (Authentication system)**
  * **권한 시스템 (Permissions)**
    를 분리해서 제공하는 것.

---

## 1. DRF에서 인증 준비 (Article에 user 연결하기)

자료 앞부분(준비 1/4 ~ 4/4)은 “게시글에 작성자(User)를 연결하는 작업”이야.

### 1-1. 모델에서 user 필드 추가

```python
# articles/models.py
from django.conf import settings

class Article(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    title = models.CharField(max_length=...)
    content = models.TextField()
    ...
```

* `settings.AUTH_USER_MODEL` : 현재 프로젝트에서 사용하는 User 모델
* `on_delete=models.CASCADE` : 유저가 탈퇴하면 그 유저가 쓴 글도 함께 삭제

> 의미
>
> * 이제 Article은 “**누가 작성했는지**” 정보를 항상 가지고 있게 됨.

---

### 1-2. Serializer에서 user는 read_only로

```python
# articles/serializers.py
class ArticleSerializer(serializers.ModelSerializer):
    class Meta:
        model = Article
        fields = '__all__'
        read_only_fields = ('user',)
```

* 글을 만들 때, 클라이언트(프론트)에서 `user` 값을 직접 보내지 못하게 막는 설정
* 왜? **“user는 항상 로그인된 사람(request.user)”** 로 서버에서 정해줘야 하기 때문

---

### 1-3. View에서 request.user를 저장

```python
# articles/views.py
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_list(request):
    serializer = ArticleSerializer(data=request.data)
    if serializer.is_valid(raise_exception=True):
        serializer.save(user=request.user)
        ...
```

* `serializer.save(user=request.user)`
  → Article의 `user` 필드를 **현재 로그인한 사용자**로 자동 채움
* 이때 `permission_classes`로 `IsAuthenticated`를 걸었기 때문에
  **로그인하지 않으면 애초에 글을 만들 수 없음**

---

### 1-4. DB / fixture 정리

* user 필드가 추가되었으니

  * `makemigrations` + `migrate`
  * 기존 `articles.json` fixture에 `user` 정보 추가
* 요약: **모든 Article 데이터는 반드시 “어떤 User의 글인지” 가지도록 구조를 바꾼다.**

---

## 2. 인증 정책 전반: Authentication 설정

### 2-1. DRF 인증의 개념

* HTTP 요청이 들어오면 DRF는

  1. 설정된 **인증 클래스(authentication_classes)**를 이용해
     헤더, 쿠키 등에서 “누가 요청했는지” 확인하고
  2. 결과를 `request.user`, `request.auth`에 채워줌
* 이 작업은 “권한 검사”보다 먼저 일어남.

---

### 2-2. 전역 설정 vs View 개별 설정

#### 1) 전역 설정 (settings.py)

```python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
        # 나중에 TokenAuthentication 추가
    ],
}
```

* **프로젝트 전체**에 기본 적용되는 인증 방식들

#### 2) View 개별 설정

```python
from rest_framework.decorators import api_view, authentication_classes
from rest_framework.authentication import TokenAuthentication, BasicAuthentication

@api_view(['GET'])
@authentication_classes([TokenAuthentication, BasicAuthentication])
def some_view(request):
    ...
```

* 이 View에 한해서만 다른 인증 방식을 쓰고 싶을 때 사용

---

### 2-3. DRF가 제공하는 대표 인증 방식들

슬라이드에서는 4가지 정도를 소개해.

1. **BasicAuthentication**

   * 요청 때마다 `id:password`를 Base64로 인코딩해서 보내는 방식
   * 브라우저 테스트에는 간단하지만, 실제 서비스에서는 거의 안 씀
2. **SessionAuthentication**

   * Django의 기존 세션 기반 로그인과 연동되는 방식
   * 서버가 세션 쿠키로 사용자를 기억하는 전통적인 웹 방식
3. **TokenAuthentication**

   * 우리가 지금 배우는 “Token 기반 인증”
4. (참고용) **RemoteUserAuthentication** 등

우리는 **“SPA(Vue) + DRF 백엔드 분리 구조”**라서
프론트가 매 요청마다 토큰을 들고 다니기 좋은 **TokenAuthentication**을 사용한다.

---

## 3. TokenAuthentication 개념

### 3-1. 토큰 기반 인증 흐름 (중요)
 

1. 사용자가 아이디/비밀번호로 서버에 로그인 요청
2. 서버는 비밀번호가 맞으면 DB에 **Token(랜덤 문자열)과 User를 매핑해서 저장**
3. 서버는 이 토큰을 클라이언트에 돌려줌
4. 이후부터 클라이언트는 요청할 때마다 HTTP 헤더에

   ```http
   Authorization: Token <발급된_토큰값>
   ```

   을 붙여서 보냄
5. 서버는 이 토큰이 DB에 있는지 확인해보고, 해당 User를 `request.user`로 세팅
6. 인증 성공 시 권한 검사 → View 로직 실행

> 포인트
>
> * **로그인은 “토큰 발급받는 행위”**로 생각하면 된다.
> * 이후 모든 보호된 API 요청은 “이 토큰을 들고 가는지”로 인증한다.

---

### 3-2. TokenAuthentication 설정 순서

1. settings.py – REST_FRAMEWORK에 Token 인증 추가

   ```python
   REST_FRAMEWORK = {
       'DEFAULT_AUTHENTICATION_CLASSES': [
           'rest_framework.authentication.TokenAuthentication',
           'rest_framework.authentication.SessionAuthentication',
       ],
   }
   ```
2. `INSTALLED_APPS`에 토큰 앱 등록

   ```python
   INSTALLED_APPS = [
       ...
       'rest_framework.authtoken',
   ]
   ```
3. `python manage.py migrate`
   → `authtoken_token` 테이블 생성 (Token과 User 매핑 저장용)

---

## 4. dj-rest-auth: 인증 API를 쉽게 만들어 주는 라이브러리

### 4-1. dj-rest-auth가 해주는 일

* 로그인, 로그아웃, 비밀번호 변경/초기화, 소셜 로그인 등 **인증 관련 API들을 자동으로 제공**하는 라이브러리
* `dj-rest-auth` + `django-allauth` 조합으로

  * 회원가입, 이메일 검증 등도 쉽게 구성 가능
* 우리는 이 중 **로그인/회원가입 + Token 발급** 기능을 주로 사용

---

### 4-2. 설치 & 기본 설정 흐름

1. 설치

   ```bash
   pip install dj-rest-auth
   ```
2. `INSTALLED_APPS` 에 추가

   * `dj_rest_auth`,
   * (회원가입 기능까지 할 때) `allauth`, `allauth.account`, `dj_rest_auth.registration` 등
3. urls.py 에 엔드포인트 추가

   ```python
   urlpatterns = [
       path('accounts/', include('dj_rest_auth.urls')),
       path('accounts/registration/', include('dj_rest_auth.registration.urls')),
   ]
   ```
4. (회원가입을 위해) `SITE_ID`, context processors 등 allauth 설정
5. migrate

이렇게 하면 자동으로

* `/accounts/login/` : 로그인 → Token 발급
* `/accounts/logout/`
* `/accounts/registration/` : 회원가입
  같은 API를 사용할 수 있음.

---

### 4-3. 토큰 발급 & 활용

#### 1) 토큰 발급

* 회원가입 → 로그인 과정을 거치면
  DRF는 해당 User에 대한 Token을 생성하고, 응답으로 돌려줌
* 이 토큰은 DB의 `authtoken_token` 테이블에 저장됨

#### 2) 토큰 확인

* 관리자로 admin 페이지 들어가서 `Token` 테이블을 보면
  어떤 유저에게 어떤 토큰이 발급됐는지 확인 가능

#### 3) 토큰 사용(중요)

* Postman, Vue, axios 등에서 보호된 API를 호출할 때
  요청 헤더에 다음처럼 넣어야 함:

```http
Authorization: Token abcd1234.....
```

* 이때 DRF는 `TokenAuthentication`을 통해

  * 헤더에서 토큰 읽고
  * DB에서 유효한지 확인한 뒤
  * 연결된 User를 `request.user`로 세팅

---

## 5. 권한 with DRF (Permissions)

이제부터는 “**로그인 후에, 무엇을 허용/차단할까**”에 대한 이야기.

### 5-1. 권한 정책 설정 위치

1. **전역 설정 (settings.py)**

```python
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
}
```

* 아무 설정 안 하면 기본은 `AllowAny` (모든 요청 허용)
* 여기서 기본값을 `IsAuthenticated`로 바꾸면
  **모든 View가 로그인 필요**로 바뀜 (필요에 따라 사용)

2. **View 개별 설정**

```python
from rest_framework.permissions import IsAuthenticated
from rest_framework.decorators import permission_classes

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_list(request):
    ...
```

* 이 View는 인증된 사용자만 접근할 수 있음
* 로그인 안 하고 접근 → 401 또는 403

---

### 5-2. DRF 주요 Permission 클래스 4개

1. **IsAuthenticated**

   * “**로그인한 사용자만** 허용”
   * 인증되지 않은 요청은 거절

2. **IsAdminUser**

   * “**is_staff=True**인 관리자만 허용”
   * 운영툴, 관리자 페이지, 중요 리소스 삭제 등에 사용

3. **IsAuthenticatedOrReadOnly**

   * 읽기(GET, HEAD, OPTIONS)는 아무나
   * 쓰기(POST, PUT, PATCH, DELETE)는 로그인한 사용자만
   * 블로그, 게시판, 댓글 API에 자주 쓰는 패턴

4. **AllowAny**

   * 누구나 접근 가능 (인증 여부 상관 없음)
   * 공개 정보 API에 사용

---

### 5-3. 401 vs 403 정리

* **401 Unauthorized**

  * “넌 인증 자체가 안 됐어 (로그인부터 해와).”
  * 토큰이 없거나, 잘못된 토큰 등

* **403 Forbidden (Permission Denied)**

  * “로그인은 됐는데, 이 작업을 할 권한은 없어.”
  * 일반 유저가 관리자 전용 API에 접근하는 경우 등

---

## 6. IsAuthenticated 실습 흐름 이해하기

### 6-1. 기본 권한 AllowAny → 누구나 접근

```python
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],
}
```

* 로그인 여부와 상관 없이 모든 API 접근 가능

---

### 6-2. 특정 View만 로그인 필수로 만들기

```python
from rest_framework.permissions import IsAuthenticated

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def article_list(request):
    ...
```

* 이 경우

  * GET(목록 조회)은 AllowAny로 열어두고,
  * POST(글 작성)에는 `IsAuthenticated`를 걸어서
  * 로그인한 사용자만 글을 쓸 수 있게 할 수 있음
* 토큰 없이 POST 요청 → 401 / 403

---

### 6-3. 관리자만 허용하려면?

```python
from rest_framework.permissions import IsAdminUser

@api_view(['DELETE'])
@permission_classes([IsAdminUser])
def article_delete(request, pk):
    ...
```

* 이제 staff 권한이 있는 관리자만 삭제 가능
* 일반 로그인 유저 → 403 Forbidden

---

## 7. 마지막 요약 표 

> ### 키워드 & 연결관계

| 키워드                        | 역할                                      | 예시 코드/값                                                 |
| -------------------------- | --------------------------------------- | ------------------------------------------------------- |
| **인증 (Authentication)**    | “누구인지 확인”                               | `DEFAULT_AUTHENTICATION_CLASSES`, `TokenAuthentication` |
| **권한 (Permission)**        | “뭘 해도 되는지”                              | `DEFAULT_PERMISSION_CLASSES`, `IsAuthenticated`         |
| **토큰(Token)**              | 로그인 성공 시 발급되는 문자열. 매 요청마다 들고 다니며 자신을 증명 | `Authorization: Token <value>`                          |
| **Authentication Classes** | 어떤 방식으로 인증할지                            | `SessionAuthentication`, `TokenAuthentication`          |
| **Permission Classes**     | 어떤 조건을 만족해야 이 View를 사용할 수 있는지           | `IsAuthenticated`, `AllowAny` 등                         |
| **401**                    | 인증 실패                                   | 토큰 없음, 잘못된 토큰                                           |
| **403**                    | 권한 없음                                   | 일반 유저가 관리자-only API 접근                                  |

---

## 8. Vue + DRF에서 인증 역할 분담
 “프론트와 백엔드가 인증을 어떻게 나눠 갖나?” 

### 8-1. 백엔드(DRF)의 역할

* User 모델, 토큰 발급/저장, 로그인/로그아웃 API 제공 (dj-rest-auth)
* 인증 정책 (`DEFAULT_AUTHENTICATION_CLASSES`)
* 권한 정책 (`DEFAULT_PERMISSION_CLASSES`, `permission_classes`)
* 각 API 앞단에서 “누군지, 할 수 있는 사람인지” 검사

### 8-2. 프론트(Vue)의 역할

* 회원가입/로그인 폼 제공
* 로그인 성공 시 **토큰을 받아서 저장** (예: Pinia, localStorage)
* API 요청 보낼 때마다 axios 헤더에

  ```js
  axios.defaults.headers.common['Authorization'] = `Token ${token}`
  ```

  이런 식으로 붙여서 보냄
* 로그아웃 시 토큰 삭제

---
